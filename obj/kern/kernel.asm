
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 a0 13 00 	lgdtl  0x13a018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

        # Leave a few words on the stack for the user trap frame
	movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
f0100033:	bc bc 9f 13 f0       	mov    $0xf0139fbc,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 02 00 00 00       	call   f010003f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <FOS_initialize>:
extern uint32 isBufferingEnabled();


//First ever function called in FOS kernel
void FOS_initialize()
{
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_uninitialized_data_section[], end_of_kernel[];

	// Before doing anything else,
	// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
	// This ensures that all static/global variables start with zero value.
	memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100045:	ba c0 67 51 f0       	mov    $0xf05167c0,%edx
f010004a:	b8 c1 9e 42 f0       	mov    $0xf0429ec1,%eax
f010004f:	29 c2                	sub    %eax,%edx
f0100051:	89 d0                	mov    %edx,%eax
f0100053:	83 ec 04             	sub    $0x4,%esp
f0100056:	50                   	push   %eax
f0100057:	6a 00                	push   $0x0
f0100059:	68 c1 9e 42 f0       	push   $0xf0429ec1
f010005e:	e8 3b ec 00 00       	call   f010ec9e <memset>
f0100063:	83 c4 10             	add    $0x10,%esp

	// Initialize the console.
	// Can't call cprintf until after we do this!
	console_initialize();
f0100066:	e8 a7 09 00 00       	call   f0100a12 <console_initialize>

	//print welcome message
	print_welcome_message();
f010006b:	e8 73 00 00 00       	call   f01000e3 <print_welcome_message>

	// Lab 2 memory management initialization functions
	detect_memory();
f0100070:	e8 40 1d 00 00       	call   f0101db5 <detect_memory>
	initialize_kernel_VM();
f0100075:	e8 81 23 00 00       	call   f01023fb <initialize_kernel_VM>
	initialize_paging();
f010007a:	e8 9f 27 00 00       	call   f010281e <initialize_paging>
//	page_check();


	// Lab 3 user environment initialization functions
	env_init();
f010007f:	e8 54 54 00 00       	call   f01054d8 <env_init>
	idt_init();
f0100084:	e8 23 60 00 00       	call   f01060ac <idt_init>
	setPageReplacmentAlgorithmLRU();
f0100089:	e8 ab 74 00 00       	call   f0107539 <setPageReplacmentAlgorithmLRU>
	setUHeapPlacementStrategyFIRSTFIT();
f010008e:	e8 a6 44 00 00       	call   f0104539 <setUHeapPlacementStrategyFIRSTFIT>
	enableBuffering(0);
f0100093:	83 ec 0c             	sub    $0xc,%esp
f0100096:	6a 00                	push   $0x0
f0100098:	e8 60 75 00 00       	call   f01075fd <enableBuffering>
f010009d:	83 c4 10             	add    $0x10,%esp
	//enableModifiedBuffer(1) ;
	enableModifiedBuffer(0) ;
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	6a 00                	push   $0x0
f01000a5:	e8 3b 75 00 00       	call   f01075e5 <enableModifiedBuffer>
f01000aa:	83 c4 10             	add    $0x10,%esp

	// Lab 4 multitasking initialization functions
	pic_init();
f01000ad:	e8 da 5d 00 00       	call   f0105e8c <pic_init>
	kclock_start();
f01000b2:	e8 fc 5b 00 00       	call   f0105cb3 <kclock_start>
	sched_init() ;
f01000b7:	e8 ea 7e 00 00       	call   f0107fa6 <sched_init>
	//cprintf("Int Flag before = %d\n", read_eflags() & FL_IF) ;

	// start the kernel command prompt.
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f01000bc:	83 ec 0c             	sub    $0xc,%esp
f01000bf:	68 00 f7 10 f0       	push   $0xf010f700
f01000c4:	e8 92 5f 00 00       	call   f010605b <cprintf>
f01000c9:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01000cc:	83 ec 0c             	sub    $0xc,%esp
f01000cf:	68 2c f7 10 f0       	push   $0xf010f72c
f01000d4:	e8 82 5f 00 00       	call   f010605b <cprintf>
f01000d9:	83 c4 10             	add    $0x10,%esp
		run_command_prompt();
f01000dc:	e8 ef 0d 00 00       	call   f0100ed0 <run_command_prompt>
	}
f01000e1:	eb d9                	jmp    f01000bc <FOS_initialize+0x7d>

f01000e3 <print_welcome_message>:
}


void print_welcome_message()
{
f01000e3:	55                   	push   %ebp
f01000e4:	89 e5                	mov    %esp,%ebp
f01000e6:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01000e9:	83 ec 0c             	sub    $0xc,%esp
f01000ec:	68 51 f7 10 f0       	push   $0xf010f751
f01000f1:	e8 65 5f 00 00       	call   f010605b <cprintf>
f01000f6:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01000f9:	83 ec 0c             	sub    $0xc,%esp
f01000fc:	68 58 f7 10 f0       	push   $0xf010f758
f0100101:	e8 55 5f 00 00       	call   f010605b <cprintf>
f0100106:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100109:	83 ec 0c             	sub    $0xc,%esp
f010010c:	68 a0 f7 10 f0       	push   $0xf010f7a0
f0100111:	e8 45 5f 00 00       	call   f010605b <cprintf>
f0100116:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f0100119:	83 ec 0c             	sub    $0xc,%esp
f010011c:	68 e8 f7 10 f0       	push   $0xf010f7e8
f0100121:	e8 35 5f 00 00       	call   f010605b <cprintf>
f0100126:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100129:	83 ec 0c             	sub    $0xc,%esp
f010012c:	68 a0 f7 10 f0       	push   $0xf010f7a0
f0100131:	e8 25 5f 00 00       	call   f010605b <cprintf>
f0100136:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100139:	83 ec 0c             	sub    $0xc,%esp
f010013c:	68 58 f7 10 f0       	push   $0xf010f758
f0100141:	e8 15 5f 00 00       	call   f010605b <cprintf>
f0100146:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100149:	83 ec 0c             	sub    $0xc,%esp
f010014c:	68 2d f8 10 f0       	push   $0xf010f82d
f0100151:	e8 05 5f 00 00       	call   f010605b <cprintf>
f0100156:	83 c4 10             	add    $0x10,%esp
}
f0100159:	90                   	nop
f010015a:	c9                   	leave  
f010015b:	c3                   	ret    

f010015c <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel command prompt.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f010015c:	55                   	push   %ebp
f010015d:	89 e5                	mov    %esp,%ebp
f010015f:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100162:	8b 45 10             	mov    0x10(%ebp),%eax
f0100165:	a3 e0 9e 42 f0       	mov    %eax,0xf0429ee0

	va_start(ap, fmt);
f010016a:	8d 45 10             	lea    0x10(%ebp),%eax
f010016d:	83 c0 04             	add    $0x4,%eax
f0100170:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f0100173:	83 ec 04             	sub    $0x4,%esp
f0100176:	ff 75 0c             	pushl  0xc(%ebp)
f0100179:	ff 75 08             	pushl  0x8(%ebp)
f010017c:	68 32 f8 10 f0       	push   $0xf010f832
f0100181:	e8 d5 5e 00 00       	call   f010605b <cprintf>
f0100186:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100189:	8b 45 10             	mov    0x10(%ebp),%eax
f010018c:	83 ec 08             	sub    $0x8,%esp
f010018f:	ff 75 f4             	pushl  -0xc(%ebp)
f0100192:	50                   	push   %eax
f0100193:	e8 9a 5e 00 00       	call   f0106032 <vcprintf>
f0100198:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010019b:	83 ec 0c             	sub    $0xc,%esp
f010019e:	68 4b f8 10 f0       	push   $0xf010f84b
f01001a3:	e8 b3 5e 00 00       	call   f010605b <cprintf>
f01001a8:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (curenv != NULL && curenv->env_status == ENV_READY)
f01001ab:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01001b0:	85 c0                	test   %eax,%eax
f01001b2:	74 12                	je     f01001c6 <_panic+0x6a>
f01001b4:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01001b9:	8b 40 54             	mov    0x54(%eax),%eax
f01001bc:	83 f8 01             	cmp    $0x1,%eax
f01001bf:	75 05                	jne    f01001c6 <_panic+0x6a>
	{
		//2015
		env_exit();
f01001c1:	e8 74 59 00 00       	call   f0105b3a <env_exit>
		//env_run_cmd_prmpt() ;
	}

	//2015
	fos_scheduler();
f01001c6:	e8 64 7d 00 00       	call   f0107f2f <fos_scheduler>

f01001cb <_warn>:

}

/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01001cb:	55                   	push   %ebp
f01001cc:	89 e5                	mov    %esp,%ebp
f01001ce:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01001d1:	8d 45 10             	lea    0x10(%ebp),%eax
f01001d4:	83 c0 04             	add    $0x4,%eax
f01001d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01001da:	83 ec 04             	sub    $0x4,%esp
f01001dd:	ff 75 0c             	pushl  0xc(%ebp)
f01001e0:	ff 75 08             	pushl  0x8(%ebp)
f01001e3:	68 4d f8 10 f0       	push   $0xf010f84d
f01001e8:	e8 6e 5e 00 00       	call   f010605b <cprintf>
f01001ed:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01001f0:	8b 45 10             	mov    0x10(%ebp),%eax
f01001f3:	83 ec 08             	sub    $0x8,%esp
f01001f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01001f9:	50                   	push   %eax
f01001fa:	e8 33 5e 00 00       	call   f0106032 <vcprintf>
f01001ff:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100202:	83 ec 0c             	sub    $0xc,%esp
f0100205:	68 4b f8 10 f0       	push   $0xf010f84b
f010020a:	e8 4c 5e 00 00       	call   f010605b <cprintf>
f010020f:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f0100212:	90                   	nop
f0100213:	c9                   	leave  
f0100214:	c3                   	ret    

f0100215 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100215:	55                   	push   %ebp
f0100216:	89 e5                	mov    %esp,%ebp
f0100218:	83 ec 10             	sub    $0x10,%esp
f010021b:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100222:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100225:	89 c2                	mov    %eax,%edx
f0100227:	ec                   	in     (%dx),%al
f0100228:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f010022b:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f010022e:	0f b6 c0             	movzbl %al,%eax
f0100231:	83 e0 01             	and    $0x1,%eax
f0100234:	85 c0                	test   %eax,%eax
f0100236:	75 07                	jne    f010023f <serial_proc_data+0x2a>
		return -1;
f0100238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010023d:	eb 16                	jmp    f0100255 <serial_proc_data+0x40>
f010023f:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100246:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100249:	89 c2                	mov    %eax,%edx
f010024b:	ec                   	in     (%dx),%al
f010024c:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010024f:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f0100252:	0f b6 c0             	movzbl %al,%eax
}
f0100255:	c9                   	leave  
f0100256:	c3                   	ret    

f0100257 <serial_intr>:

void
serial_intr(void)
{
f0100257:	55                   	push   %ebp
f0100258:	89 e5                	mov    %esp,%ebp
f010025a:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f010025d:	a1 00 9f 42 f0       	mov    0xf0429f00,%eax
f0100262:	85 c0                	test   %eax,%eax
f0100264:	74 10                	je     f0100276 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100266:	83 ec 0c             	sub    $0xc,%esp
f0100269:	68 15 02 10 f0       	push   $0xf0100215
f010026e:	e8 e4 05 00 00       	call   f0100857 <cons_intr>
f0100273:	83 c4 10             	add    $0x10,%esp
}
f0100276:	90                   	nop
f0100277:	c9                   	leave  
f0100278:	c3                   	ret    

f0100279 <serial_init>:

void
serial_init(void)
{
f0100279:	55                   	push   %ebp
f010027a:	89 e5                	mov    %esp,%ebp
f010027c:	83 ec 40             	sub    $0x40,%esp
f010027f:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%ebp)
f0100286:	c6 45 ce 00          	movb   $0x0,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010028a:	8a 45 ce             	mov    -0x32(%ebp),%al
f010028d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0100290:	ee                   	out    %al,(%dx)
f0100291:	c7 45 f8 fb 03 00 00 	movl   $0x3fb,-0x8(%ebp)
f0100298:	c6 45 cf 80          	movb   $0x80,-0x31(%ebp)
f010029c:	8a 45 cf             	mov    -0x31(%ebp),%al
f010029f:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01002a2:	ee                   	out    %al,(%dx)
f01002a3:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%ebp)
f01002aa:	c6 45 d0 0c          	movb   $0xc,-0x30(%ebp)
f01002ae:	8a 45 d0             	mov    -0x30(%ebp),%al
f01002b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01002b4:	ee                   	out    %al,(%dx)
f01002b5:	c7 45 f0 f9 03 00 00 	movl   $0x3f9,-0x10(%ebp)
f01002bc:	c6 45 d1 00          	movb   $0x0,-0x2f(%ebp)
f01002c0:	8a 45 d1             	mov    -0x2f(%ebp),%al
f01002c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01002c6:	ee                   	out    %al,(%dx)
f01002c7:	c7 45 ec fb 03 00 00 	movl   $0x3fb,-0x14(%ebp)
f01002ce:	c6 45 d2 03          	movb   $0x3,-0x2e(%ebp)
f01002d2:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01002d5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01002d8:	ee                   	out    %al,(%dx)
f01002d9:	c7 45 e8 fc 03 00 00 	movl   $0x3fc,-0x18(%ebp)
f01002e0:	c6 45 d3 00          	movb   $0x0,-0x2d(%ebp)
f01002e4:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01002e7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01002ea:	ee                   	out    %al,(%dx)
f01002eb:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%ebp)
f01002f2:	c6 45 d4 01          	movb   $0x1,-0x2c(%ebp)
f01002f6:	8a 45 d4             	mov    -0x2c(%ebp),%al
f01002f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01002fc:	ee                   	out    %al,(%dx)
f01002fd:	c7 45 e0 fd 03 00 00 	movl   $0x3fd,-0x20(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100304:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0100307:	89 c2                	mov    %eax,%edx
f0100309:	ec                   	in     (%dx),%al
f010030a:	88 45 d5             	mov    %al,-0x2b(%ebp)
	return data;
f010030d:	8a 45 d5             	mov    -0x2b(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100310:	3c ff                	cmp    $0xff,%al
f0100312:	0f 95 c0             	setne  %al
f0100315:	0f b6 c0             	movzbl %al,%eax
f0100318:	a3 00 9f 42 f0       	mov    %eax,0xf0429f00
f010031d:	c7 45 dc fa 03 00 00 	movl   $0x3fa,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100324:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100327:	89 c2                	mov    %eax,%edx
f0100329:	ec                   	in     (%dx),%al
f010032a:	88 45 d6             	mov    %al,-0x2a(%ebp)
f010032d:	c7 45 d8 f8 03 00 00 	movl   $0x3f8,-0x28(%ebp)
f0100334:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100337:	89 c2                	mov    %eax,%edx
f0100339:	ec                   	in     (%dx),%al
f010033a:	88 45 d7             	mov    %al,-0x29(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

}
f010033d:	90                   	nop
f010033e:	c9                   	leave  
f010033f:	c3                   	ret    

f0100340 <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f0100340:	55                   	push   %ebp
f0100341:	89 e5                	mov    %esp,%ebp
f0100343:	83 ec 20             	sub    $0x20,%esp
f0100346:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f010034d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100350:	89 c2                	mov    %eax,%edx
f0100352:	ec                   	in     (%dx),%al
f0100353:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100356:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f010035d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100360:	89 c2                	mov    %eax,%edx
f0100362:	ec                   	in     (%dx),%al
f0100363:	88 45 ed             	mov    %al,-0x13(%ebp)
f0100366:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f010036d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100370:	89 c2                	mov    %eax,%edx
f0100372:	ec                   	in     (%dx),%al
f0100373:	88 45 ee             	mov    %al,-0x12(%ebp)
f0100376:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f010037d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100380:	89 c2                	mov    %eax,%edx
f0100382:	ec                   	in     (%dx),%al
f0100383:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f0100386:	90                   	nop
f0100387:	c9                   	leave  
f0100388:	c3                   	ret    

f0100389 <lpt_putc>:

static void
lpt_putc(int c)
{
f0100389:	55                   	push   %ebp
f010038a:	89 e5                	mov    %esp,%ebp
f010038c:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f010038f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0100396:	eb 08                	jmp    f01003a0 <lpt_putc+0x17>
		delay();
f0100398:	e8 a3 ff ff ff       	call   f0100340 <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f010039d:	ff 45 fc             	incl   -0x4(%ebp)
f01003a0:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01003a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01003aa:	89 c2                	mov    %eax,%edx
f01003ac:	ec                   	in     (%dx),%al
f01003ad:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01003b0:	8a 45 eb             	mov    -0x15(%ebp),%al
f01003b3:	84 c0                	test   %al,%al
f01003b5:	78 09                	js     f01003c0 <lpt_putc+0x37>
f01003b7:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01003be:	7e d8                	jle    f0100398 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01003c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01003c3:	0f b6 c0             	movzbl %al,%eax
f01003c6:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f01003cd:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01003d0:	8a 45 e8             	mov    -0x18(%ebp),%al
f01003d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01003d6:	ee                   	out    %al,(%dx)
f01003d7:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f01003de:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f01003e2:	8a 45 e9             	mov    -0x17(%ebp),%al
f01003e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01003e8:	ee                   	out    %al,(%dx)
f01003e9:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f01003f0:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f01003f4:	8a 45 ea             	mov    -0x16(%ebp),%al
f01003f7:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01003fa:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f01003fb:	90                   	nop
f01003fc:	c9                   	leave  
f01003fd:	c3                   	ret    

f01003fe <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f01003fe:	55                   	push   %ebp
f01003ff:	89 e5                	mov    %esp,%ebp
f0100401:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f0100404:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f010040b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010040e:	66 8b 00             	mov    (%eax),%ax
f0100411:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100415:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100418:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f010041d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100420:	66 8b 00             	mov    (%eax),%ax
f0100423:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100427:	74 13                	je     f010043c <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100429:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f0100430:	c7 05 04 9f 42 f0 b4 	movl   $0x3b4,0xf0429f04
f0100437:	03 00 00 
f010043a:	eb 14                	jmp    f0100450 <cga_init+0x52>
	} else {
		*cp = was;
f010043c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010043f:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f0100443:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100446:	c7 05 04 9f 42 f0 d4 	movl   $0x3d4,0xf0429f04
f010044d:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f0100450:	a1 04 9f 42 f0       	mov    0xf0429f04,%eax
f0100455:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100458:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f010045c:	8a 45 e0             	mov    -0x20(%ebp),%al
f010045f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100462:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f0100463:	a1 04 9f 42 f0       	mov    0xf0429f04,%eax
f0100468:	40                   	inc    %eax
f0100469:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010046c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010046f:	89 c2                	mov    %eax,%edx
f0100471:	ec                   	in     (%dx),%al
f0100472:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f0100475:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100478:	0f b6 c0             	movzbl %al,%eax
f010047b:	c1 e0 08             	shl    $0x8,%eax
f010047e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f0100481:	a1 04 9f 42 f0       	mov    0xf0429f04,%eax
f0100486:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100489:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010048d:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100490:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100493:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f0100494:	a1 04 9f 42 f0       	mov    0xf0429f04,%eax
f0100499:	40                   	inc    %eax
f010049a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010049d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01004a0:	89 c2                	mov    %eax,%edx
f01004a2:	ec                   	in     (%dx),%al
f01004a3:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01004a6:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01004a9:	0f b6 c0             	movzbl %al,%eax
f01004ac:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01004af:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01004b2:	a3 08 9f 42 f0       	mov    %eax,0xf0429f08
	crt_pos = pos;
f01004b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004ba:	66 a3 0c 9f 42 f0    	mov    %ax,0xf0429f0c
}
f01004c0:	90                   	nop
f01004c1:	c9                   	leave  
f01004c2:	c3                   	ret    

f01004c3 <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01004c3:	55                   	push   %ebp
f01004c4:	89 e5                	mov    %esp,%ebp
f01004c6:	53                   	push   %ebx
f01004c7:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f01004ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01004cd:	b0 00                	mov    $0x0,%al
f01004cf:	85 c0                	test   %eax,%eax
f01004d1:	75 07                	jne    f01004da <cga_putc+0x17>
		c |= 0x0700;
f01004d3:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f01004da:	8b 45 08             	mov    0x8(%ebp),%eax
f01004dd:	0f b6 c0             	movzbl %al,%eax
f01004e0:	83 f8 09             	cmp    $0x9,%eax
f01004e3:	0f 84 94 00 00 00    	je     f010057d <cga_putc+0xba>
f01004e9:	83 f8 09             	cmp    $0x9,%eax
f01004ec:	7f 0a                	jg     f01004f8 <cga_putc+0x35>
f01004ee:	83 f8 08             	cmp    $0x8,%eax
f01004f1:	74 14                	je     f0100507 <cga_putc+0x44>
f01004f3:	e9 c8 00 00 00       	jmp    f01005c0 <cga_putc+0xfd>
f01004f8:	83 f8 0a             	cmp    $0xa,%eax
f01004fb:	74 49                	je     f0100546 <cga_putc+0x83>
f01004fd:	83 f8 0d             	cmp    $0xd,%eax
f0100500:	74 53                	je     f0100555 <cga_putc+0x92>
f0100502:	e9 b9 00 00 00       	jmp    f01005c0 <cga_putc+0xfd>
	case '\b':
		if (crt_pos > 0) {
f0100507:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f010050d:	66 85 c0             	test   %ax,%ax
f0100510:	0f 84 d0 00 00 00    	je     f01005e6 <cga_putc+0x123>
			crt_pos--;
f0100516:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f010051c:	48                   	dec    %eax
f010051d:	66 a3 0c 9f 42 f0    	mov    %ax,0xf0429f0c
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100523:	8b 15 08 9f 42 f0    	mov    0xf0429f08,%edx
f0100529:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f010052f:	0f b7 c0             	movzwl %ax,%eax
f0100532:	01 c0                	add    %eax,%eax
f0100534:	01 c2                	add    %eax,%edx
f0100536:	8b 45 08             	mov    0x8(%ebp),%eax
f0100539:	b0 00                	mov    $0x0,%al
f010053b:	83 c8 20             	or     $0x20,%eax
f010053e:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100541:	e9 a0 00 00 00       	jmp    f01005e6 <cga_putc+0x123>
	case '\n':
		crt_pos += CRT_COLS;
f0100546:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f010054c:	83 c0 50             	add    $0x50,%eax
f010054f:	66 a3 0c 9f 42 f0    	mov    %ax,0xf0429f0c
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f0100555:	66 8b 0d 0c 9f 42 f0 	mov    0xf0429f0c,%cx
f010055c:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f0100562:	bb 50 00 00 00       	mov    $0x50,%ebx
f0100567:	ba 00 00 00 00       	mov    $0x0,%edx
f010056c:	66 f7 f3             	div    %bx
f010056f:	89 d0                	mov    %edx,%eax
f0100571:	29 c1                	sub    %eax,%ecx
f0100573:	89 c8                	mov    %ecx,%eax
f0100575:	66 a3 0c 9f 42 f0    	mov    %ax,0xf0429f0c
		break;
f010057b:	eb 6a                	jmp    f01005e7 <cga_putc+0x124>
	case '\t':
		cons_putc(' ');
f010057d:	83 ec 0c             	sub    $0xc,%esp
f0100580:	6a 20                	push   $0x20
f0100582:	e8 69 04 00 00       	call   f01009f0 <cons_putc>
f0100587:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	6a 20                	push   $0x20
f010058f:	e8 5c 04 00 00       	call   f01009f0 <cons_putc>
f0100594:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100597:	83 ec 0c             	sub    $0xc,%esp
f010059a:	6a 20                	push   $0x20
f010059c:	e8 4f 04 00 00       	call   f01009f0 <cons_putc>
f01005a1:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01005a4:	83 ec 0c             	sub    $0xc,%esp
f01005a7:	6a 20                	push   $0x20
f01005a9:	e8 42 04 00 00       	call   f01009f0 <cons_putc>
f01005ae:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01005b1:	83 ec 0c             	sub    $0xc,%esp
f01005b4:	6a 20                	push   $0x20
f01005b6:	e8 35 04 00 00       	call   f01009f0 <cons_putc>
f01005bb:	83 c4 10             	add    $0x10,%esp
		break;
f01005be:	eb 27                	jmp    f01005e7 <cga_putc+0x124>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
f01005c0:	8b 0d 08 9f 42 f0    	mov    0xf0429f08,%ecx
f01005c6:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f01005cc:	8d 50 01             	lea    0x1(%eax),%edx
f01005cf:	66 89 15 0c 9f 42 f0 	mov    %dx,0xf0429f0c
f01005d6:	0f b7 c0             	movzwl %ax,%eax
f01005d9:	01 c0                	add    %eax,%eax
f01005db:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01005de:	8b 45 08             	mov    0x8(%ebp),%eax
f01005e1:	66 89 02             	mov    %ax,(%edx)
		break;
f01005e4:	eb 01                	jmp    f01005e7 <cga_putc+0x124>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01005e6:	90                   	nop
		crt_buf[crt_pos++] = c;		/* write the character */
		break;
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01005e7:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f01005ed:	66 3d cf 07          	cmp    $0x7cf,%ax
f01005f1:	76 58                	jbe    f010064b <cga_putc+0x188>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01005f3:	a1 08 9f 42 f0       	mov    0xf0429f08,%eax
f01005f8:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01005fe:	a1 08 9f 42 f0       	mov    0xf0429f08,%eax
f0100603:	83 ec 04             	sub    $0x4,%esp
f0100606:	68 00 0f 00 00       	push   $0xf00
f010060b:	52                   	push   %edx
f010060c:	50                   	push   %eax
f010060d:	e8 bc e6 00 00       	call   f010ecce <memcpy>
f0100612:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100615:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f010061c:	eb 15                	jmp    f0100633 <cga_putc+0x170>
			crt_buf[i] = 0x0700 | ' ';
f010061e:	8b 15 08 9f 42 f0    	mov    0xf0429f08,%edx
f0100624:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100627:	01 c0                	add    %eax,%eax
f0100629:	01 d0                	add    %edx,%eax
f010062b:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100630:	ff 45 f4             	incl   -0xc(%ebp)
f0100633:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f010063a:	7e e2                	jle    f010061e <cga_putc+0x15b>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f010063c:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f0100642:	83 e8 50             	sub    $0x50,%eax
f0100645:	66 a3 0c 9f 42 f0    	mov    %ax,0xf0429f0c
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f010064b:	a1 04 9f 42 f0       	mov    0xf0429f04,%eax
f0100650:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100653:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100657:	8a 45 e0             	mov    -0x20(%ebp),%al
f010065a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010065d:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f010065e:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f0100664:	66 c1 e8 08          	shr    $0x8,%ax
f0100668:	0f b6 c0             	movzbl %al,%eax
f010066b:	8b 15 04 9f 42 f0    	mov    0xf0429f04,%edx
f0100671:	42                   	inc    %edx
f0100672:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100675:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100678:	8a 45 e1             	mov    -0x1f(%ebp),%al
f010067b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010067e:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f010067f:	a1 04 9f 42 f0       	mov    0xf0429f04,%eax
f0100684:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100687:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f010068b:	8a 45 e2             	mov    -0x1e(%ebp),%al
f010068e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100691:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100692:	66 a1 0c 9f 42 f0    	mov    0xf0429f0c,%ax
f0100698:	0f b6 c0             	movzbl %al,%eax
f010069b:	8b 15 04 9f 42 f0    	mov    0xf0429f04,%edx
f01006a1:	42                   	inc    %edx
f01006a2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01006a5:	88 45 e3             	mov    %al,-0x1d(%ebp)
f01006a8:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01006ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01006ae:	ee                   	out    %al,(%dx)
}
f01006af:	90                   	nop
f01006b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01006b3:	c9                   	leave  
f01006b4:	c3                   	ret    

f01006b5 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f01006b5:	55                   	push   %ebp
f01006b6:	89 e5                	mov    %esp,%ebp
f01006b8:	83 ec 28             	sub    $0x28,%esp
f01006bb:	c7 45 e4 64 00 00 00 	movl   $0x64,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01006c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01006c5:	89 c2                	mov    %eax,%edx
f01006c7:	ec                   	in     (%dx),%al
f01006c8:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01006cb:	8a 45 e3             	mov    -0x1d(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f01006ce:	0f b6 c0             	movzbl %al,%eax
f01006d1:	83 e0 01             	and    $0x1,%eax
f01006d4:	85 c0                	test   %eax,%eax
f01006d6:	75 0a                	jne    f01006e2 <kbd_proc_data+0x2d>
		return -1;
f01006d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01006dd:	e9 54 01 00 00       	jmp    f0100836 <kbd_proc_data+0x181>
f01006e2:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01006e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006ec:	89 c2                	mov    %eax,%edx
f01006ee:	ec                   	in     (%dx),%al
f01006ef:	88 45 e2             	mov    %al,-0x1e(%ebp)
	return data;
f01006f2:	8a 45 e2             	mov    -0x1e(%ebp),%al

	data = inb(KBDATAP);
f01006f5:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f01006f8:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f01006fc:	75 17                	jne    f0100715 <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f01006fe:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f0100703:	83 c8 40             	or     $0x40,%eax
f0100706:	a3 28 a1 42 f0       	mov    %eax,0xf042a128
		return 0;
f010070b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100710:	e9 21 01 00 00       	jmp    f0100836 <kbd_proc_data+0x181>
	} else if (data & 0x80) {
f0100715:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100718:	84 c0                	test   %al,%al
f010071a:	79 44                	jns    f0100760 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f010071c:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f0100721:	83 e0 40             	and    $0x40,%eax
f0100724:	85 c0                	test   %eax,%eax
f0100726:	75 08                	jne    f0100730 <kbd_proc_data+0x7b>
f0100728:	8a 45 f3             	mov    -0xd(%ebp),%al
f010072b:	83 e0 7f             	and    $0x7f,%eax
f010072e:	eb 03                	jmp    f0100733 <kbd_proc_data+0x7e>
f0100730:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100733:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100736:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f010073a:	8a 80 20 a0 13 f0    	mov    -0xfec5fe0(%eax),%al
f0100740:	83 c8 40             	or     $0x40,%eax
f0100743:	0f b6 c0             	movzbl %al,%eax
f0100746:	f7 d0                	not    %eax
f0100748:	89 c2                	mov    %eax,%edx
f010074a:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f010074f:	21 d0                	and    %edx,%eax
f0100751:	a3 28 a1 42 f0       	mov    %eax,0xf042a128
		return 0;
f0100756:	b8 00 00 00 00       	mov    $0x0,%eax
f010075b:	e9 d6 00 00 00       	jmp    f0100836 <kbd_proc_data+0x181>
	} else if (shift & E0ESC) {
f0100760:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f0100765:	83 e0 40             	and    $0x40,%eax
f0100768:	85 c0                	test   %eax,%eax
f010076a:	74 11                	je     f010077d <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f010076c:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100770:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f0100775:	83 e0 bf             	and    $0xffffffbf,%eax
f0100778:	a3 28 a1 42 f0       	mov    %eax,0xf042a128
	}

	shift |= shiftcode[data];
f010077d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100781:	8a 80 20 a0 13 f0    	mov    -0xfec5fe0(%eax),%al
f0100787:	0f b6 d0             	movzbl %al,%edx
f010078a:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f010078f:	09 d0                	or     %edx,%eax
f0100791:	a3 28 a1 42 f0       	mov    %eax,0xf042a128
	shift ^= togglecode[data];
f0100796:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f010079a:	8a 80 20 a1 13 f0    	mov    -0xfec5ee0(%eax),%al
f01007a0:	0f b6 d0             	movzbl %al,%edx
f01007a3:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f01007a8:	31 d0                	xor    %edx,%eax
f01007aa:	a3 28 a1 42 f0       	mov    %eax,0xf042a128

	c = charcode[shift & (CTL | SHIFT)][data];
f01007af:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f01007b4:	83 e0 03             	and    $0x3,%eax
f01007b7:	8b 14 85 20 a5 13 f0 	mov    -0xfec5ae0(,%eax,4),%edx
f01007be:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01007c2:	01 d0                	add    %edx,%eax
f01007c4:	8a 00                	mov    (%eax),%al
f01007c6:	0f b6 c0             	movzbl %al,%eax
f01007c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (shift & CAPSLOCK) {
f01007cc:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f01007d1:	83 e0 08             	and    $0x8,%eax
f01007d4:	85 c0                	test   %eax,%eax
f01007d6:	74 22                	je     f01007fa <kbd_proc_data+0x145>
		if ('a' <= c && c <= 'z')
f01007d8:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f01007dc:	7e 0c                	jle    f01007ea <kbd_proc_data+0x135>
f01007de:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f01007e2:	7f 06                	jg     f01007ea <kbd_proc_data+0x135>
			c += 'A' - 'a';
f01007e4:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f01007e8:	eb 10                	jmp    f01007fa <kbd_proc_data+0x145>
		else if ('A' <= c && c <= 'Z')
f01007ea:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f01007ee:	7e 0a                	jle    f01007fa <kbd_proc_data+0x145>
f01007f0:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f01007f4:	7f 04                	jg     f01007fa <kbd_proc_data+0x145>
			c += 'a' - 'A';
f01007f6:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f01007fa:	a1 28 a1 42 f0       	mov    0xf042a128,%eax
f01007ff:	f7 d0                	not    %eax
f0100801:	83 e0 06             	and    $0x6,%eax
f0100804:	85 c0                	test   %eax,%eax
f0100806:	75 2b                	jne    f0100833 <kbd_proc_data+0x17e>
f0100808:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010080f:	75 22                	jne    f0100833 <kbd_proc_data+0x17e>
		cprintf("Rebooting!\n");
f0100811:	83 ec 0c             	sub    $0xc,%esp
f0100814:	68 68 f8 10 f0       	push   $0xf010f868
f0100819:	e8 3d 58 00 00       	call   f010605b <cprintf>
f010081e:	83 c4 10             	add    $0x10,%esp
f0100821:	c7 45 e8 92 00 00 00 	movl   $0x92,-0x18(%ebp)
f0100828:	c6 45 e1 03          	movb   $0x3,-0x1f(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010082c:	8a 45 e1             	mov    -0x1f(%ebp),%al
f010082f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100832:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100833:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100836:	c9                   	leave  
f0100837:	c3                   	ret    

f0100838 <kbd_intr>:

void
kbd_intr(void)
{
f0100838:	55                   	push   %ebp
f0100839:	89 e5                	mov    %esp,%ebp
f010083b:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f010083e:	83 ec 0c             	sub    $0xc,%esp
f0100841:	68 b5 06 10 f0       	push   $0xf01006b5
f0100846:	e8 0c 00 00 00       	call   f0100857 <cons_intr>
f010084b:	83 c4 10             	add    $0x10,%esp
}
f010084e:	90                   	nop
f010084f:	c9                   	leave  
f0100850:	c3                   	ret    

f0100851 <kbd_init>:

void
kbd_init(void)
{
f0100851:	55                   	push   %ebp
f0100852:	89 e5                	mov    %esp,%ebp
}
f0100854:	90                   	nop
f0100855:	5d                   	pop    %ebp
f0100856:	c3                   	ret    

f0100857 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100857:	55                   	push   %ebp
f0100858:	89 e5                	mov    %esp,%ebp
f010085a:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f010085d:	eb 35                	jmp    f0100894 <cons_intr+0x3d>
		if (c == 0)
f010085f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100863:	75 02                	jne    f0100867 <cons_intr+0x10>
			continue;
f0100865:	eb 2d                	jmp    f0100894 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100867:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f010086c:	8d 50 01             	lea    0x1(%eax),%edx
f010086f:	89 15 24 a1 42 f0    	mov    %edx,0xf042a124
f0100875:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100878:	88 90 20 9f 42 f0    	mov    %dl,-0xfbd60e0(%eax)
		if (cons.wpos == CONSBUFSIZE)
f010087e:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f0100883:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100888:	75 0a                	jne    f0100894 <cons_intr+0x3d>
			cons.wpos = 0;
f010088a:	c7 05 24 a1 42 f0 00 	movl   $0x0,0xf042a124
f0100891:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100894:	8b 45 08             	mov    0x8(%ebp),%eax
f0100897:	ff d0                	call   *%eax
f0100899:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010089c:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f01008a0:	75 bd                	jne    f010085f <cons_intr+0x8>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
f01008a2:	90                   	nop
f01008a3:	c9                   	leave  
f01008a4:	c3                   	ret    

f01008a5 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f01008a5:	55                   	push   %ebp
f01008a6:	89 e5                	mov    %esp,%ebp
f01008a8:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f01008ab:	e8 a7 f9 ff ff       	call   f0100257 <serial_intr>
	kbd_intr();
f01008b0:	e8 83 ff ff ff       	call   f0100838 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f01008b5:	8b 15 20 a1 42 f0    	mov    0xf042a120,%edx
f01008bb:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f01008c0:	39 c2                	cmp    %eax,%edx
f01008c2:	74 35                	je     f01008f9 <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f01008c4:	a1 20 a1 42 f0       	mov    0xf042a120,%eax
f01008c9:	8d 50 01             	lea    0x1(%eax),%edx
f01008cc:	89 15 20 a1 42 f0    	mov    %edx,0xf042a120
f01008d2:	8a 80 20 9f 42 f0    	mov    -0xfbd60e0(%eax),%al
f01008d8:	0f b6 c0             	movzbl %al,%eax
f01008db:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f01008de:	a1 20 a1 42 f0       	mov    0xf042a120,%eax
f01008e3:	3d 00 02 00 00       	cmp    $0x200,%eax
f01008e8:	75 0a                	jne    f01008f4 <cons_getc+0x4f>
			cons.rpos = 0;
f01008ea:	c7 05 20 a1 42 f0 00 	movl   $0x0,0xf042a120
f01008f1:	00 00 00 
		return c;
f01008f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01008f7:	eb 05                	jmp    f01008fe <cons_getc+0x59>
	}
	return 0;
f01008f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01008fe:	c9                   	leave  
f01008ff:	c3                   	ret    

f0100900 <cons_getc2>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc2(void)
{
f0100900:	55                   	push   %ebp
f0100901:	89 e5                	mov    %esp,%ebp
f0100903:	83 ec 18             	sub    $0x18,%esp

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).

	int c1 = 0;
f0100906:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//serial_intr();
	{
		if (serial_exists)
f010090d:	a1 00 9f 42 f0       	mov    0xf0429f00,%eax
f0100912:	85 c0                	test   %eax,%eax
f0100914:	74 41                	je     f0100957 <cons_getc2+0x57>
		{
			if ((c1 = serial_proc_data()) != -1) {
f0100916:	e8 fa f8 ff ff       	call   f0100215 <serial_proc_data>
f010091b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010091e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100922:	74 33                	je     f0100957 <cons_getc2+0x57>
				if (c1 == 0)
f0100924:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100928:	74 2d                	je     f0100957 <cons_getc2+0x57>
				{
					//continue;
				}
				else
				{
					cons.buf[cons.wpos++] = c1;
f010092a:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f010092f:	8d 50 01             	lea    0x1(%eax),%edx
f0100932:	89 15 24 a1 42 f0    	mov    %edx,0xf042a124
f0100938:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010093b:	88 90 20 9f 42 f0    	mov    %dl,-0xfbd60e0(%eax)
					if (cons.wpos == CONSBUFSIZE)
f0100941:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f0100946:	3d 00 02 00 00       	cmp    $0x200,%eax
f010094b:	75 0a                	jne    f0100957 <cons_getc2+0x57>
						cons.wpos = 0;
f010094d:	c7 05 24 a1 42 f0 00 	movl   $0x0,0xf042a124
f0100954:	00 00 00 
				}
			}
		}
	}

	int c2 = 0;
f0100957:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	//kbd_intr();
	{
		if ((c2 = kbd_proc_data()) != -1) {
f010095e:	e8 52 fd ff ff       	call   f01006b5 <kbd_proc_data>
f0100963:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100966:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f010096a:	74 33                	je     f010099f <cons_getc2+0x9f>
			if (c2 == 0)
f010096c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0100970:	74 2d                	je     f010099f <cons_getc2+0x9f>
			{
				//continue;
			}
			else
			{
				cons.buf[cons.wpos++] = c2;
f0100972:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f0100977:	8d 50 01             	lea    0x1(%eax),%edx
f010097a:	89 15 24 a1 42 f0    	mov    %edx,0xf042a124
f0100980:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100983:	88 90 20 9f 42 f0    	mov    %dl,-0xfbd60e0(%eax)
				if (cons.wpos == CONSBUFSIZE)
f0100989:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f010098e:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100993:	75 0a                	jne    f010099f <cons_getc2+0x9f>
					cons.wpos = 0;
f0100995:	c7 05 24 a1 42 f0 00 	movl   $0x0,0xf042a124
f010099c:	00 00 00 
	}

	// grab the next character from the input buffer.
	//cprintf("%d, %d \n", c1, c2);
	//if(c1 > 0 && c2 > 0)
	if(c2 > 0)
f010099f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01009a3:	7e 44                	jle    f01009e9 <cons_getc2+0xe9>
	{
		if (cons.rpos != cons.wpos) {
f01009a5:	8b 15 20 a1 42 f0    	mov    0xf042a120,%edx
f01009ab:	a1 24 a1 42 f0       	mov    0xf042a124,%eax
f01009b0:	39 c2                	cmp    %eax,%edx
f01009b2:	74 35                	je     f01009e9 <cons_getc2+0xe9>
			c = cons.buf[cons.rpos++];
f01009b4:	a1 20 a1 42 f0       	mov    0xf042a120,%eax
f01009b9:	8d 50 01             	lea    0x1(%eax),%edx
f01009bc:	89 15 20 a1 42 f0    	mov    %edx,0xf042a120
f01009c2:	8a 80 20 9f 42 f0    	mov    -0xfbd60e0(%eax),%al
f01009c8:	0f b6 c0             	movzbl %al,%eax
f01009cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (cons.rpos == CONSBUFSIZE)
f01009ce:	a1 20 a1 42 f0       	mov    0xf042a120,%eax
f01009d3:	3d 00 02 00 00       	cmp    $0x200,%eax
f01009d8:	75 0a                	jne    f01009e4 <cons_getc2+0xe4>
				cons.rpos = 0;
f01009da:	c7 05 20 a1 42 f0 00 	movl   $0x0,0xf042a120
f01009e1:	00 00 00 
			return c;
f01009e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01009e7:	eb 05                	jmp    f01009ee <cons_getc2+0xee>
		}
	}
	return 0;
f01009e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01009ee:	c9                   	leave  
f01009ef:	c3                   	ret    

f01009f0 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f01009f0:	55                   	push   %ebp
f01009f1:	89 e5                	mov    %esp,%ebp
f01009f3:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f01009f6:	ff 75 08             	pushl  0x8(%ebp)
f01009f9:	e8 8b f9 ff ff       	call   f0100389 <lpt_putc>
f01009fe:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100a01:	83 ec 0c             	sub    $0xc,%esp
f0100a04:	ff 75 08             	pushl  0x8(%ebp)
f0100a07:	e8 b7 fa ff ff       	call   f01004c3 <cga_putc>
f0100a0c:	83 c4 10             	add    $0x10,%esp
}
f0100a0f:	90                   	nop
f0100a10:	c9                   	leave  
f0100a11:	c3                   	ret    

f0100a12 <console_initialize>:

// initialize the console devices
void
console_initialize(void)
{
f0100a12:	55                   	push   %ebp
f0100a13:	89 e5                	mov    %esp,%ebp
f0100a15:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100a18:	e8 e1 f9 ff ff       	call   f01003fe <cga_init>
	kbd_init();
f0100a1d:	e8 2f fe ff ff       	call   f0100851 <kbd_init>
	serial_init();
f0100a22:	e8 52 f8 ff ff       	call   f0100279 <serial_init>

	if (!serial_exists)
f0100a27:	a1 00 9f 42 f0       	mov    0xf0429f00,%eax
f0100a2c:	85 c0                	test   %eax,%eax
f0100a2e:	75 10                	jne    f0100a40 <console_initialize+0x2e>
		cprintf("Serial port does not exist!\n");
f0100a30:	83 ec 0c             	sub    $0xc,%esp
f0100a33:	68 74 f8 10 f0       	push   $0xf010f874
f0100a38:	e8 1e 56 00 00       	call   f010605b <cprintf>
f0100a3d:	83 c4 10             	add    $0x10,%esp
}
f0100a40:	90                   	nop
f0100a41:	c9                   	leave  
f0100a42:	c3                   	ret    

f0100a43 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
f0100a43:	55                   	push   %ebp
f0100a44:	89 e5                	mov    %esp,%ebp
f0100a46:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100a49:	83 ec 0c             	sub    $0xc,%esp
f0100a4c:	ff 75 08             	pushl  0x8(%ebp)
f0100a4f:	e8 9c ff ff ff       	call   f01009f0 <cons_putc>
f0100a54:	83 c4 10             	add    $0x10,%esp
}
f0100a57:	90                   	nop
f0100a58:	c9                   	leave  
f0100a59:	c3                   	ret    

f0100a5a <getchar>:

int
getchar(void)
{
f0100a5a:	55                   	push   %ebp
f0100a5b:	89 e5                	mov    %esp,%ebp
f0100a5d:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100a60:	e8 40 fe ff ff       	call   f01008a5 <cons_getc>
f0100a65:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100a68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100a6c:	74 f2                	je     f0100a60 <getchar+0x6>
		/* do nothing */;
	return c;
f0100a6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100a71:	c9                   	leave  
f0100a72:	c3                   	ret    

f0100a73 <iscons>:

int
iscons(int fdnum)
{
f0100a73:	55                   	push   %ebp
f0100a74:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100a76:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100a7b:	5d                   	pop    %ebp
f0100a7c:	c3                   	ret    

f0100a7d <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct Frame_Info* to_frame_info(uint32 physical_address)
{
f0100a7d:	55                   	push   %ebp
f0100a7e:	89 e5                	mov    %esp,%ebp
f0100a80:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0100a83:	8b 45 08             	mov    0x8(%ebp),%eax
f0100a86:	c1 e8 0c             	shr    $0xc,%eax
f0100a89:	89 c2                	mov    %eax,%edx
f0100a8b:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f0100a90:	39 c2                	cmp    %eax,%edx
f0100a92:	72 14                	jb     f0100aa8 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0100a94:	83 ec 04             	sub    $0x4,%esp
f0100a97:	68 94 f8 10 f0       	push   $0xf010f894
f0100a9c:	6a 60                	push   $0x60
f0100a9e:	68 b9 f8 10 f0       	push   $0xf010f8b9
f0100aa3:	e8 b4 f6 ff ff       	call   f010015c <_panic>
	return &frames_info[PPN(physical_address)];
f0100aa8:	8b 15 84 52 45 f0    	mov    0xf0455284,%edx
f0100aae:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ab1:	c1 e8 0c             	shr    $0xc,%eax
f0100ab4:	89 c1                	mov    %eax,%ecx
f0100ab6:	89 c8                	mov    %ecx,%eax
f0100ab8:	01 c0                	add    %eax,%eax
f0100aba:	01 c8                	add    %ecx,%eax
f0100abc:	c1 e0 03             	shl    $0x3,%eax
f0100abf:	01 d0                	add    %edx,%eax
}
f0100ac1:	c9                   	leave  
f0100ac2:	c3                   	ret    

f0100ac3 <command_prompt_readline>:
int history_size = 0;
int history_write = 0;
char history_list[10][1024];

void command_prompt_readline(const char *prompt, char* buf)
{
f0100ac3:	55                   	push   %ebp
f0100ac4:	89 e5                	mov    %esp,%ebp
f0100ac6:	81 ec c8 00 00 00    	sub    $0xc8,%esp
	int i, c, echoing, current_command, current_match, found_matches, used_match, current_erase, size, history_index, history_used;
	int matches[NUM_OF_COMMANDS];

	if (prompt != NULL)
f0100acc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0100ad0:	74 13                	je     f0100ae5 <command_prompt_readline+0x22>
		cprintf("%s", prompt);
f0100ad2:	83 ec 08             	sub    $0x8,%esp
f0100ad5:	ff 75 08             	pushl  0x8(%ebp)
f0100ad8:	68 a8 fe 10 f0       	push   $0xf010fea8
f0100add:	e8 79 55 00 00       	call   f010605b <cprintf>
f0100ae2:	83 c4 10             	add    $0x10,%esp

	found_matches = 0;
f0100ae5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	current_match = 0;
f0100aec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	current_erase = 0;
f0100af3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	history_index = 0;
f0100afa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	history_used = 0;
f0100b01:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	used_match = 0;
f0100b08:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	size = 0;
f0100b0f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	i = 0;
f0100b16:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	echoing = iscons(0);
f0100b1d:	83 ec 0c             	sub    $0xc,%esp
f0100b20:	6a 00                	push   $0x0
f0100b22:	e8 4c ff ff ff       	call   f0100a73 <iscons>
f0100b27:	83 c4 10             	add    $0x10,%esp
f0100b2a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	while (1)
	{
		c = getchar();
f0100b2d:	e8 28 ff ff ff       	call   f0100a5a <getchar>
f0100b32:	89 45 cc             	mov    %eax,-0x34(%ebp)

		if (c < 0)
f0100b35:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0100b39:	79 30                	jns    f0100b6b <command_prompt_readline+0xa8>
		{
			found_matches = 0;
f0100b3b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
			history_used = 0;
f0100b42:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

			if (c != -E_EOF)
f0100b49:	83 7d cc 07          	cmpl   $0x7,-0x34(%ebp)
f0100b4d:	0f 84 7a 03 00 00    	je     f0100ecd <command_prompt_readline+0x40a>
				cprintf("read error: %e\n", c);
f0100b53:	83 ec 08             	sub    $0x8,%esp
f0100b56:	ff 75 cc             	pushl  -0x34(%ebp)
f0100b59:	68 ab fe 10 f0       	push   $0xf010feab
f0100b5e:	e8 f8 54 00 00       	call   f010605b <cprintf>
f0100b63:	83 c4 10             	add    $0x10,%esp
			return;
f0100b66:	e9 62 03 00 00       	jmp    f0100ecd <command_prompt_readline+0x40a>
		}
		else if(c == 226 || c == 227)
f0100b6b:	81 7d cc e2 00 00 00 	cmpl   $0xe2,-0x34(%ebp)
f0100b72:	74 0d                	je     f0100b81 <command_prompt_readline+0xbe>
f0100b74:	81 7d cc e3 00 00 00 	cmpl   $0xe3,-0x34(%ebp)
f0100b7b:	0f 85 53 01 00 00    	jne    f0100cd4 <command_prompt_readline+0x211>
		{
			found_matches = 0;
f0100b81:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if(history_size == 0)
f0100b88:	a1 2c a1 42 f0       	mov    0xf042a12c,%eax
f0100b8d:	85 c0                	test   %eax,%eax
f0100b8f:	0f 84 2c 03 00 00    	je     f0100ec1 <command_prompt_readline+0x3fe>
				continue;

			if(history_used == 0)
f0100b95:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0100b99:	75 0f                	jne    f0100baa <command_prompt_readline+0xe7>
			{
				history_index = history_write;
f0100b9b:	a1 30 a1 42 f0       	mov    0xf042a130,%eax
f0100ba0:	89 45 dc             	mov    %eax,-0x24(%ebp)
				history_used = 1;
f0100ba3:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
			}

			if(history_used == 1 && c == 226)//Up
f0100baa:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0100bae:	0f 85 88 00 00 00    	jne    f0100c3c <command_prompt_readline+0x179>
f0100bb4:	81 7d cc e2 00 00 00 	cmpl   $0xe2,-0x34(%ebp)
f0100bbb:	75 7f                	jne    f0100c3c <command_prompt_readline+0x179>
			{
				history_index--;
f0100bbd:	ff 4d dc             	decl   -0x24(%ebp)
				if(history_index == history_min)
f0100bc0:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
f0100bc4:	75 09                	jne    f0100bcf <command_prompt_readline+0x10c>
					history_index = history_size - 1;
f0100bc6:	a1 2c a1 42 f0       	mov    0xf042a12c,%eax
f0100bcb:	48                   	dec    %eax
f0100bcc:	89 45 dc             	mov    %eax,-0x24(%ebp)

				strcpy(buf,history_list[history_index]);
f0100bcf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100bd2:	c1 e0 0a             	shl    $0xa,%eax
f0100bd5:	05 60 2a 45 f0       	add    $0xf0452a60,%eax
f0100bda:	83 ec 08             	sub    $0x8,%esp
f0100bdd:	50                   	push   %eax
f0100bde:	ff 75 0c             	pushl  0xc(%ebp)
f0100be1:	e8 19 df 00 00       	call   f010eaff <strcpy>
f0100be6:	83 c4 10             	add    $0x10,%esp

				for(current_erase = 0;current_erase < i;current_erase++)
f0100be9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0100bf0:	eb 10                	jmp    f0100c02 <command_prompt_readline+0x13f>
				{
					cputchar('\b');
f0100bf2:	83 ec 0c             	sub    $0xc,%esp
f0100bf5:	6a 08                	push   $0x8
f0100bf7:	e8 47 fe ff ff       	call   f0100a43 <cputchar>
f0100bfc:	83 c4 10             	add    $0x10,%esp
				if(history_index == history_min)
					history_index = history_size - 1;

				strcpy(buf,history_list[history_index]);

				for(current_erase = 0;current_erase < i;current_erase++)
f0100bff:	ff 45 e0             	incl   -0x20(%ebp)
f0100c02:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0100c05:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100c08:	7c e8                	jl     f0100bf2 <command_prompt_readline+0x12f>
				{
					cputchar('\b');
				}

				i = strlen(history_list[history_index]);
f0100c0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100c0d:	c1 e0 0a             	shl    $0xa,%eax
f0100c10:	05 60 2a 45 f0       	add    $0xf0452a60,%eax
f0100c15:	83 ec 0c             	sub    $0xc,%esp
f0100c18:	50                   	push   %eax
f0100c19:	e8 92 de 00 00       	call   f010eab0 <strlen>
f0100c1e:	83 c4 10             	add    $0x10,%esp
f0100c21:	89 45 f4             	mov    %eax,-0xc(%ebp)
				cprintf("%s",buf);
f0100c24:	83 ec 08             	sub    $0x8,%esp
f0100c27:	ff 75 0c             	pushl  0xc(%ebp)
f0100c2a:	68 a8 fe 10 f0       	push   $0xf010fea8
f0100c2f:	e8 27 54 00 00       	call   f010605b <cprintf>
f0100c34:	83 c4 10             	add    $0x10,%esp
			{
				history_index = history_write;
				history_used = 1;
			}

			if(history_used == 1 && c == 226)//Up
f0100c37:	e9 8b 02 00 00       	jmp    f0100ec7 <command_prompt_readline+0x404>
				}

				i = strlen(history_list[history_index]);
				cprintf("%s",buf);
			}
			else if(history_used == 1 && c == 227)//Down
f0100c3c:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0100c40:	0f 85 81 02 00 00    	jne    f0100ec7 <command_prompt_readline+0x404>
f0100c46:	81 7d cc e3 00 00 00 	cmpl   $0xe3,-0x34(%ebp)
f0100c4d:	0f 85 74 02 00 00    	jne    f0100ec7 <command_prompt_readline+0x404>
			{
				history_index++;
f0100c53:	ff 45 dc             	incl   -0x24(%ebp)
				if(history_index >= history_size)
f0100c56:	a1 2c a1 42 f0       	mov    0xf042a12c,%eax
f0100c5b:	39 45 dc             	cmp    %eax,-0x24(%ebp)
f0100c5e:	7c 07                	jl     f0100c67 <command_prompt_readline+0x1a4>
					history_index = 0;
f0100c60:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

				strcpy(buf,history_list[history_index]);
f0100c67:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100c6a:	c1 e0 0a             	shl    $0xa,%eax
f0100c6d:	05 60 2a 45 f0       	add    $0xf0452a60,%eax
f0100c72:	83 ec 08             	sub    $0x8,%esp
f0100c75:	50                   	push   %eax
f0100c76:	ff 75 0c             	pushl  0xc(%ebp)
f0100c79:	e8 81 de 00 00       	call   f010eaff <strcpy>
f0100c7e:	83 c4 10             	add    $0x10,%esp

				for(current_erase = 0;current_erase < i;current_erase++)
f0100c81:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0100c88:	eb 10                	jmp    f0100c9a <command_prompt_readline+0x1d7>
				{
					cputchar('\b');
f0100c8a:	83 ec 0c             	sub    $0xc,%esp
f0100c8d:	6a 08                	push   $0x8
f0100c8f:	e8 af fd ff ff       	call   f0100a43 <cputchar>
f0100c94:	83 c4 10             	add    $0x10,%esp
				if(history_index >= history_size)
					history_index = 0;

				strcpy(buf,history_list[history_index]);

				for(current_erase = 0;current_erase < i;current_erase++)
f0100c97:	ff 45 e0             	incl   -0x20(%ebp)
f0100c9a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0100c9d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100ca0:	7c e8                	jl     f0100c8a <command_prompt_readline+0x1c7>
				{
					cputchar('\b');
				}

				i = strlen(history_list[history_index]);
f0100ca2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100ca5:	c1 e0 0a             	shl    $0xa,%eax
f0100ca8:	05 60 2a 45 f0       	add    $0xf0452a60,%eax
f0100cad:	83 ec 0c             	sub    $0xc,%esp
f0100cb0:	50                   	push   %eax
f0100cb1:	e8 fa dd 00 00       	call   f010eab0 <strlen>
f0100cb6:	83 c4 10             	add    $0x10,%esp
f0100cb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
				cprintf("%s",buf);
f0100cbc:	83 ec 08             	sub    $0x8,%esp
f0100cbf:	ff 75 0c             	pushl  0xc(%ebp)
f0100cc2:	68 a8 fe 10 f0       	push   $0xf010fea8
f0100cc7:	e8 8f 53 00 00       	call   f010605b <cprintf>
f0100ccc:	83 c4 10             	add    $0x10,%esp
			{
				history_index = history_write;
				history_used = 1;
			}

			if(history_used == 1 && c == 226)//Up
f0100ccf:	e9 f3 01 00 00       	jmp    f0100ec7 <command_prompt_readline+0x404>

				i = strlen(history_list[history_index]);
				cprintf("%s",buf);
			}
		}
		else if (c >= ' ' && i < BUFLEN-1)
f0100cd4:	83 7d cc 1f          	cmpl   $0x1f,-0x34(%ebp)
f0100cd8:	7e 45                	jle    f0100d1f <command_prompt_readline+0x25c>
f0100cda:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0100ce1:	7f 3c                	jg     f0100d1f <command_prompt_readline+0x25c>
		{
			found_matches = 0;
f0100ce3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
			history_used = 0;
f0100cea:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

			if (echoing)
f0100cf1:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0100cf5:	74 0e                	je     f0100d05 <command_prompt_readline+0x242>
				cputchar(c);
f0100cf7:	83 ec 0c             	sub    $0xc,%esp
f0100cfa:	ff 75 cc             	pushl  -0x34(%ebp)
f0100cfd:	e8 41 fd ff ff       	call   f0100a43 <cputchar>
f0100d02:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0100d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100d08:	8d 50 01             	lea    0x1(%eax),%edx
f0100d0b:	89 55 f4             	mov    %edx,-0xc(%ebp)
f0100d0e:	89 c2                	mov    %eax,%edx
f0100d10:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100d13:	01 d0                	add    %edx,%eax
f0100d15:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0100d18:	88 10                	mov    %dl,(%eax)
f0100d1a:	e9 a9 01 00 00       	jmp    f0100ec8 <command_prompt_readline+0x405>
		}
		else if (c == '\b' && i > 0)
f0100d1f:	83 7d cc 08          	cmpl   $0x8,-0x34(%ebp)
f0100d23:	75 30                	jne    f0100d55 <command_prompt_readline+0x292>
f0100d25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d29:	7e 2a                	jle    f0100d55 <command_prompt_readline+0x292>
		{
			found_matches = 0;
f0100d2b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
			history_used = 0;
f0100d32:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

			if (echoing)
f0100d39:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0100d3d:	74 0e                	je     f0100d4d <command_prompt_readline+0x28a>
				cputchar(c);
f0100d3f:	83 ec 0c             	sub    $0xc,%esp
f0100d42:	ff 75 cc             	pushl  -0x34(%ebp)
f0100d45:	e8 f9 fc ff ff       	call   f0100a43 <cputchar>
f0100d4a:	83 c4 10             	add    $0x10,%esp

			i--;
f0100d4d:	ff 4d f4             	decl   -0xc(%ebp)
f0100d50:	e9 73 01 00 00       	jmp    f0100ec8 <command_prompt_readline+0x405>
		}
		else if (c == '\n' || c == '\r')
f0100d55:	83 7d cc 0a          	cmpl   $0xa,-0x34(%ebp)
f0100d59:	74 06                	je     f0100d61 <command_prompt_readline+0x29e>
f0100d5b:	83 7d cc 0d          	cmpl   $0xd,-0x34(%ebp)
f0100d5f:	75 32                	jne    f0100d93 <command_prompt_readline+0x2d0>
		{
			found_matches = 0;
f0100d61:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
			history_used = 0;
f0100d68:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

			if (echoing)
f0100d6f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0100d73:	74 0e                	je     f0100d83 <command_prompt_readline+0x2c0>
				cputchar(c);
f0100d75:	83 ec 0c             	sub    $0xc,%esp
f0100d78:	ff 75 cc             	pushl  -0x34(%ebp)
f0100d7b:	e8 c3 fc ff ff       	call   f0100a43 <cputchar>
f0100d80:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f0100d83:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100d89:	01 d0                	add    %edx,%eax
f0100d8b:	c6 00 00             	movb   $0x0,(%eax)
			return;
f0100d8e:	e9 3b 01 00 00       	jmp    f0100ece <command_prompt_readline+0x40b>
		}
		else if(c == '\t')
f0100d93:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
f0100d97:	0f 85 90 fd ff ff    	jne    f0100b2d <command_prompt_readline+0x6a>
		{
			history_used = 0;
f0100d9d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

			if(found_matches == 0)
f0100da4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0100da8:	75 6c                	jne    f0100e16 <command_prompt_readline+0x353>
			{
				current_match = 0;
f0100daa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				used_match = 0;
f0100db1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

				for(current_command = 0;current_command < NUM_OF_COMMANDS;current_command++)
f0100db8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0100dbf:	eb 40                	jmp    f0100e01 <command_prompt_readline+0x33e>
				{
					if(strncmp(buf,commands[current_command].name,i) == 0)
f0100dc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100dc4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0100dc7:	89 c8                	mov    %ecx,%eax
f0100dc9:	01 c0                	add    %eax,%eax
f0100dcb:	01 c8                	add    %ecx,%eax
f0100dcd:	c1 e0 02             	shl    $0x2,%eax
f0100dd0:	05 40 a5 13 f0       	add    $0xf013a540,%eax
f0100dd5:	8b 00                	mov    (%eax),%eax
f0100dd7:	83 ec 04             	sub    $0x4,%esp
f0100dda:	52                   	push   %edx
f0100ddb:	50                   	push   %eax
f0100ddc:	ff 75 0c             	pushl  0xc(%ebp)
f0100ddf:	e8 10 de 00 00       	call   f010ebf4 <strncmp>
f0100de4:	83 c4 10             	add    $0x10,%esp
f0100de7:	85 c0                	test   %eax,%eax
f0100de9:	75 13                	jne    f0100dfe <command_prompt_readline+0x33b>
					{
						matches[current_match++] = current_command;
f0100deb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0100dee:	8d 50 01             	lea    0x1(%eax),%edx
f0100df1:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100df4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100df7:	89 94 85 38 ff ff ff 	mov    %edx,-0xc8(%ebp,%eax,4)
			if(found_matches == 0)
			{
				current_match = 0;
				used_match = 0;

				for(current_command = 0;current_command < NUM_OF_COMMANDS;current_command++)
f0100dfe:	ff 45 f0             	incl   -0x10(%ebp)
f0100e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100e04:	83 f8 24             	cmp    $0x24,%eax
f0100e07:	76 b8                	jbe    f0100dc1 <command_prompt_readline+0x2fe>
					{
						matches[current_match++] = current_command;
					}
				}

				if(current_match != 0)
f0100e09:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0100e0d:	74 07                	je     f0100e16 <command_prompt_readline+0x353>
					found_matches = 1;
f0100e0f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
			}

			if(found_matches == 1)
f0100e16:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0100e1a:	0f 85 0d fd ff ff    	jne    f0100b2d <command_prompt_readline+0x6a>
			{
				strcpy(buf,commands[matches[used_match]].name);
f0100e20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100e23:	8b 94 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%edx
f0100e2a:	89 d0                	mov    %edx,%eax
f0100e2c:	01 c0                	add    %eax,%eax
f0100e2e:	01 d0                	add    %edx,%eax
f0100e30:	c1 e0 02             	shl    $0x2,%eax
f0100e33:	05 40 a5 13 f0       	add    $0xf013a540,%eax
f0100e38:	8b 00                	mov    (%eax),%eax
f0100e3a:	83 ec 08             	sub    $0x8,%esp
f0100e3d:	50                   	push   %eax
f0100e3e:	ff 75 0c             	pushl  0xc(%ebp)
f0100e41:	e8 b9 dc 00 00       	call   f010eaff <strcpy>
f0100e46:	83 c4 10             	add    $0x10,%esp

				for(current_erase = 0;current_erase < i;current_erase++)
f0100e49:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0100e50:	eb 10                	jmp    f0100e62 <command_prompt_readline+0x39f>
				{
					cputchar('\b');
f0100e52:	83 ec 0c             	sub    $0xc,%esp
f0100e55:	6a 08                	push   $0x8
f0100e57:	e8 e7 fb ff ff       	call   f0100a43 <cputchar>
f0100e5c:	83 c4 10             	add    $0x10,%esp

			if(found_matches == 1)
			{
				strcpy(buf,commands[matches[used_match]].name);

				for(current_erase = 0;current_erase < i;current_erase++)
f0100e5f:	ff 45 e0             	incl   -0x20(%ebp)
f0100e62:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0100e65:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100e68:	7c e8                	jl     f0100e52 <command_prompt_readline+0x38f>
				{
					cputchar('\b');
				}

				i = strlen(commands[matches[used_match]].name);
f0100e6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100e6d:	8b 94 85 38 ff ff ff 	mov    -0xc8(%ebp,%eax,4),%edx
f0100e74:	89 d0                	mov    %edx,%eax
f0100e76:	01 c0                	add    %eax,%eax
f0100e78:	01 d0                	add    %edx,%eax
f0100e7a:	c1 e0 02             	shl    $0x2,%eax
f0100e7d:	05 40 a5 13 f0       	add    $0xf013a540,%eax
f0100e82:	8b 00                	mov    (%eax),%eax
f0100e84:	83 ec 0c             	sub    $0xc,%esp
f0100e87:	50                   	push   %eax
f0100e88:	e8 23 dc 00 00       	call   f010eab0 <strlen>
f0100e8d:	83 c4 10             	add    $0x10,%esp
f0100e90:	89 45 f4             	mov    %eax,-0xc(%ebp)
				cprintf("%s",buf);
f0100e93:	83 ec 08             	sub    $0x8,%esp
f0100e96:	ff 75 0c             	pushl  0xc(%ebp)
f0100e99:	68 a8 fe 10 f0       	push   $0xf010fea8
f0100e9e:	e8 b8 51 00 00       	call   f010605b <cprintf>
f0100ea3:	83 c4 10             	add    $0x10,%esp

				used_match++;
f0100ea6:	ff 45 e4             	incl   -0x1c(%ebp)
				if(used_match == current_match)
f0100ea9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100eac:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0100eaf:	0f 85 78 fc ff ff    	jne    f0100b2d <command_prompt_readline+0x6a>
					used_match = 0;
f0100eb5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0100ebc:	e9 6c fc ff ff       	jmp    f0100b2d <command_prompt_readline+0x6a>
		else if(c == 226 || c == 227)
		{
			found_matches = 0;

			if(history_size == 0)
				continue;
f0100ec1:	90                   	nop
f0100ec2:	e9 66 fc ff ff       	jmp    f0100b2d <command_prompt_readline+0x6a>
			{
				history_index = history_write;
				history_used = 1;
			}

			if(history_used == 1 && c == 226)//Up
f0100ec7:	90                   	nop
				used_match++;
				if(used_match == current_match)
					used_match = 0;
			}
		}
	}
f0100ec8:	e9 60 fc ff ff       	jmp    f0100b2d <command_prompt_readline+0x6a>
			found_matches = 0;
			history_used = 0;

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0100ecd:	90                   	nop
				if(used_match == current_match)
					used_match = 0;
			}
		}
	}
}
f0100ece:	c9                   	leave  
f0100ecf:	c3                   	ret    

f0100ed0 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

//invoke the command prompt
void run_command_prompt()
{
f0100ed0:	55                   	push   %ebp
f0100ed1:	89 e5                	mov    %esp,%ebp
f0100ed3:	81 ec 08 04 00 00    	sub    $0x408,%esp
	{
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is implemented by **********
		// ********** Abdullah Najuib (now FCIS T.A.), 3rd year student, FCIS, 2012
		command_prompt_readline("FOS> ", command_line);
f0100ed9:	83 ec 08             	sub    $0x8,%esp
f0100edc:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
f0100ee2:	50                   	push   %eax
f0100ee3:	68 bb fe 10 f0       	push   $0xf010febb
f0100ee8:	e8 d6 fb ff ff       	call   f0100ac3 <command_prompt_readline>
f0100eed:	83 c4 10             	add    $0x10,%esp

		//save history
		strcpy(history_list[history_write],command_line);
f0100ef0:	a1 30 a1 42 f0       	mov    0xf042a130,%eax
f0100ef5:	c1 e0 0a             	shl    $0xa,%eax
f0100ef8:	8d 90 60 2a 45 f0    	lea    -0xfbad5a0(%eax),%edx
f0100efe:	83 ec 08             	sub    $0x8,%esp
f0100f01:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
f0100f07:	50                   	push   %eax
f0100f08:	52                   	push   %edx
f0100f09:	e8 f1 db 00 00       	call   f010eaff <strcpy>
f0100f0e:	83 c4 10             	add    $0x10,%esp

		if(++history_write == history_max)
f0100f11:	a1 30 a1 42 f0       	mov    0xf042a130,%eax
f0100f16:	40                   	inc    %eax
f0100f17:	a3 30 a1 42 f0       	mov    %eax,0xf042a130
f0100f1c:	a1 30 a1 42 f0       	mov    0xf042a130,%eax
f0100f21:	83 f8 0a             	cmp    $0xa,%eax
f0100f24:	75 0a                	jne    f0100f30 <run_command_prompt+0x60>
			history_write = 0;
f0100f26:	c7 05 30 a1 42 f0 00 	movl   $0x0,0xf042a130
f0100f2d:	00 00 00 

		if(history_size != 10)
f0100f30:	a1 2c a1 42 f0       	mov    0xf042a12c,%eax
f0100f35:	83 f8 0a             	cmp    $0xa,%eax
f0100f38:	74 0b                	je     f0100f45 <run_command_prompt+0x75>
			history_size++;
f0100f3a:	a1 2c a1 42 f0       	mov    0xf042a12c,%eax
f0100f3f:	40                   	inc    %eax
f0100f40:	a3 2c a1 42 f0       	mov    %eax,0xf042a12c

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0100f45:	83 ec 0c             	sub    $0xc,%esp
f0100f48:	8d 85 f8 fb ff ff    	lea    -0x408(%ebp),%eax
f0100f4e:	50                   	push   %eax
f0100f4f:	e8 10 00 00 00       	call   f0100f64 <execute_command>
f0100f54:	83 c4 10             	add    $0x10,%esp
f0100f57:	85 c0                	test   %eax,%eax
f0100f59:	78 05                	js     f0100f60 <run_command_prompt+0x90>
				break;
	}
f0100f5b:	e9 79 ff ff ff       	jmp    f0100ed9 <run_command_prompt+0x9>
			history_size++;

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0100f60:	90                   	nop
	}
}
f0100f61:	90                   	nop
f0100f62:	c9                   	leave  
f0100f63:	c3                   	ret    

f0100f64 <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0100f64:	55                   	push   %ebp
f0100f65:	89 e5                	mov    %esp,%ebp
f0100f67:	83 ec 58             	sub    $0x58,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0100f6a:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0100f6d:	50                   	push   %eax
f0100f6e:	8d 45 a8             	lea    -0x58(%ebp),%eax
f0100f71:	50                   	push   %eax
f0100f72:	68 c1 fe 10 f0       	push   $0xf010fec1
f0100f77:	ff 75 08             	pushl  0x8(%ebp)
f0100f7a:	e8 65 e1 00 00       	call   f010f0e4 <strsplit>
f0100f7f:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0100f82:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100f85:	85 c0                	test   %eax,%eax
f0100f87:	75 0a                	jne    f0100f93 <execute_command+0x2f>
		return 0;
f0100f89:	b8 00 00 00 00       	mov    $0x0,%eax
f0100f8e:	e9 95 00 00 00       	jmp    f0101028 <execute_command+0xc4>

	// Lookup in the commands array and execute the command
	int command_found = 0;
f0100f93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0100f9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0100fa1:	eb 33                	jmp    f0100fd6 <execute_command+0x72>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f0100fa3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100fa6:	89 d0                	mov    %edx,%eax
f0100fa8:	01 c0                	add    %eax,%eax
f0100faa:	01 d0                	add    %edx,%eax
f0100fac:	c1 e0 02             	shl    $0x2,%eax
f0100faf:	05 40 a5 13 f0       	add    $0xf013a540,%eax
f0100fb4:	8b 10                	mov    (%eax),%edx
f0100fb6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0100fb9:	83 ec 08             	sub    $0x8,%esp
f0100fbc:	52                   	push   %edx
f0100fbd:	50                   	push   %eax
f0100fbe:	e8 f9 db 00 00       	call   f010ebbc <strcmp>
f0100fc3:	83 c4 10             	add    $0x10,%esp
f0100fc6:	85 c0                	test   %eax,%eax
f0100fc8:	75 09                	jne    f0100fd3 <execute_command+0x6f>
		{
			command_found = 1;
f0100fca:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
			break;
f0100fd1:	eb 0b                	jmp    f0100fde <execute_command+0x7a>
		return 0;

	// Lookup in the commands array and execute the command
	int command_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0100fd3:	ff 45 f0             	incl   -0x10(%ebp)
f0100fd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100fd9:	83 f8 24             	cmp    $0x24,%eax
f0100fdc:	76 c5                	jbe    f0100fa3 <execute_command+0x3f>
			command_found = 1;
			break;
		}
	}

	if(command_found)
f0100fde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100fe2:	74 2b                	je     f010100f <execute_command+0xab>
	{
		int return_value;
		return_value = commands[i].function_to_execute(number_of_arguments, arguments);
f0100fe4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100fe7:	89 d0                	mov    %edx,%eax
f0100fe9:	01 c0                	add    %eax,%eax
f0100feb:	01 d0                	add    %edx,%eax
f0100fed:	c1 e0 02             	shl    $0x2,%eax
f0100ff0:	05 48 a5 13 f0       	add    $0xf013a548,%eax
f0100ff5:	8b 00                	mov    (%eax),%eax
f0100ff7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100ffa:	83 ec 08             	sub    $0x8,%esp
f0100ffd:	8d 4d a8             	lea    -0x58(%ebp),%ecx
f0101000:	51                   	push   %ecx
f0101001:	52                   	push   %edx
f0101002:	ff d0                	call   *%eax
f0101004:	83 c4 10             	add    $0x10,%esp
f0101007:	89 45 ec             	mov    %eax,-0x14(%ebp)
		return return_value;
f010100a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010100d:	eb 19                	jmp    f0101028 <execute_command+0xc4>
	}
	else
	{
		//if not found, then it's unknown command
		cprintf("Unknown command '%s'\n", arguments[0]);
f010100f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0101012:	83 ec 08             	sub    $0x8,%esp
f0101015:	50                   	push   %eax
f0101016:	68 c6 fe 10 f0       	push   $0xf010fec6
f010101b:	e8 3b 50 00 00       	call   f010605b <cprintf>
f0101020:	83 c4 10             	add    $0x10,%esp
		return 0;
f0101023:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0101028:	c9                   	leave  
f0101029:	c3                   	ret    

f010102a <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f010102a:	55                   	push   %ebp
f010102b:	89 e5                	mov    %esp,%ebp
f010102d:	53                   	push   %ebx
f010102e:	83 ec 14             	sub    $0x14,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0101031:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101038:	eb 3b                	jmp    f0101075 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f010103a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010103d:	89 d0                	mov    %edx,%eax
f010103f:	01 c0                	add    %eax,%eax
f0101041:	01 d0                	add    %edx,%eax
f0101043:	c1 e0 02             	shl    $0x2,%eax
f0101046:	05 44 a5 13 f0       	add    $0xf013a544,%eax
f010104b:	8b 10                	mov    (%eax),%edx
f010104d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0101050:	89 c8                	mov    %ecx,%eax
f0101052:	01 c0                	add    %eax,%eax
f0101054:	01 c8                	add    %ecx,%eax
f0101056:	c1 e0 02             	shl    $0x2,%eax
f0101059:	05 40 a5 13 f0       	add    $0xf013a540,%eax
f010105e:	8b 00                	mov    (%eax),%eax
f0101060:	83 ec 04             	sub    $0x4,%esp
f0101063:	52                   	push   %edx
f0101064:	50                   	push   %eax
f0101065:	68 dc fe 10 f0       	push   $0xf010fedc
f010106a:	e8 ec 4f 00 00       	call   f010605b <cprintf>
f010106f:	83 c4 10             	add    $0x10,%esp

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0101072:	ff 45 f4             	incl   -0xc(%ebp)
f0101075:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101078:	83 f8 24             	cmp    $0x24,%eax
f010107b:	76 bd                	jbe    f010103a <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f010107d:	83 ec 0c             	sub    $0xc,%esp
f0101080:	68 e5 fe 10 f0       	push   $0xf010fee5
f0101085:	e8 d1 4f 00 00       	call   f010605b <cprintf>
f010108a:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f010108d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101094:	eb 42                	jmp    f01010d8 <command_help+0xae>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0101096:	8b 0d 5c a9 13 f0    	mov    0xf013a95c,%ecx
f010109c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010109f:	89 d0                	mov    %edx,%eax
f01010a1:	01 c0                	add    %eax,%eax
f01010a3:	01 d0                	add    %edx,%eax
f01010a5:	c1 e0 02             	shl    $0x2,%eax
f01010a8:	01 c8                	add    %ecx,%eax
f01010aa:	8b 50 04             	mov    0x4(%eax),%edx
f01010ad:	8b 1d 5c a9 13 f0    	mov    0xf013a95c,%ebx
f01010b3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01010b6:	89 c8                	mov    %ecx,%eax
f01010b8:	01 c0                	add    %eax,%eax
f01010ba:	01 c8                	add    %ecx,%eax
f01010bc:	c1 e0 02             	shl    $0x2,%eax
f01010bf:	01 d8                	add    %ebx,%eax
f01010c1:	8b 00                	mov    (%eax),%eax
f01010c3:	83 ec 04             	sub    $0x4,%esp
f01010c6:	52                   	push   %edx
f01010c7:	50                   	push   %eax
f01010c8:	68 fa fe 10 f0       	push   $0xf010fefa
f01010cd:	e8 89 4f 00 00       	call   f010605b <cprintf>
f01010d2:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f01010d5:	ff 45 f4             	incl   -0xc(%ebp)
f01010d8:	a1 60 a9 13 f0       	mov    0xf013a960,%eax
f01010dd:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f01010e0:	7c b4                	jl     f0101096 <command_help+0x6c>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f01010e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01010e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01010ea:	c9                   	leave  
f01010eb:	c3                   	ret    

f01010ec <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f01010ec:	55                   	push   %ebp
f01010ed:	89 e5                	mov    %esp,%ebp
f01010ef:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f01010f2:	83 ec 0c             	sub    $0xc,%esp
f01010f5:	68 16 ff 10 f0       	push   $0xf010ff16
f01010fa:	e8 5c 4f 00 00       	call   f010605b <cprintf>
f01010ff:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0101102:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0101107:	83 ec 04             	sub    $0x4,%esp
f010110a:	50                   	push   %eax
f010110b:	68 0c 00 10 f0       	push   $0xf010000c
f0101110:	68 30 ff 10 f0       	push   $0xf010ff30
f0101115:	e8 41 4f 00 00       	call   f010605b <cprintf>
f010111a:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f010111d:	b8 e5 f6 10 00       	mov    $0x10f6e5,%eax
f0101122:	83 ec 04             	sub    $0x4,%esp
f0101125:	50                   	push   %eax
f0101126:	68 e5 f6 10 f0       	push   $0xf010f6e5
f010112b:	68 6c ff 10 f0       	push   $0xf010ff6c
f0101130:	e8 26 4f 00 00       	call   f010605b <cprintf>
f0101135:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f0101138:	b8 c1 9e 42 00       	mov    $0x429ec1,%eax
f010113d:	83 ec 04             	sub    $0x4,%esp
f0101140:	50                   	push   %eax
f0101141:	68 c1 9e 42 f0       	push   $0xf0429ec1
f0101146:	68 a8 ff 10 f0       	push   $0xf010ffa8
f010114b:	e8 0b 4f 00 00       	call   f010605b <cprintf>
f0101150:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f0101153:	b8 c0 67 51 00       	mov    $0x5167c0,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	50                   	push   %eax
f010115c:	68 c0 67 51 f0       	push   $0xf05167c0
f0101161:	68 f0 ff 10 f0       	push   $0xf010fff0
f0101166:	e8 f0 4e 00 00       	call   f010605b <cprintf>
f010116b:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f010116e:	b8 c0 67 51 f0       	mov    $0xf05167c0,%eax
f0101173:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f0101179:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f010117e:	29 c2                	sub    %eax,%edx
f0101180:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f0101182:	85 c0                	test   %eax,%eax
f0101184:	79 05                	jns    f010118b <command_kernel_info+0x9f>
f0101186:	05 ff 03 00 00       	add    $0x3ff,%eax
f010118b:	c1 f8 0a             	sar    $0xa,%eax
f010118e:	83 ec 08             	sub    $0x8,%esp
f0101191:	50                   	push   %eax
f0101192:	68 2c 00 11 f0       	push   $0xf011002c
f0101197:	e8 bf 4e 00 00       	call   f010605b <cprintf>
f010119c:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010119f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01011a4:	c9                   	leave  
f01011a5:	c3                   	ret    

f01011a6 <command_writeusermem>:

int command_writeusermem(int number_of_arguments, char **arguments)
{
f01011a6:	55                   	push   %ebp
f01011a7:	89 e5                	mov    %esp,%ebp
f01011a9:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01011ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01011af:	83 c0 04             	add    $0x4,%eax
f01011b2:	8b 00                	mov    (%eax),%eax
f01011b4:	83 ec 04             	sub    $0x4,%esp
f01011b7:	6a 0a                	push   $0xa
f01011b9:	6a 00                	push   $0x0
f01011bb:	50                   	push   %eax
f01011bc:	e8 4f dc 00 00       	call   f010ee10 <strtol>
f01011c1:	83 c4 10             	add    $0x10,%esp
f01011c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f01011c7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f01011ce:	83 ec 04             	sub    $0x4,%esp
f01011d1:	6a 00                	push   $0x0
f01011d3:	8d 45 d8             	lea    -0x28(%ebp),%eax
f01011d6:	50                   	push   %eax
f01011d7:	ff 75 f4             	pushl  -0xc(%ebp)
f01011da:	e8 d8 10 00 00       	call   f01022b7 <envid2env>
f01011df:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[3], NULL, 16);
f01011e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01011e5:	83 c0 0c             	add    $0xc,%eax
f01011e8:	8b 00                	mov    (%eax),%eax
f01011ea:	83 ec 04             	sub    $0x4,%esp
f01011ed:	6a 10                	push   $0x10
f01011ef:	6a 00                	push   $0x0
f01011f1:	50                   	push   %eax
f01011f2:	e8 19 dc 00 00       	call   f010ee10 <strtol>
f01011f7:	83 c4 10             	add    $0x10,%esp
f01011fa:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if(env == NULL) return 0;
f01011fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0101200:	85 c0                	test   %eax,%eax
f0101202:	75 07                	jne    f010120b <command_writeusermem+0x65>
f0101204:	b8 00 00 00 00       	mov    $0x0,%eax
f0101209:	eb 43                	jmp    f010124e <command_writeusermem+0xa8>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010120b:	0f 20 d8             	mov    %cr3,%eax
f010120e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0101211:	8b 45 e8             	mov    -0x18(%ebp),%eax

	uint32 oldDir = rcr3();
f0101214:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32) (env->env_cr3));
f0101217:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010121a:	8b 40 60             	mov    0x60(%eax),%eax
f010121d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0101220:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101223:	0f 22 d8             	mov    %eax,%cr3

	unsigned char *ptr = (unsigned char *)(address) ;
f0101226:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101229:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	//Write the given Character
	*ptr = arguments[2][0];
f010122c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010122f:	83 c0 08             	add    $0x8,%eax
f0101232:	8b 00                	mov    (%eax),%eax
f0101234:	8a 00                	mov    (%eax),%al
f0101236:	88 c2                	mov    %al,%dl
f0101238:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010123b:	88 10                	mov    %dl,(%eax)
f010123d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101240:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0101243:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101246:	0f 22 d8             	mov    %eax,%cr3
	lcr3(oldDir);

	return 0;
f0101249:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010124e:	c9                   	leave  
f010124f:	c3                   	ret    

f0101250 <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f0101250:	55                   	push   %ebp
f0101251:	89 e5                	mov    %esp,%ebp
f0101253:	83 ec 28             	sub    $0x28,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0101256:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101259:	83 c0 04             	add    $0x4,%eax
f010125c:	8b 00                	mov    (%eax),%eax
f010125e:	83 ec 04             	sub    $0x4,%esp
f0101261:	6a 10                	push   $0x10
f0101263:	6a 00                	push   $0x0
f0101265:	50                   	push   %eax
f0101266:	e8 a5 db 00 00       	call   f010ee10 <strtol>
f010126b:	83 c4 10             	add    $0x10,%esp
f010126e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0101273:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int size = strtol(arguments[2], NULL, 10);
f0101276:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101279:	83 c0 08             	add    $0x8,%eax
f010127c:	8b 00                	mov    (%eax),%eax
f010127e:	83 ec 04             	sub    $0x4,%esp
f0101281:	6a 0a                	push   $0xa
f0101283:	6a 00                	push   $0x0
f0101285:	50                   	push   %eax
f0101286:	e8 85 db 00 00       	call   f010ee10 <strtol>
f010128b:	83 c4 10             	add    $0x10,%esp
f010128e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int c, i=0;
f0101291:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	int stringLen = strlen(arguments[3]);
f0101298:	8b 45 0c             	mov    0xc(%ebp),%eax
f010129b:	83 c0 0c             	add    $0xc,%eax
f010129e:	8b 00                	mov    (%eax),%eax
f01012a0:	83 ec 0c             	sub    $0xc,%esp
f01012a3:	50                   	push   %eax
f01012a4:	e8 07 d8 00 00       	call   f010eab0 <strlen>
f01012a9:	83 c4 10             	add    $0x10,%esp
f01012ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	for(c=0; c<size; c++)
f01012af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01012b6:	eb 30                	jmp    f01012e8 <command_writemem_k+0x98>
	{
		for(i=0;i < stringLen; i++)
f01012b8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012bf:	eb 1c                	jmp    f01012dd <command_writemem_k+0x8d>
		{
			*address = arguments[3][i];
f01012c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01012c4:	83 c0 0c             	add    $0xc,%eax
f01012c7:	8b 10                	mov    (%eax),%edx
f01012c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012cc:	01 d0                	add    %edx,%eax
f01012ce:	8a 00                	mov    (%eax),%al
f01012d0:	88 c2                	mov    %al,%dl
f01012d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01012d5:	88 10                	mov    %dl,(%eax)
			address++;
f01012d7:	ff 45 f4             	incl   -0xc(%ebp)
	int c, i=0;
	int stringLen = strlen(arguments[3]);

	for(c=0; c<size; c++)
	{
		for(i=0;i < stringLen; i++)
f01012da:	ff 45 ec             	incl   -0x14(%ebp)
f01012dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012e0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01012e3:	7c dc                	jl     f01012c1 <command_writemem_k+0x71>
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int size = strtol(arguments[2], NULL, 10);
	int c, i=0;
	int stringLen = strlen(arguments[3]);

	for(c=0; c<size; c++)
f01012e5:	ff 45 f0             	incl   -0x10(%ebp)
f01012e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01012eb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01012ee:	7c c8                	jl     f01012b8 <command_writemem_k+0x68>
		{
			*address = arguments[3][i];
			address++;
		}
	}
	return 0;
f01012f0:	b8 00 00 00 00       	mov    $0x0,%eax


}
f01012f5:	c9                   	leave  
f01012f6:	c3                   	ret    

f01012f7 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f01012f7:	55                   	push   %ebp
f01012f8:	89 e5                	mov    %esp,%ebp
f01012fa:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01012fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101300:	83 c0 04             	add    $0x4,%eax
f0101303:	8b 00                	mov    (%eax),%eax
f0101305:	83 ec 04             	sub    $0x4,%esp
f0101308:	6a 0a                	push   $0xa
f010130a:	6a 00                	push   $0x0
f010130c:	50                   	push   %eax
f010130d:	e8 fe da 00 00       	call   f010ee10 <strtol>
f0101312:	83 c4 10             	add    $0x10,%esp
f0101315:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0101318:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f010131f:	83 ec 04             	sub    $0x4,%esp
f0101322:	6a 00                	push   $0x0
f0101324:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0101327:	50                   	push   %eax
f0101328:	ff 75 f4             	pushl  -0xc(%ebp)
f010132b:	e8 87 0f 00 00       	call   f01022b7 <envid2env>
f0101330:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0101333:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101336:	83 c0 08             	add    $0x8,%eax
f0101339:	8b 00                	mov    (%eax),%eax
f010133b:	83 ec 04             	sub    $0x4,%esp
f010133e:	6a 10                	push   $0x10
f0101340:	6a 00                	push   $0x0
f0101342:	50                   	push   %eax
f0101343:	e8 c8 da 00 00       	call   f010ee10 <strtol>
f0101348:	83 c4 10             	add    $0x10,%esp
f010134b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if(env == NULL) return 0;
f010134e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0101351:	85 c0                	test   %eax,%eax
f0101353:	75 07                	jne    f010135c <command_readusermem+0x65>
f0101355:	b8 00 00 00 00       	mov    $0x0,%eax
f010135a:	eb 4e                	jmp    f01013aa <command_readusermem+0xb3>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010135c:	0f 20 d8             	mov    %cr3,%eax
f010135f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0101362:	8b 45 e8             	mov    -0x18(%ebp),%eax

	uint32 oldDir = rcr3();
f0101365:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0101368:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010136b:	8b 40 60             	mov    0x60(%eax),%eax
f010136e:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0101371:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101374:	0f 22 d8             	mov    %eax,%cr3

	unsigned char *ptr = (unsigned char *)(address) ;
f0101377:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010137a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	//Write the given Character
	cprintf("value at address %x = %c\n", address, *ptr);
f010137d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101380:	8a 00                	mov    (%eax),%al
f0101382:	0f b6 c0             	movzbl %al,%eax
f0101385:	83 ec 04             	sub    $0x4,%esp
f0101388:	50                   	push   %eax
f0101389:	ff 75 f0             	pushl  -0x10(%ebp)
f010138c:	68 57 00 11 f0       	push   $0xf0110057
f0101391:	e8 c5 4c 00 00       	call   f010605b <cprintf>
f0101396:	83 c4 10             	add    $0x10,%esp
f0101399:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010139c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010139f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01013a2:	0f 22 d8             	mov    %eax,%cr3

	lcr3(oldDir);
	return 0;
f01013a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01013aa:	c9                   	leave  
f01013ab:	c3                   	ret    

f01013ac <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f01013ac:	55                   	push   %ebp
f01013ad:	89 e5                	mov    %esp,%ebp
f01013af:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f01013b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01013b5:	83 c0 04             	add    $0x4,%eax
f01013b8:	8b 00                	mov    (%eax),%eax
f01013ba:	83 ec 04             	sub    $0x4,%esp
f01013bd:	6a 10                	push   $0x10
f01013bf:	6a 00                	push   $0x0
f01013c1:	50                   	push   %eax
f01013c2:	e8 49 da 00 00       	call   f010ee10 <strtol>
f01013c7:	83 c4 10             	add    $0x10,%esp
f01013ca:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01013cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int size = strtol(arguments[2], NULL, 10);
f01013d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01013d5:	83 c0 08             	add    $0x8,%eax
f01013d8:	8b 00                	mov    (%eax),%eax
f01013da:	83 ec 04             	sub    $0x4,%esp
f01013dd:	6a 0a                	push   $0xa
f01013df:	6a 00                	push   $0x0
f01013e1:	50                   	push   %eax
f01013e2:	e8 29 da 00 00       	call   f010ee10 <strtol>
f01013e7:	83 c4 10             	add    $0x10,%esp
f01013ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int i=0;
f01013ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for(;i < size; i++)
f01013f4:	eb 22                	jmp    f0101418 <command_readmem_k+0x6c>
	{
		cprintf("%c",*address++);
f01013f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01013f9:	8d 50 01             	lea    0x1(%eax),%edx
f01013fc:	89 55 f4             	mov    %edx,-0xc(%ebp)
f01013ff:	8a 00                	mov    (%eax),%al
f0101401:	0f b6 c0             	movzbl %al,%eax
f0101404:	83 ec 08             	sub    $0x8,%esp
f0101407:	50                   	push   %eax
f0101408:	68 71 00 11 f0       	push   $0xf0110071
f010140d:	e8 49 4c 00 00       	call   f010605b <cprintf>
f0101412:	83 c4 10             	add    $0x10,%esp
int command_readmem_k(int number_of_arguments, char **arguments)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int size = strtol(arguments[2], NULL, 10);
	int i=0;
	for(;i < size; i++)
f0101415:	ff 45 f0             	incl   -0x10(%ebp)
f0101418:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010141b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010141e:	7c d6                	jl     f01013f6 <command_readmem_k+0x4a>
	{
		cprintf("%c",*address++);
	}
	cprintf("\n");
f0101420:	83 ec 0c             	sub    $0xc,%esp
f0101423:	68 74 00 11 f0       	push   $0xf0110074
f0101428:	e8 2e 4c 00 00       	call   f010605b <cprintf>
f010142d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101430:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101435:	c9                   	leave  
f0101436:	c3                   	ret    

f0101437 <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0101437:	55                   	push   %ebp
f0101438:	89 e5                	mov    %esp,%ebp
f010143a:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010143d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101440:	83 c0 04             	add    $0x4,%eax
f0101443:	8b 00                	mov    (%eax),%eax
f0101445:	83 ec 04             	sub    $0x4,%esp
f0101448:	6a 0a                	push   $0xa
f010144a:	6a 00                	push   $0x0
f010144c:	50                   	push   %eax
f010144d:	e8 be d9 00 00       	call   f010ee10 <strtol>
f0101452:	83 c4 10             	add    $0x10,%esp
f0101455:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0101458:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f010145f:	83 ec 04             	sub    $0x4,%esp
f0101462:	6a 00                	push   $0x0
f0101464:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101467:	50                   	push   %eax
f0101468:	ff 75 ec             	pushl  -0x14(%ebp)
f010146b:	e8 47 0e 00 00       	call   f01022b7 <envid2env>
f0101470:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0101473:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101476:	83 c0 08             	add    $0x8,%eax
f0101479:	8b 00                	mov    (%eax),%eax
f010147b:	83 ec 04             	sub    $0x4,%esp
f010147e:	6a 10                	push   $0x10
f0101480:	6a 00                	push   $0x0
f0101482:	50                   	push   %eax
f0101483:	e8 88 d9 00 00       	call   f010ee10 <strtol>
f0101488:	83 c4 10             	add    $0x10,%esp
f010148b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f010148e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101491:	83 c0 0c             	add    $0xc,%eax
f0101494:	8b 00                	mov    (%eax),%eax
f0101496:	83 ec 04             	sub    $0x4,%esp
f0101499:	6a 0a                	push   $0xa
f010149b:	6a 00                	push   $0x0
f010149d:	50                   	push   %eax
f010149e:	e8 6d d9 00 00       	call   f010ee10 <strtol>
f01014a3:	83 c4 10             	add    $0x10,%esp
f01014a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f01014a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01014ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f01014af:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01014b2:	85 c0                	test   %eax,%eax
f01014b4:	75 07                	jne    f01014bd <command_readuserblock+0x86>
f01014b6:	b8 00 00 00 00       	mov    $0x0,%eax
f01014bb:	eb 65                	jmp    f0101522 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01014bd:	0f 20 d8             	mov    %cr3,%eax
f01014c0:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01014c3:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f01014c6:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f01014c9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01014cc:	8b 40 60             	mov    0x60(%eax),%eax
f01014cf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01014d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01014d5:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f01014d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01014df:	eb 28                	jmp    f0101509 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f01014e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01014e4:	8a 00                	mov    (%eax),%al
f01014e6:	0f b6 d0             	movzbl %al,%edx
f01014e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01014ec:	8a 00                	mov    (%eax),%al
f01014ee:	0f b6 c0             	movzbl %al,%eax
f01014f1:	52                   	push   %edx
f01014f2:	50                   	push   %eax
f01014f3:	ff 75 f4             	pushl  -0xc(%ebp)
f01014f6:	68 76 00 11 f0       	push   $0xf0110076
f01014fb:	e8 5b 4b 00 00       	call   f010605b <cprintf>
f0101500:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0101503:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0101506:	ff 45 f0             	incl   -0x10(%ebp)
f0101509:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010150c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010150f:	7c d0                	jl     f01014e1 <command_readuserblock+0xaa>
f0101511:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101514:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101517:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010151a:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f010151d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101522:	c9                   	leave  
f0101523:	c3                   	ret    

f0101524 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0101524:	55                   	push   %ebp
f0101525:	89 e5                	mov    %esp,%ebp
f0101527:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010152a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010152d:	83 c0 04             	add    $0x4,%eax
f0101530:	8b 00                	mov    (%eax),%eax
f0101532:	83 ec 04             	sub    $0x4,%esp
f0101535:	6a 0a                	push   $0xa
f0101537:	6a 00                	push   $0x0
f0101539:	50                   	push   %eax
f010153a:	e8 d1 d8 00 00       	call   f010ee10 <strtol>
f010153f:	83 c4 10             	add    $0x10,%esp
f0101542:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0101545:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f010154c:	83 ec 04             	sub    $0x4,%esp
f010154f:	6a 00                	push   $0x0
f0101551:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0101554:	50                   	push   %eax
f0101555:	ff 75 f4             	pushl  -0xc(%ebp)
f0101558:	e8 5a 0d 00 00       	call   f01022b7 <envid2env>
f010155d:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0101560:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0101563:	85 c0                	test   %eax,%eax
f0101565:	75 0a                	jne    f0101571 <command_remove_table+0x4d>
f0101567:	b8 00 00 00 00       	mov    $0x0,%eax
f010156c:	e9 c7 00 00 00       	jmp    f0101638 <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0101571:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101574:	83 c0 08             	add    $0x8,%eax
f0101577:	8b 00                	mov    (%eax),%eax
f0101579:	83 ec 04             	sub    $0x4,%esp
f010157c:	6a 10                	push   $0x10
f010157e:	6a 00                	push   $0x0
f0101580:	50                   	push   %eax
f0101581:	e8 8a d8 00 00       	call   f010ee10 <strtol>
f0101586:	83 c4 10             	add    $0x10,%esp
f0101589:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f010158c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010158f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0101592:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0101595:	8b 40 5c             	mov    0x5c(%eax),%eax
f0101598:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010159b:	c1 ea 16             	shr    $0x16,%edx
f010159e:	c1 e2 02             	shl    $0x2,%edx
f01015a1:	01 d0                	add    %edx,%eax
f01015a3:	8b 00                	mov    (%eax),%eax
f01015a5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01015aa:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f01015ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01015b0:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f01015b5:	77 1c                	ja     f01015d3 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f01015b7:	83 ec 0c             	sub    $0xc,%esp
f01015ba:	ff 75 e8             	pushl  -0x18(%ebp)
f01015bd:	e8 e1 9b 00 00       	call   f010b1a3 <kheap_virtual_address>
f01015c2:	83 c4 10             	add    $0x10,%esp
f01015c5:	83 ec 0c             	sub    $0xc,%esp
f01015c8:	50                   	push   %eax
f01015c9:	e8 d0 9a 00 00       	call   f010b09e <kfree>
f01015ce:	83 c4 10             	add    $0x10,%esp
f01015d1:	eb 28                	jmp    f01015fb <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and Frame_Info of the page table
		struct Frame_Info *table_frame_info = to_frame_info(table_pa);
f01015d3:	83 ec 0c             	sub    $0xc,%esp
f01015d6:	ff 75 e8             	pushl  -0x18(%ebp)
f01015d9:	e8 9f f4 ff ff       	call   f0100a7d <to_frame_info>
f01015de:	83 c4 10             	add    $0x10,%esp
f01015e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_frame_info->references = 0;
f01015e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01015e7:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_frame_info);
f01015ed:	83 ec 0c             	sub    $0xc,%esp
f01015f0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01015f3:	e8 8b 16 00 00       	call   f0102c83 <free_frame>
f01015f8:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f01015fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01015fe:	c1 e8 16             	shr    $0x16,%eax
f0101601:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0101604:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0101607:	8b 40 5c             	mov    0x5c(%eax),%eax
f010160a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010160d:	c1 e2 02             	shl    $0x2,%edx
f0101610:	01 c2                	add    %eax,%edx
f0101612:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0101615:	8b 40 5c             	mov    0x5c(%eax),%eax
f0101618:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f010161b:	c1 e1 02             	shl    $0x2,%ecx
f010161e:	01 c8                	add    %ecx,%eax
f0101620:	8b 00                	mov    (%eax),%eax
f0101622:	83 e0 fe             	and    $0xfffffffe,%eax
f0101625:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0101627:	0f 20 d8             	mov    %cr3,%eax
f010162a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010162d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101630:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0101633:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101638:	c9                   	leave  
f0101639:	c3                   	ret    

f010163a <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f010163a:	55                   	push   %ebp
f010163b:	89 e5                	mov    %esp,%ebp
f010163d:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0101640:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101643:	83 c0 04             	add    $0x4,%eax
f0101646:	8b 00                	mov    (%eax),%eax
f0101648:	83 ec 04             	sub    $0x4,%esp
f010164b:	6a 0a                	push   $0xa
f010164d:	6a 00                	push   $0x0
f010164f:	50                   	push   %eax
f0101650:	e8 bb d7 00 00       	call   f010ee10 <strtol>
f0101655:	83 c4 10             	add    $0x10,%esp
f0101658:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f010165b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	envid2env(envId, &env, 0 );
f0101662:	83 ec 04             	sub    $0x4,%esp
f0101665:	6a 00                	push   $0x0
f0101667:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010166a:	50                   	push   %eax
f010166b:	ff 75 f4             	pushl  -0xc(%ebp)
f010166e:	e8 44 0c 00 00       	call   f01022b7 <envid2env>
f0101673:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0101676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101679:	85 c0                	test   %eax,%eax
f010167b:	75 07                	jne    f0101684 <command_allocuserpage+0x4a>
f010167d:	b8 00 00 00 00       	mov    $0x0,%eax
f0101682:	eb 6d                	jmp    f01016f1 <command_allocuserpage+0xb7>

	uint32 address = strtol(arguments[2], NULL, 16);
f0101684:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101687:	83 c0 08             	add    $0x8,%eax
f010168a:	8b 00                	mov    (%eax),%eax
f010168c:	83 ec 04             	sub    $0x4,%esp
f010168f:	6a 10                	push   $0x10
f0101691:	6a 00                	push   $0x0
f0101693:	50                   	push   %eax
f0101694:	e8 77 d7 00 00       	call   f010ee10 <strtol>
f0101699:	83 c4 10             	add    $0x10,%esp
f010169c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f010169f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01016a2:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct Frame_Info * ptr_frame_info ;
	int ret = allocate_frame(&ptr_frame_info);
f01016a5:	83 ec 0c             	sub    $0xc,%esp
f01016a8:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01016ab:	50                   	push   %eax
f01016ac:	e8 e7 14 00 00       	call   f0102b98 <allocate_frame>
f01016b1:	83 c4 10             	add    $0x10,%esp
f01016b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f01016b7:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01016bb:	75 17                	jne    f01016d4 <command_allocuserpage+0x9a>
	{
		cprintf("ERROR: no enough memory\n");
f01016bd:	83 ec 0c             	sub    $0xc,%esp
f01016c0:	68 87 00 11 f0       	push   $0xf0110087
f01016c5:	e8 91 49 00 00       	call   f010605b <cprintf>
f01016ca:	83 c4 10             	add    $0x10,%esp
		return 0;
f01016cd:	b8 00 00 00 00       	mov    $0x0,%eax
f01016d2:	eb 1d                	jmp    f01016f1 <command_allocuserpage+0xb7>
	}

	// Map this frame to the given user virtual address
	map_frame(env->env_page_directory, ptr_frame_info, va, PERM_WRITEABLE | PERM_USER);
f01016d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01016d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01016da:	8b 40 5c             	mov    0x5c(%eax),%eax
f01016dd:	6a 06                	push   $0x6
f01016df:	ff 75 ec             	pushl  -0x14(%ebp)
f01016e2:	52                   	push   %edx
f01016e3:	50                   	push   %eax
f01016e4:	e8 b2 18 00 00       	call   f0102f9b <map_frame>
f01016e9:	83 c4 10             	add    $0x10,%esp

	return 0;
f01016ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01016f1:	c9                   	leave  
f01016f2:	c3                   	ret    

f01016f3 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f01016f3:	55                   	push   %ebp
f01016f4:	89 e5                	mov    %esp,%ebp
f01016f6:	56                   	push   %esi
f01016f7:	53                   	push   %ebx
f01016f8:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f01016fb:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01016fe:	83 ec 0c             	sub    $0xc,%esp
f0101701:	50                   	push   %eax
f0101702:	e8 15 1e 00 00       	call   f010351c <calculate_available_frames>
f0101707:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f010170a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010170d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101710:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0101713:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0101716:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0101719:	01 de                	add    %ebx,%esi
f010171b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f010171e:	01 f3                	add    %esi,%ebx
f0101720:	83 ec 0c             	sub    $0xc,%esp
f0101723:	51                   	push   %ecx
f0101724:	52                   	push   %edx
f0101725:	50                   	push   %eax
f0101726:	53                   	push   %ebx
f0101727:	68 a0 00 11 f0       	push   $0xf01100a0
f010172c:	e8 2a 49 00 00       	call   f010605b <cprintf>
f0101731:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
	return 0;
f0101734:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101739:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010173c:	5b                   	pop    %ebx
f010173d:	5e                   	pop    %esi
f010173e:	5d                   	pop    %ebp
f010173f:	c3                   	ret    

f0101740 <command_run_program>:


int command_run_program(int number_of_arguments, char **arguments)
{
f0101740:	55                   	push   %ebp
f0101741:	89 e5                	mov    %esp,%ebp
f0101743:	83 ec 18             	sub    $0x18,%esp
	struct Env* env;
	if(USE_KHEAP)
	{
		if(number_of_arguments < 3)
f0101746:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010174a:	7f 17                	jg     f0101763 <command_run_program+0x23>
		{
			cprintf("Error: Please specify a working set size in the third argument, aborting.\n");
f010174c:	83 ec 0c             	sub    $0xc,%esp
f010174f:	68 f8 00 11 f0       	push   $0xf01100f8
f0101754:	e8 02 49 00 00       	call   f010605b <cprintf>
f0101759:	83 c4 10             	add    $0x10,%esp
			return 0;
f010175c:	b8 00 00 00 00       	mov    $0x0,%eax
f0101761:	eb 7b                	jmp    f01017de <command_run_program+0x9e>
		}
		env = env_create(arguments[1], strtol(arguments[2], NULL, 10));
f0101763:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101766:	83 c0 08             	add    $0x8,%eax
f0101769:	8b 00                	mov    (%eax),%eax
f010176b:	83 ec 04             	sub    $0x4,%esp
f010176e:	6a 0a                	push   $0xa
f0101770:	6a 00                	push   $0x0
f0101772:	50                   	push   %eax
f0101773:	e8 98 d6 00 00       	call   f010ee10 <strtol>
f0101778:	83 c4 10             	add    $0x10,%esp
f010177b:	89 c2                	mov    %eax,%edx
f010177d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101780:	83 c0 04             	add    $0x4,%eax
f0101783:	8b 00                	mov    (%eax),%eax
f0101785:	83 ec 08             	sub    $0x8,%esp
f0101788:	52                   	push   %edx
f0101789:	50                   	push   %eax
f010178a:	e8 98 34 00 00       	call   f0104c27 <env_create>
f010178f:	83 c4 10             	add    $0x10,%esp
f0101792:	89 45 f4             	mov    %eax,-0xc(%ebp)
	else
	{
		env = env_create(arguments[1], __PWS_MAX_SIZE);
	}

	if(env == NULL) return 0;
f0101795:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101799:	75 07                	jne    f01017a2 <command_run_program+0x62>
f010179b:	b8 00 00 00 00       	mov    $0x0,%eax
f01017a0:	eb 3c                	jmp    f01017de <command_run_program+0x9e>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f01017a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01017a5:	8b 40 4c             	mov    0x4c(%eax),%eax
f01017a8:	83 ec 08             	sub    $0x8,%esp
f01017ab:	50                   	push   %eax
f01017ac:	68 43 01 11 f0       	push   $0xf0110143
f01017b1:	e8 a5 48 00 00       	call   f010605b <cprintf>
f01017b6:	83 c4 10             	add    $0x10,%esp

	sched_new_env(env);
f01017b9:	83 ec 0c             	sub    $0xc,%esp
f01017bc:	ff 75 f4             	pushl  -0xc(%ebp)
f01017bf:	e8 38 70 00 00       	call   f01087fc <sched_new_env>
f01017c4:	83 c4 10             	add    $0x10,%esp
	sched_run_env(env->env_id);
f01017c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01017ca:	8b 40 4c             	mov    0x4c(%eax),%eax
f01017cd:	83 ec 0c             	sub    $0xc,%esp
f01017d0:	50                   	push   %eax
f01017d1:	e8 3d 70 00 00       	call   f0108813 <sched_run_env>
f01017d6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01017d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01017de:	c9                   	leave  
f01017df:	c3                   	ret    

f01017e0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01017e0:	55                   	push   %ebp
f01017e1:	89 e5                	mov    %esp,%ebp
f01017e3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01017e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01017e9:	83 c0 04             	add    $0x4,%eax
f01017ec:	8b 00                	mov    (%eax),%eax
f01017ee:	83 ec 04             	sub    $0x4,%esp
f01017f1:	6a 0a                	push   $0xa
f01017f3:	6a 00                	push   $0x0
f01017f5:	50                   	push   %eax
f01017f6:	e8 15 d6 00 00       	call   f010ee10 <strtol>
f01017fb:	83 c4 10             	add    $0x10,%esp
f01017fe:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0101801:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101804:	83 ec 0c             	sub    $0xc,%esp
f0101807:	50                   	push   %eax
f0101808:	e8 a0 71 00 00       	call   f01089ad <sched_kill_env>
f010180d:	83 c4 10             	add    $0x10,%esp

	return 0;
f0101810:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101815:	c9                   	leave  
f0101816:	c3                   	ret    

f0101817 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0101817:	55                   	push   %ebp
f0101818:	89 e5                	mov    %esp,%ebp
f010181a:	83 ec 18             	sub    $0x18,%esp
	struct Env* env;
	if(USE_KHEAP)
	{
		if(number_of_arguments < 3)
f010181d:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0101821:	7f 17                	jg     f010183a <commnad_load_env+0x23>
		{
			cprintf("Error: Please specify a working set size in the third argument, aborting.\n");
f0101823:	83 ec 0c             	sub    $0xc,%esp
f0101826:	68 f8 00 11 f0       	push   $0xf01100f8
f010182b:	e8 2b 48 00 00       	call   f010605b <cprintf>
f0101830:	83 c4 10             	add    $0x10,%esp
			return 0;
f0101833:	b8 00 00 00 00       	mov    $0x0,%eax
f0101838:	eb 69                	jmp    f01018a3 <commnad_load_env+0x8c>
		}
		env = env_create(arguments[1], strtol(arguments[2], NULL, 10));
f010183a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010183d:	83 c0 08             	add    $0x8,%eax
f0101840:	8b 00                	mov    (%eax),%eax
f0101842:	83 ec 04             	sub    $0x4,%esp
f0101845:	6a 0a                	push   $0xa
f0101847:	6a 00                	push   $0x0
f0101849:	50                   	push   %eax
f010184a:	e8 c1 d5 00 00       	call   f010ee10 <strtol>
f010184f:	83 c4 10             	add    $0x10,%esp
f0101852:	89 c2                	mov    %eax,%edx
f0101854:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101857:	83 c0 04             	add    $0x4,%eax
f010185a:	8b 00                	mov    (%eax),%eax
f010185c:	83 ec 08             	sub    $0x8,%esp
f010185f:	52                   	push   %edx
f0101860:	50                   	push   %eax
f0101861:	e8 c1 33 00 00       	call   f0104c27 <env_create>
f0101866:	83 c4 10             	add    $0x10,%esp
f0101869:	89 45 f4             	mov    %eax,-0xc(%ebp)
	else
	{
		env = env_create(arguments[1], __PWS_MAX_SIZE);
	}

	if (env == NULL)
f010186c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101870:	75 07                	jne    f0101879 <commnad_load_env+0x62>
		return 0 ;
f0101872:	b8 00 00 00 00       	mov    $0x0,%eax
f0101877:	eb 2a                	jmp    f01018a3 <commnad_load_env+0x8c>

	sched_new_env(env) ;
f0101879:	83 ec 0c             	sub    $0xc,%esp
f010187c:	ff 75 f4             	pushl  -0xc(%ebp)
f010187f:	e8 78 6f 00 00       	call   f01087fc <sched_new_env>
f0101884:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0101887:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010188a:	8b 40 4c             	mov    0x4c(%eax),%eax
f010188d:	83 ec 08             	sub    $0x8,%esp
f0101890:	50                   	push   %eax
f0101891:	68 43 01 11 f0       	push   $0xf0110143
f0101896:	e8 c0 47 00 00       	call   f010605b <cprintf>
f010189b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010189e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01018a3:	c9                   	leave  
f01018a4:	c3                   	ret    

f01018a5 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f01018a5:	55                   	push   %ebp
f01018a6:	89 e5                	mov    %esp,%ebp
f01018a8:	83 ec 08             	sub    $0x8,%esp
	sched_run_all();
f01018ab:	e8 95 6c 00 00       	call   f0108545 <sched_run_all>

	return 0 ;
f01018b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01018b5:	c9                   	leave  
f01018b6:	c3                   	ret    

f01018b7 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f01018b7:	55                   	push   %ebp
f01018b8:	89 e5                	mov    %esp,%ebp
f01018ba:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f01018bd:	e8 cb 6a 00 00       	call   f010838d <sched_print_all>

	return 0 ;
f01018c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01018c7:	c9                   	leave  
f01018c8:	c3                   	ret    

f01018c9 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f01018c9:	55                   	push   %ebp
f01018ca:	89 e5                	mov    %esp,%ebp
f01018cc:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01018cf:	e8 de 6c 00 00       	call   f01085b2 <sched_kill_all>

	return 0 ;
f01018d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01018d9:	c9                   	leave  
f01018da:	c3                   	ret    

f01018db <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f01018db:	55                   	push   %ebp
f01018dc:	89 e5                	mov    %esp,%ebp
f01018de:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmLRU();
f01018e1:	e8 53 5c 00 00       	call   f0107539 <setPageReplacmentAlgorithmLRU>
	cprintf("Page replacement algorithm is now LRU\n");
f01018e6:	83 ec 0c             	sub    $0xc,%esp
f01018e9:	68 58 01 11 f0       	push   $0xf0110158
f01018ee:	e8 68 47 00 00       	call   f010605b <cprintf>
f01018f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01018f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01018fb:	c9                   	leave  
f01018fc:	c3                   	ret    

f01018fd <command_set_page_rep_CLOCK>:

int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f01018fd:	55                   	push   %ebp
f01018fe:	89 e5                	mov    %esp,%ebp
f0101900:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0101903:	e8 41 5c 00 00       	call   f0107549 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0101908:	83 ec 0c             	sub    $0xc,%esp
f010190b:	68 80 01 11 f0       	push   $0xf0110180
f0101910:	e8 46 47 00 00       	call   f010605b <cprintf>
f0101915:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101918:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010191d:	c9                   	leave  
f010191e:	c3                   	ret    

f010191f <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010191f:	55                   	push   %ebp
f0101920:	89 e5                	mov    %esp,%ebp
f0101922:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0101925:	e8 2f 5c 00 00       	call   f0107559 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f010192a:	83 ec 0c             	sub    $0xc,%esp
f010192d:	68 ac 01 11 f0       	push   $0xf01101ac
f0101932:	e8 24 47 00 00       	call   f010605b <cprintf>
f0101937:	83 c4 10             	add    $0x10,%esp
	return 0;
f010193a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010193f:	c9                   	leave  
f0101940:	c3                   	ret    

f0101941 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0101941:	55                   	push   %ebp
f0101942:	89 e5                	mov    %esp,%ebp
f0101944:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0101947:	e8 1d 5c 00 00       	call   f0107569 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f010194c:	83 ec 0c             	sub    $0xc,%esp
f010194f:	68 d4 01 11 f0       	push   $0xf01101d4
f0101954:	e8 02 47 00 00       	call   f010605b <cprintf>
f0101959:	83 c4 10             	add    $0x10,%esp
	return 0;
f010195c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101961:	c9                   	leave  
f0101962:	c3                   	ret    

f0101963 <command_print_page_rep>:

/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f0101963:	55                   	push   %ebp
f0101964:	89 e5                	mov    %esp,%ebp
f0101966:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0101969:	e8 26 5c 00 00       	call   f0107594 <isPageReplacmentAlgorithmCLOCK>
f010196e:	85 c0                	test   %eax,%eax
f0101970:	74 12                	je     f0101984 <command_print_page_rep+0x21>
		cprintf("Page replacement algorithm is CLOCK\n");
f0101972:	83 ec 0c             	sub    $0xc,%esp
f0101975:	68 08 02 11 f0       	push   $0xf0110208
f010197a:	e8 dc 46 00 00       	call   f010605b <cprintf>
f010197f:	83 c4 10             	add    $0x10,%esp
f0101982:	eb 61                	jmp    f01019e5 <command_print_page_rep+0x82>
	else if (isPageReplacmentAlgorithmLRU())
f0101984:	e8 f0 5b 00 00       	call   f0107579 <isPageReplacmentAlgorithmLRU>
f0101989:	85 c0                	test   %eax,%eax
f010198b:	74 12                	je     f010199f <command_print_page_rep+0x3c>
		cprintf("Page replacement algorithm is LRU\n");
f010198d:	83 ec 0c             	sub    $0xc,%esp
f0101990:	68 30 02 11 f0       	push   $0xf0110230
f0101995:	e8 c1 46 00 00       	call   f010605b <cprintf>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	eb 46                	jmp    f01019e5 <command_print_page_rep+0x82>
	else if (isPageReplacmentAlgorithmFIFO())
f010199f:	e8 0b 5c 00 00       	call   f01075af <isPageReplacmentAlgorithmFIFO>
f01019a4:	85 c0                	test   %eax,%eax
f01019a6:	74 12                	je     f01019ba <command_print_page_rep+0x57>
		cprintf("Page replacement algorithm is FIFO\n");
f01019a8:	83 ec 0c             	sub    $0xc,%esp
f01019ab:	68 54 02 11 f0       	push   $0xf0110254
f01019b0:	e8 a6 46 00 00       	call   f010605b <cprintf>
f01019b5:	83 c4 10             	add    $0x10,%esp
f01019b8:	eb 2b                	jmp    f01019e5 <command_print_page_rep+0x82>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01019ba:	e8 0b 5c 00 00       	call   f01075ca <isPageReplacmentAlgorithmModifiedCLOCK>
f01019bf:	85 c0                	test   %eax,%eax
f01019c1:	74 12                	je     f01019d5 <command_print_page_rep+0x72>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01019c3:	83 ec 0c             	sub    $0xc,%esp
f01019c6:	68 78 02 11 f0       	push   $0xf0110278
f01019cb:	e8 8b 46 00 00       	call   f010605b <cprintf>
f01019d0:	83 c4 10             	add    $0x10,%esp
f01019d3:	eb 10                	jmp    f01019e5 <command_print_page_rep+0x82>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f01019d5:	83 ec 0c             	sub    $0xc,%esp
f01019d8:	68 a8 02 11 f0       	push   $0xf01102a8
f01019dd:	e8 79 46 00 00       	call   f010605b <cprintf>
f01019e2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01019e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01019ea:	c9                   	leave  
f01019eb:	c3                   	ret    

f01019ec <command_set_heap_plac_FIRSTFIT>:


int command_set_heap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01019ec:	55                   	push   %ebp
f01019ed:	89 e5                	mov    %esp,%ebp
f01019ef:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f01019f2:	e8 42 2b 00 00       	call   f0104539 <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f01019f7:	83 ec 0c             	sub    $0xc,%esp
f01019fa:	68 d4 02 11 f0       	push   $0xf01102d4
f01019ff:	e8 57 46 00 00       	call   f010605b <cprintf>
f0101a04:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101a07:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101a0c:	c9                   	leave  
f0101a0d:	c3                   	ret    

f0101a0e <command_set_heap_plac_BESTFIT>:

int command_set_heap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0101a0e:	55                   	push   %ebp
f0101a0f:	89 e5                	mov    %esp,%ebp
f0101a11:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f0101a14:	e8 30 2b 00 00       	call   f0104549 <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f0101a19:	83 ec 0c             	sub    $0xc,%esp
f0101a1c:	68 04 03 11 f0       	push   $0xf0110304
f0101a21:	e8 35 46 00 00       	call   f010605b <cprintf>
f0101a26:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101a29:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101a2e:	c9                   	leave  
f0101a2f:	c3                   	ret    

f0101a30 <command_set_heap_plac_NEXTFIT>:

int command_set_heap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0101a30:	55                   	push   %ebp
f0101a31:	89 e5                	mov    %esp,%ebp
f0101a33:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f0101a36:	e8 1e 2b 00 00       	call   f0104559 <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f0101a3b:	83 ec 0c             	sub    $0xc,%esp
f0101a3e:	68 34 03 11 f0       	push   $0xf0110334
f0101a43:	e8 13 46 00 00       	call   f010605b <cprintf>
f0101a48:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101a4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101a50:	c9                   	leave  
f0101a51:	c3                   	ret    

f0101a52 <command_set_heap_plac_WORSTFIT>:
int command_set_heap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0101a52:	55                   	push   %ebp
f0101a53:	89 e5                	mov    %esp,%ebp
f0101a55:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f0101a58:	e8 0c 2b 00 00       	call   f0104569 <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0101a5d:	83 ec 0c             	sub    $0xc,%esp
f0101a60:	68 64 03 11 f0       	push   $0xf0110364
f0101a65:	e8 f1 45 00 00       	call   f010605b <cprintf>
f0101a6a:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101a6d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101a72:	c9                   	leave  
f0101a73:	c3                   	ret    

f0101a74 <command_print_heap_plac>:

int command_print_heap_plac(int number_of_arguments, char **arguments)
{
f0101a74:	55                   	push   %ebp
f0101a75:	89 e5                	mov    %esp,%ebp
f0101a77:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0101a7a:	e8 fa 2a 00 00       	call   f0104579 <isUHeapPlacementStrategyFIRSTFIT>
f0101a7f:	85 c0                	test   %eax,%eax
f0101a81:	74 12                	je     f0101a95 <command_print_heap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0101a83:	83 ec 0c             	sub    $0xc,%esp
f0101a86:	68 94 03 11 f0       	push   $0xf0110394
f0101a8b:	e8 cb 45 00 00       	call   f010605b <cprintf>
f0101a90:	83 c4 10             	add    $0x10,%esp
f0101a93:	eb 61                	jmp    f0101af6 <command_print_heap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f0101a95:	e8 fa 2a 00 00       	call   f0104594 <isUHeapPlacementStrategyBESTFIT>
f0101a9a:	85 c0                	test   %eax,%eax
f0101a9c:	74 12                	je     f0101ab0 <command_print_heap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0101a9e:	83 ec 0c             	sub    $0xc,%esp
f0101aa1:	68 c0 03 11 f0       	push   $0xf01103c0
f0101aa6:	e8 b0 45 00 00       	call   f010605b <cprintf>
f0101aab:	83 c4 10             	add    $0x10,%esp
f0101aae:	eb 46                	jmp    f0101af6 <command_print_heap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0101ab0:	e8 fa 2a 00 00       	call   f01045af <isUHeapPlacementStrategyNEXTFIT>
f0101ab5:	85 c0                	test   %eax,%eax
f0101ab7:	74 12                	je     f0101acb <command_print_heap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0101ab9:	83 ec 0c             	sub    $0xc,%esp
f0101abc:	68 ec 03 11 f0       	push   $0xf01103ec
f0101ac1:	e8 95 45 00 00       	call   f010605b <cprintf>
f0101ac6:	83 c4 10             	add    $0x10,%esp
f0101ac9:	eb 2b                	jmp    f0101af6 <command_print_heap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0101acb:	e8 fa 2a 00 00       	call   f01045ca <isUHeapPlacementStrategyWORSTFIT>
f0101ad0:	85 c0                	test   %eax,%eax
f0101ad2:	74 12                	je     f0101ae6 <command_print_heap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f0101ad4:	83 ec 0c             	sub    $0xc,%esp
f0101ad7:	68 18 04 11 f0       	push   $0xf0110418
f0101adc:	e8 7a 45 00 00       	call   f010605b <cprintf>
f0101ae1:	83 c4 10             	add    $0x10,%esp
f0101ae4:	eb 10                	jmp    f0101af6 <command_print_heap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f0101ae6:	83 ec 0c             	sub    $0xc,%esp
f0101ae9:	68 44 04 11 f0       	push   $0xf0110444
f0101aee:	e8 68 45 00 00       	call   f010605b <cprintf>
f0101af3:	83 c4 10             	add    $0x10,%esp

	return 0;
f0101af6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101afb:	c9                   	leave  
f0101afc:	c3                   	ret    

f0101afd <command_disable_modified_buffer>:

/*2015*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0101afd:	55                   	push   %ebp
f0101afe:	89 e5                	mov    %esp,%ebp
f0101b00:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0101b03:	e8 03 5b 00 00       	call   f010760b <isBufferingEnabled>
f0101b08:	85 c0                	test   %eax,%eax
f0101b0a:	75 12                	jne    f0101b1e <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0101b0c:	83 ec 0c             	sub    $0xc,%esp
f0101b0f:	68 70 04 11 f0       	push   $0xf0110470
f0101b14:	e8 42 45 00 00       	call   f010605b <cprintf>
f0101b19:	83 c4 10             	add    $0x10,%esp
f0101b1c:	eb 1d                	jmp    f0101b3b <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0101b1e:	83 ec 0c             	sub    $0xc,%esp
f0101b21:	6a 00                	push   $0x0
f0101b23:	e8 bd 5a 00 00       	call   f01075e5 <enableModifiedBuffer>
f0101b28:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0101b2b:	83 ec 0c             	sub    $0xc,%esp
f0101b2e:	68 ac 04 11 f0       	push   $0xf01104ac
f0101b33:	e8 23 45 00 00       	call   f010605b <cprintf>
f0101b38:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0101b3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101b40:	c9                   	leave  
f0101b41:	c3                   	ret    

f0101b42 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0101b42:	55                   	push   %ebp
f0101b43:	89 e5                	mov    %esp,%ebp
f0101b45:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0101b48:	e8 be 5a 00 00       	call   f010760b <isBufferingEnabled>
f0101b4d:	85 c0                	test   %eax,%eax
f0101b4f:	75 12                	jne    f0101b63 <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0101b51:	83 ec 0c             	sub    $0xc,%esp
f0101b54:	68 70 04 11 f0       	push   $0xf0110470
f0101b59:	e8 fd 44 00 00       	call   f010605b <cprintf>
f0101b5e:	83 c4 10             	add    $0x10,%esp
f0101b61:	eb 1d                	jmp    f0101b80 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0101b63:	83 ec 0c             	sub    $0xc,%esp
f0101b66:	6a 01                	push   $0x1
f0101b68:	e8 78 5a 00 00       	call   f01075e5 <enableModifiedBuffer>
f0101b6d:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0101b70:	83 ec 0c             	sub    $0xc,%esp
f0101b73:	68 d0 04 11 f0       	push   $0xf01104d0
f0101b78:	e8 de 44 00 00       	call   f010605b <cprintf>
f0101b7d:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0101b80:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101b85:	c9                   	leave  
f0101b86:	c3                   	ret    

f0101b87 <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0101b87:	55                   	push   %ebp
f0101b88:	89 e5                	mov    %esp,%ebp
f0101b8a:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0101b8d:	83 ec 0c             	sub    $0xc,%esp
f0101b90:	6a 00                	push   $0x0
f0101b92:	e8 66 5a 00 00       	call   f01075fd <enableBuffering>
f0101b97:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0101b9a:	83 ec 0c             	sub    $0xc,%esp
f0101b9d:	6a 00                	push   $0x0
f0101b9f:	e8 41 5a 00 00       	call   f01075e5 <enableModifiedBuffer>
f0101ba4:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0101ba7:	83 ec 0c             	sub    $0xc,%esp
f0101baa:	68 f0 04 11 f0       	push   $0xf01104f0
f0101baf:	e8 a7 44 00 00       	call   f010605b <cprintf>
f0101bb4:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101bb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101bbc:	c9                   	leave  
f0101bbd:	c3                   	ret    

f0101bbe <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0101bbe:	55                   	push   %ebp
f0101bbf:	89 e5                	mov    %esp,%ebp
f0101bc1:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0101bc4:	83 ec 0c             	sub    $0xc,%esp
f0101bc7:	6a 01                	push   $0x1
f0101bc9:	e8 2f 5a 00 00       	call   f01075fd <enableBuffering>
f0101bce:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0101bd1:	83 ec 0c             	sub    $0xc,%esp
f0101bd4:	6a 01                	push   $0x1
f0101bd6:	e8 0a 5a 00 00       	call   f01075e5 <enableModifiedBuffer>
f0101bdb:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0101bde:	e8 40 5a 00 00       	call   f0107623 <getModifiedBufferLength>
f0101be3:	85 c0                	test   %eax,%eax
f0101be5:	75 59                	jne    f0101c40 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0101be7:	83 ec 0c             	sub    $0xc,%esp
f0101bea:	68 0c 05 11 f0       	push   $0xf011050c
f0101bef:	e8 67 44 00 00       	call   f010605b <cprintf>
f0101bf4:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0101bf7:	83 ec 08             	sub    $0x8,%esp
f0101bfa:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0101bfd:	50                   	push   %eax
f0101bfe:	68 3c 05 11 f0       	push   $0xf011053c
f0101c03:	e8 a2 cc 00 00       	call   f010e8aa <readline>
f0101c08:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0101c0b:	83 ec 04             	sub    $0x4,%esp
f0101c0e:	6a 0a                	push   $0xa
f0101c10:	6a 00                	push   $0x0
f0101c12:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0101c15:	50                   	push   %eax
f0101c16:	e8 f5 d1 00 00       	call   f010ee10 <strtol>
f0101c1b:	83 c4 10             	add    $0x10,%esp
f0101c1e:	83 ec 0c             	sub    $0xc,%esp
f0101c21:	50                   	push   %eax
f0101c22:	e8 ee 59 00 00       	call   f0107615 <setModifiedBufferLength>
f0101c27:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0101c2a:	e8 f4 59 00 00       	call   f0107623 <getModifiedBufferLength>
f0101c2f:	83 ec 08             	sub    $0x8,%esp
f0101c32:	50                   	push   %eax
f0101c33:	68 68 05 11 f0       	push   $0xf0110568
f0101c38:	e8 1e 44 00 00       	call   f010605b <cprintf>
f0101c3d:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0101c40:	83 ec 0c             	sub    $0xc,%esp
f0101c43:	68 8d 05 11 f0       	push   $0xf011058d
f0101c48:	e8 0e 44 00 00       	call   f010605b <cprintf>
f0101c4d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101c50:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101c55:	c9                   	leave  
f0101c56:	c3                   	ret    

f0101c57 <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0101c57:	55                   	push   %ebp
f0101c58:	89 e5                	mov    %esp,%ebp
f0101c5a:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0101c5d:	e8 a9 59 00 00       	call   f010760b <isBufferingEnabled>
f0101c62:	85 c0                	test   %eax,%eax
f0101c64:	75 12                	jne    f0101c78 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0101c66:	83 ec 0c             	sub    $0xc,%esp
f0101c69:	68 a8 05 11 f0       	push   $0xf01105a8
f0101c6e:	e8 e8 43 00 00       	call   f010605b <cprintf>
f0101c73:	83 c4 10             	add    $0x10,%esp
f0101c76:	eb 19                	jmp    f0101c91 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0101c78:	e8 76 59 00 00       	call   f01075f3 <isModifiedBufferEnabled>
f0101c7d:	85 c0                	test   %eax,%eax
f0101c7f:	75 10                	jne    f0101c91 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0101c81:	83 ec 0c             	sub    $0xc,%esp
f0101c84:	68 f8 05 11 f0       	push   $0xf01105f8
f0101c89:	e8 cd 43 00 00       	call   f010605b <cprintf>
f0101c8e:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0101c91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101c94:	83 c0 04             	add    $0x4,%eax
f0101c97:	8b 00                	mov    (%eax),%eax
f0101c99:	83 ec 04             	sub    $0x4,%esp
f0101c9c:	6a 0a                	push   $0xa
f0101c9e:	6a 00                	push   $0x0
f0101ca0:	50                   	push   %eax
f0101ca1:	e8 6a d1 00 00       	call   f010ee10 <strtol>
f0101ca6:	83 c4 10             	add    $0x10,%esp
f0101ca9:	83 ec 0c             	sub    $0xc,%esp
f0101cac:	50                   	push   %eax
f0101cad:	e8 63 59 00 00       	call   f0107615 <setModifiedBufferLength>
f0101cb2:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0101cb5:	e8 69 59 00 00       	call   f0107623 <getModifiedBufferLength>
f0101cba:	83 ec 08             	sub    $0x8,%esp
f0101cbd:	50                   	push   %eax
f0101cbe:	68 68 05 11 f0       	push   $0xf0110568
f0101cc3:	e8 93 43 00 00       	call   f010605b <cprintf>
f0101cc8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101ccb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101cd0:	c9                   	leave  
f0101cd1:	c3                   	ret    

f0101cd2 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0101cd2:	55                   	push   %ebp
f0101cd3:	89 e5                	mov    %esp,%ebp
f0101cd5:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0101cd8:	e8 2e 59 00 00       	call   f010760b <isBufferingEnabled>
f0101cdd:	85 c0                	test   %eax,%eax
f0101cdf:	75 12                	jne    f0101cf3 <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0101ce1:	83 ec 0c             	sub    $0xc,%esp
f0101ce4:	68 a8 05 11 f0       	push   $0xf01105a8
f0101ce9:	e8 6d 43 00 00       	call   f010605b <cprintf>
f0101cee:	83 c4 10             	add    $0x10,%esp
f0101cf1:	eb 19                	jmp    f0101d0c <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0101cf3:	e8 fb 58 00 00       	call   f01075f3 <isModifiedBufferEnabled>
f0101cf8:	85 c0                	test   %eax,%eax
f0101cfa:	75 10                	jne    f0101d0c <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0101cfc:	83 ec 0c             	sub    $0xc,%esp
f0101cff:	68 f8 05 11 f0       	push   $0xf01105f8
f0101d04:	e8 52 43 00 00       	call   f010605b <cprintf>
f0101d09:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0101d0c:	e8 12 59 00 00       	call   f0107623 <getModifiedBufferLength>
f0101d11:	83 ec 08             	sub    $0x8,%esp
f0101d14:	50                   	push   %eax
f0101d15:	68 3e 06 11 f0       	push   $0xf011063e
f0101d1a:	e8 3c 43 00 00       	call   f010605b <cprintf>
f0101d1f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0101d22:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101d27:	c9                   	leave  
f0101d28:	c3                   	ret    

f0101d29 <command_test_kmalloc>:

int command_test_kmalloc(int number_of_arguments, char **arguments)
{
f0101d29:	55                   	push   %ebp
f0101d2a:	89 e5                	mov    %esp,%ebp
f0101d2c:	83 ec 08             	sub    $0x8,%esp
	test_kmalloc();
f0101d2f:	e8 da 94 00 00       	call   f010b20e <test_kmalloc>
	return 0;
f0101d34:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101d39:	c9                   	leave  
f0101d3a:	c3                   	ret    

f0101d3b <command_test_kfree>:
int command_test_kfree(int number_of_arguments, char **arguments)
{
f0101d3b:	55                   	push   %ebp
f0101d3c:	89 e5                	mov    %esp,%ebp
f0101d3e:	83 ec 08             	sub    $0x8,%esp
	test_kfree();
f0101d41:	e8 fd 9e 00 00       	call   f010bc43 <test_kfree>
	return 0;
f0101d46:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101d4b:	c9                   	leave  
f0101d4c:	c3                   	ret    

f0101d4d <command_test_kheap_phys_addr>:
int command_test_kheap_phys_addr(int number_of_arguments, char **arguments)
{
f0101d4d:	55                   	push   %ebp
f0101d4e:	89 e5                	mov    %esp,%ebp
f0101d50:	83 ec 08             	sub    $0x8,%esp
	test_kheap_phys_addr();
f0101d53:	e8 46 b0 00 00       	call   f010cd9e <test_kheap_phys_addr>
	return 0;
f0101d58:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101d5d:	c9                   	leave  
f0101d5e:	c3                   	ret    

f0101d5f <command_test_kheap_virt_addr>:
int command_test_kheap_virt_addr(int number_of_arguments, char **arguments)
{
f0101d5f:	55                   	push   %ebp
f0101d60:	89 e5                	mov    %esp,%ebp
f0101d62:	83 ec 08             	sub    $0x8,%esp
	test_kheap_virt_addr();
f0101d65:	e8 16 ba 00 00       	call   f010d780 <test_kheap_virt_addr>
	return 0;
f0101d6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101d6f:	c9                   	leave  
f0101d70:	c3                   	ret    

f0101d71 <command_test_three_creation_functions>:
int command_test_three_creation_functions(int number_of_arguments, char **arguments)
{
f0101d71:	55                   	push   %ebp
f0101d72:	89 e5                	mov    %esp,%ebp
f0101d74:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f0101d77:	e8 4e c3 00 00       	call   f010e0ca <test_three_creation_functions>
	return 0;
f0101d7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101d81:	c9                   	leave  
f0101d82:	c3                   	ret    

f0101d83 <nvram_read>:
{
		sizeof(gdt) - 1, (unsigned long) gdt
};

int nvram_read(int r)
{
f0101d83:	55                   	push   %ebp
f0101d84:	89 e5                	mov    %esp,%ebp
f0101d86:	53                   	push   %ebx
f0101d87:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0101d8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0101d8d:	83 ec 0c             	sub    $0xc,%esp
f0101d90:	50                   	push   %eax
f0101d91:	e8 b1 3e 00 00       	call   f0105c47 <mc146818_read>
f0101d96:	83 c4 10             	add    $0x10,%esp
f0101d99:	89 c3                	mov    %eax,%ebx
f0101d9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0101d9e:	40                   	inc    %eax
f0101d9f:	83 ec 0c             	sub    $0xc,%esp
f0101da2:	50                   	push   %eax
f0101da3:	e8 9f 3e 00 00       	call   f0105c47 <mc146818_read>
f0101da8:	83 c4 10             	add    $0x10,%esp
f0101dab:	c1 e0 08             	shl    $0x8,%eax
f0101dae:	09 d8                	or     %ebx,%eax
}
f0101db0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0101db3:	c9                   	leave  
f0101db4:	c3                   	ret    

f0101db5 <detect_memory>:

void detect_memory()
{
f0101db5:	55                   	push   %ebp
f0101db6:	89 e5                	mov    %esp,%ebp
f0101db8:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0101dbb:	83 ec 0c             	sub    $0xc,%esp
f0101dbe:	6a 15                	push   $0x15
f0101dc0:	e8 be ff ff ff       	call   f0101d83 <nvram_read>
f0101dc5:	83 c4 10             	add    $0x10,%esp
f0101dc8:	c1 e0 0a             	shl    $0xa,%eax
f0101dcb:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0101dce:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101dd1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0101dd6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0101dd9:	83 ec 0c             	sub    $0xc,%esp
f0101ddc:	6a 17                	push   $0x17
f0101dde:	e8 a0 ff ff ff       	call   f0101d83 <nvram_read>
f0101de3:	83 c4 10             	add    $0x10,%esp
f0101de6:	c1 e0 0a             	shl    $0xa,%eax
f0101de9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0101dec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101def:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0101df4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0101df7:	83 ec 0c             	sub    $0xc,%esp
f0101dfa:	6a 34                	push   $0x34
f0101dfc:	e8 82 ff ff ff       	call   f0101d83 <nvram_read>
f0101e01:	83 c4 10             	add    $0x10,%esp
f0101e04:	c1 e0 10             	shl    $0x10,%eax
f0101e07:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e0a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101e0d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0101e12:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0101e15:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101e19:	74 18                	je     f0101e33 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0101e1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101e1e:	05 00 00 00 01       	add    $0x1000000,%eax
f0101e23:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0101e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e29:	2d 00 00 10 00       	sub    $0x100000,%eax
f0101e2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101e31:	eb 19                	jmp    f0101e4c <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0101e33:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0101e37:	74 0d                	je     f0101e46 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0101e39:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e3c:	05 00 00 10 00       	add    $0x100000,%eax
f0101e41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101e44:	eb 06                	jmp    f0101e4c <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0101e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e49:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0101e4c:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0101e53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e56:	c1 e8 0c             	shr    $0xc,%eax
f0101e59:	a3 28 2a 45 f0       	mov    %eax,0xf0452a28

	cprintf("Physical memory: %dK available, ", (int)(maxpa/1024));
f0101e5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e61:	c1 e8 0a             	shr    $0xa,%eax
f0101e64:	83 ec 08             	sub    $0x8,%esp
f0101e67:	50                   	push   %eax
f0101e68:	68 5c 06 11 f0       	push   $0xf011065c
f0101e6d:	e8 e9 41 00 00       	call   f010605b <cprintf>
f0101e72:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0101e75:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e78:	c1 e8 0a             	shr    $0xa,%eax
f0101e7b:	89 c2                	mov    %eax,%edx
f0101e7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e80:	c1 e8 0a             	shr    $0xa,%eax
f0101e83:	83 ec 04             	sub    $0x4,%esp
f0101e86:	52                   	push   %edx
f0101e87:	50                   	push   %eax
f0101e88:	68 7d 06 11 f0       	push   $0xf011067d
f0101e8d:	e8 c9 41 00 00       	call   f010605b <cprintf>
f0101e92:	83 c4 10             	add    $0x10,%esp
}
f0101e95:	90                   	nop
f0101e96:	c9                   	leave  
f0101e97:	c3                   	ret    

f0101e98 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f0101e98:	55                   	push   %ebp
f0101e99:	89 e5                	mov    %esp,%ebp
f0101e9b:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
	if(USE_KHEAP)
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0101e9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101ea5:	eb 40                	jmp    f0101ee7 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f0101ea7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101eaa:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0101eb0:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0101eb5:	83 ec 08             	sub    $0x8,%esp
f0101eb8:	52                   	push   %edx
f0101eb9:	50                   	push   %eax
f0101eba:	e8 9b 01 00 00       	call   f010205a <check_va2pa>
f0101ebf:	83 c4 10             	add    $0x10,%esp
f0101ec2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0101ec5:	74 19                	je     f0101ee0 <check_boot_pgdir+0x48>
f0101ec7:	68 9c 06 11 f0       	push   $0xf011069c
f0101ecc:	68 d2 06 11 f0       	push   $0xf01106d2
f0101ed1:	68 86 00 00 00       	push   $0x86
f0101ed6:	68 e7 06 11 f0       	push   $0xf01106e7
f0101edb:	e8 7c e2 ff ff       	call   f010015c <_panic>

	//2016
	// check phys mem
	if(USE_KHEAP)
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0101ee0:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0101ee7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101eea:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0101ef0:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f0101ef5:	39 c2                	cmp    %eax,%edx
f0101ef7:	72 ae                	jb     f0101ea7 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}

	// check kernel stack
	for (i = 0; i < KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0101ef9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101f00:	eb 74                	jmp    f0101f76 <check_boot_pgdir+0xde>
		assert(check_va2pa(ptr_page_directory, KERNEL_STACK_TOP - KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f0101f02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101f05:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f0101f0b:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0101f10:	83 ec 08             	sub    $0x8,%esp
f0101f13:	52                   	push   %edx
f0101f14:	50                   	push   %eax
f0101f15:	e8 40 01 00 00       	call   f010205a <check_va2pa>
f0101f1a:	83 c4 10             	add    $0x10,%esp
f0101f1d:	c7 45 f0 00 20 13 f0 	movl   $0xf0132000,-0x10(%ebp)
f0101f24:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f0101f2b:	77 17                	ja     f0101f44 <check_boot_pgdir+0xac>
f0101f2d:	ff 75 f0             	pushl  -0x10(%ebp)
f0101f30:	68 f8 06 11 f0       	push   $0xf01106f8
f0101f35:	68 90 00 00 00       	push   $0x90
f0101f3a:	68 e7 06 11 f0       	push   $0xf01106e7
f0101f3f:	e8 18 e2 ff ff       	call   f010015c <_panic>
f0101f44:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101f47:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f0101f4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101f50:	01 ca                	add    %ecx,%edx
f0101f52:	39 d0                	cmp    %edx,%eax
f0101f54:	74 19                	je     f0101f6f <check_boot_pgdir+0xd7>
f0101f56:	68 2c 07 11 f0       	push   $0xf011072c
f0101f5b:	68 d2 06 11 f0       	push   $0xf01106d2
f0101f60:	68 90 00 00 00       	push   $0x90
f0101f65:	68 e7 06 11 f0       	push   $0xf01106e7
f0101f6a:	e8 ed e1 ff ff       	call   f010015c <_panic>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}

	// check kernel stack
	for (i = 0; i < KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0101f6f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0101f76:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f0101f7d:	76 83                	jbe    f0101f02 <check_boot_pgdir+0x6a>
		assert(check_va2pa(ptr_page_directory, KERNEL_STACK_TOP - KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);

	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0101f7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101f86:	e9 af 00 00 00       	jmp    f010203a <check_boot_pgdir+0x1a2>
		switch (i) {
f0101f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101f8e:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f0101f93:	74 11                	je     f0101fa6 <check_boot_pgdir+0x10e>
f0101f95:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f0101f9a:	72 36                	jb     f0101fd2 <check_boot_pgdir+0x13a>
f0101f9c:	2d bd 03 00 00       	sub    $0x3bd,%eax
f0101fa1:	83 f8 02             	cmp    $0x2,%eax
f0101fa4:	77 2c                	ja     f0101fd2 <check_boot_pgdir+0x13a>
		case PDX(UVPT):
		case PDX(KERNEL_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f0101fa6:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0101fab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101fae:	c1 e2 02             	shl    $0x2,%edx
f0101fb1:	01 d0                	add    %edx,%eax
f0101fb3:	8b 00                	mov    (%eax),%eax
f0101fb5:	85 c0                	test   %eax,%eax
f0101fb7:	75 7a                	jne    f0102033 <check_boot_pgdir+0x19b>
f0101fb9:	68 ae 07 11 f0       	push   $0xf01107ae
f0101fbe:	68 d2 06 11 f0       	push   $0xf01106d2
f0101fc3:	68 9b 00 00 00       	push   $0x9b
f0101fc8:	68 e7 06 11 f0       	push   $0xf01106e7
f0101fcd:	e8 8a e1 ff ff       	call   f010015c <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f0101fd2:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f0101fd9:	76 2c                	jbe    f0102007 <check_boot_pgdir+0x16f>
				assert(ptr_page_directory[i]);
f0101fdb:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0101fe0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101fe3:	c1 e2 02             	shl    $0x2,%edx
f0101fe6:	01 d0                	add    %edx,%eax
f0101fe8:	8b 00                	mov    (%eax),%eax
f0101fea:	85 c0                	test   %eax,%eax
f0101fec:	75 48                	jne    f0102036 <check_boot_pgdir+0x19e>
f0101fee:	68 ae 07 11 f0       	push   $0xf01107ae
f0101ff3:	68 d2 06 11 f0       	push   $0xf01106d2
f0101ff8:	68 9f 00 00 00       	push   $0x9f
f0101ffd:	68 e7 06 11 f0       	push   $0xf01106e7
f0102002:	e8 55 e1 ff ff       	call   f010015c <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f0102007:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010200c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010200f:	c1 e2 02             	shl    $0x2,%edx
f0102012:	01 d0                	add    %edx,%eax
f0102014:	8b 00                	mov    (%eax),%eax
f0102016:	85 c0                	test   %eax,%eax
f0102018:	74 1c                	je     f0102036 <check_boot_pgdir+0x19e>
f010201a:	68 c4 07 11 f0       	push   $0xf01107c4
f010201f:	68 d2 06 11 f0       	push   $0xf01106d2
f0102024:	68 a1 00 00 00       	push   $0xa1
f0102029:	68 e7 06 11 f0       	push   $0xf01106e7
f010202e:	e8 29 e1 ff ff       	call   f010015c <_panic>
		case PDX(KERNEL_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f0102033:	90                   	nop
f0102034:	eb 01                	jmp    f0102037 <check_boot_pgdir+0x19f>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f0102036:	90                   	nop
	// check kernel stack
	for (i = 0; i < KERNEL_STACK_SIZE; i += PAGE_SIZE)
		assert(check_va2pa(ptr_page_directory, KERNEL_STACK_TOP - KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);

	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0102037:	ff 45 f4             	incl   -0xc(%ebp)
f010203a:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0102041:	0f 86 44 ff ff ff    	jbe    f0101f8b <check_boot_pgdir+0xf3>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("check_boot_pgdir() succeeded!\n");
f0102047:	83 ec 0c             	sub    $0xc,%esp
f010204a:	68 e0 07 11 f0       	push   $0xf01107e0
f010204f:	e8 07 40 00 00       	call   f010605b <cprintf>
f0102054:	83 c4 10             	add    $0x10,%esp
}
f0102057:	90                   	nop
f0102058:	c9                   	leave  
f0102059:	c3                   	ret    

f010205a <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f010205a:	55                   	push   %ebp
f010205b:	89 e5                	mov    %esp,%ebp
f010205d:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f0102060:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102063:	c1 e8 16             	shr    $0x16,%eax
f0102066:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010206d:	8b 45 08             	mov    0x8(%ebp),%eax
f0102070:	01 d0                	add    %edx,%eax
f0102072:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f0102075:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102078:	8b 00                	mov    (%eax),%eax
f010207a:	83 e0 01             	and    $0x1,%eax
f010207d:	85 c0                	test   %eax,%eax
f010207f:	75 0a                	jne    f010208b <check_va2pa+0x31>
		return ~0;
f0102081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0102086:	e9 87 00 00 00       	jmp    f0102112 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f010208b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010208e:	8b 00                	mov    (%eax),%eax
f0102090:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102095:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102098:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010209b:	c1 e8 0c             	shr    $0xc,%eax
f010209e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01020a1:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f01020a6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01020a9:	72 17                	jb     f01020c2 <check_va2pa+0x68>
f01020ab:	ff 75 f0             	pushl  -0x10(%ebp)
f01020ae:	68 00 08 11 f0       	push   $0xf0110800
f01020b3:	68 b7 00 00 00       	push   $0xb7
f01020b8:	68 e7 06 11 f0       	push   $0xf01106e7
f01020bd:	e8 9a e0 ff ff       	call   f010015c <_panic>
f01020c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020c5:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01020ca:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f01020cd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01020d0:	c1 e8 0c             	shr    $0xc,%eax
f01020d3:	25 ff 03 00 00       	and    $0x3ff,%eax
f01020d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01020df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e2:	01 d0                	add    %edx,%eax
f01020e4:	8b 00                	mov    (%eax),%eax
f01020e6:	83 e0 01             	and    $0x1,%eax
f01020e9:	85 c0                	test   %eax,%eax
f01020eb:	75 07                	jne    f01020f4 <check_va2pa+0x9a>
		return ~0;
f01020ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01020f2:	eb 1e                	jmp    f0102112 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f01020f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01020f7:	c1 e8 0c             	shr    $0xc,%eax
f01020fa:	25 ff 03 00 00       	and    $0x3ff,%eax
f01020ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102106:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102109:	01 d0                	add    %edx,%eax
f010210b:	8b 00                	mov    (%eax),%eax
f010210d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0102112:	c9                   	leave  
f0102113:	c3                   	ret    

f0102114 <tlb_invalidate>:

void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0102114:	55                   	push   %ebp
f0102115:	89 e5                	mov    %esp,%ebp
f0102117:	83 ec 10             	sub    $0x10,%esp
f010211a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010211d:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void 
invlpg(void *addr)
{ 
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0102120:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0102123:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0102126:	90                   	nop
f0102127:	c9                   	leave  
f0102128:	c3                   	ret    

f0102129 <turn_on_paging>:
	cprintf("page_check() succeeded!\n");
}
*/

void turn_on_paging()
{
f0102129:	55                   	push   %ebp
f010212a:	89 e5                	mov    %esp,%ebp
f010212c:	83 ec 30             	sub    $0x30,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f010212f:	c7 45 fc c0 03 00 00 	movl   $0x3c0,-0x4(%ebp)
		int j = 0;
f0102136:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f010213d:	eb 24                	jmp    f0102163 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f010213f:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102144:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0102147:	c1 e2 02             	shl    $0x2,%edx
f010214a:	01 c2                	add    %eax,%edx
f010214c:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102151:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0102154:	c1 e1 02             	shl    $0x2,%ecx
f0102157:	01 c8                	add    %ecx,%eax
f0102159:	8b 00                	mov    (%eax),%eax
f010215b:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f010215d:	ff 45 fc             	incl   -0x4(%ebp)
f0102160:	ff 45 f8             	incl   -0x8(%ebp)
f0102163:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f0102168:	c1 e8 16             	shr    $0x16,%eax
f010216b:	89 c2                	mov    %eax,%edx
f010216d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0102170:	39 c2                	cmp    %eax,%edx
f0102172:	77 cb                	ja     f010213f <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0102174:	a1 98 52 45 f0       	mov    0xf0455298,%eax
f0102179:	89 45 e8             	mov    %eax,-0x18(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010217c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010217f:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0102182:	0f 20 c0             	mov    %cr0,%eax
f0102185:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return val;
f0102188:	8b 45 e0             	mov    -0x20(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f010218b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f010218e:	81 4d e4 2f 00 05 80 	orl    $0x8005002f,-0x1c(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0102195:	83 65 e4 f3          	andl   $0xfffffff3,-0x1c(%ebp)
f0102199:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010219c:	89 45 dc             	mov    %eax,-0x24(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f010219f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01021a2:	0f 22 c0             	mov    %eax,%cr0

	// Current mapping: KERNEL_BASE+x => x => x.
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	asm volatile("lgdt gdt_pd");
f01021a5:	0f 01 15 30 a7 13 f0 	lgdtl  0xf013a730
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f01021ac:	b8 23 00 00 00       	mov    $0x23,%eax
f01021b1:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f01021b3:	b8 23 00 00 00       	mov    $0x23,%eax
f01021b8:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f01021ba:	b8 10 00 00 00       	mov    $0x10,%eax
f01021bf:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f01021c1:	b8 10 00 00 00       	mov    $0x10,%eax
f01021c6:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f01021c8:	b8 10 00 00 00       	mov    $0x10,%eax
f01021cd:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f01021cf:	ea d6 21 10 f0 08 00 	ljmp   $0x8,$0xf01021d6
	asm volatile("lldt %%ax" :: "a" (0));
f01021d6:	b8 00 00 00 00       	mov    $0x0,%eax
f01021db:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f01021de:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f01021e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01021ec:	eb 19                	jmp    f0102207 <turn_on_paging+0xde>
		{
			ptr_page_directory[j] = 0;
f01021ee:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f01021f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01021f6:	c1 e2 02             	shl    $0x2,%edx
f01021f9:	01 d0                	add    %edx,%eax
f01021fb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0102201:	ff 45 f4             	incl   -0xc(%ebp)
f0102204:	ff 45 f0             	incl   -0x10(%ebp)
f0102207:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f010220c:	c1 e8 16             	shr    $0x16,%eax
f010220f:	89 c2                	mov    %eax,%edx
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	39 c2                	cmp    %eax,%edx
f0102216:	77 d6                	ja     f01021ee <turn_on_paging+0xc5>
		{
			ptr_page_directory[j] = 0;
		}
	}
	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0102218:	a1 98 52 45 f0       	mov    0xf0455298,%eax
f010221d:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102220:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102223:	0f 22 d8             	mov    %eax,%cr3
}
f0102226:	90                   	nop
f0102227:	c9                   	leave  
f0102228:	c3                   	ret    

f0102229 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0102229:	55                   	push   %ebp
f010222a:	89 e5                	mov    %esp,%ebp
f010222c:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f010222f:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102234:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0102237:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f010223e:	77 17                	ja     f0102257 <setup_listing_to_all_page_tables_entries+0x2e>
f0102240:	ff 75 f4             	pushl  -0xc(%ebp)
f0102243:	68 f8 06 11 f0       	push   $0xf01106f8
f0102248:	68 86 01 00 00       	push   $0x186
f010224d:	68 e7 06 11 f0       	push   $0xf01106e7
f0102252:	e8 05 df ff ff       	call   f010015c <_panic>
f0102257:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010225a:	05 00 00 00 10       	add    $0x10000000,%eax
f010225f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0102262:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102267:	05 fc 0e 00 00       	add    $0xefc,%eax
f010226c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010226f:	83 ca 03             	or     $0x3,%edx
f0102272:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0102274:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102279:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010227f:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102284:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102287:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f010228e:	77 17                	ja     f01022a7 <setup_listing_to_all_page_tables_entries+0x7e>
f0102290:	ff 75 ec             	pushl  -0x14(%ebp)
f0102293:	68 f8 06 11 f0       	push   $0xf01106f8
f0102298:	68 8b 01 00 00       	push   $0x18b
f010229d:	68 e7 06 11 f0       	push   $0xf01106e7
f01022a2:	e8 b5 de ff ff       	call   f010015c <_panic>
f01022a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01022aa:	05 00 00 00 10       	add    $0x10000000,%eax
f01022af:	83 c8 05             	or     $0x5,%eax
f01022b2:	89 02                	mov    %eax,(%edx)

}
f01022b4:	90                   	nop
f01022b5:	c9                   	leave  
f01022b6:	c3                   	ret    

f01022b7 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f01022b7:	55                   	push   %ebp
f01022b8:	89 e5                	mov    %esp,%ebp
f01022ba:	83 ec 10             	sub    $0x10,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f01022bd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01022c1:	75 15                	jne    f01022d8 <envid2env+0x21>
		*env_store = curenv;
f01022c3:	8b 15 38 a1 42 f0    	mov    0xf042a138,%edx
f01022c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022cc:	89 10                	mov    %edx,(%eax)
		return 0;
f01022ce:	b8 00 00 00 00       	mov    $0x0,%eax
f01022d3:	e9 90 00 00 00       	jmp    f0102368 <envid2env+0xb1>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f01022d8:	8b 0d 34 a1 42 f0    	mov    0xf042a134,%ecx
f01022de:	8b 45 08             	mov    0x8(%ebp),%eax
f01022e1:	25 62 05 00 00       	and    $0x562,%eax
f01022e6:	89 c2                	mov    %eax,%edx
f01022e8:	89 d0                	mov    %edx,%eax
f01022ea:	c1 e0 03             	shl    $0x3,%eax
f01022ed:	01 d0                	add    %edx,%eax
f01022ef:	01 c0                	add    %eax,%eax
f01022f1:	01 d0                	add    %edx,%eax
f01022f3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01022fa:	01 d0                	add    %edx,%eax
f01022fc:	c1 e0 03             	shl    $0x3,%eax
f01022ff:	01 c8                	add    %ecx,%eax
f0102301:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f0102304:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0102307:	8b 40 54             	mov    0x54(%eax),%eax
f010230a:	85 c0                	test   %eax,%eax
f010230c:	74 0b                	je     f0102319 <envid2env+0x62>
f010230e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0102311:	8b 40 4c             	mov    0x4c(%eax),%eax
f0102314:	3b 45 08             	cmp    0x8(%ebp),%eax
f0102317:	74 10                	je     f0102329 <envid2env+0x72>
		*env_store = 0;
f0102319:	8b 45 0c             	mov    0xc(%ebp),%eax
f010231c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f0102322:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0102327:	eb 3f                	jmp    f0102368 <envid2env+0xb1>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
f0102329:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010232d:	74 2c                	je     f010235b <envid2env+0xa4>
f010232f:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0102334:	39 45 fc             	cmp    %eax,-0x4(%ebp)
f0102337:	74 22                	je     f010235b <envid2env+0xa4>
f0102339:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010233c:	8b 50 50             	mov    0x50(%eax),%edx
f010233f:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0102344:	8b 40 4c             	mov    0x4c(%eax),%eax
f0102347:	39 c2                	cmp    %eax,%edx
f0102349:	74 10                	je     f010235b <envid2env+0xa4>
		*env_store = 0;
f010234b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010234e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f0102354:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0102359:	eb 0d                	jmp    f0102368 <envid2env+0xb1>
	}

	*env_store = e;
f010235b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010235e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0102361:	89 10                	mov    %edx,(%eax)
	return 0;
f0102363:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102368:	c9                   	leave  
f0102369:	c3                   	ret    

f010236a <to_frame_number>:
struct Frame_Info *get_frame_info(uint32 *ptr_page_directory, void *virtual_address, uint32 **ptr_page_table);
void decrement_references(struct Frame_Info* ptr_frame_info);
void initialize_frame_info(struct Frame_Info *ptr_frame_info);

static inline uint32 to_frame_number(struct Frame_Info *ptr_frame_info)
{
f010236a:	55                   	push   %ebp
f010236b:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010236d:	8b 45 08             	mov    0x8(%ebp),%eax
f0102370:	8b 15 84 52 45 f0    	mov    0xf0455284,%edx
f0102376:	29 d0                	sub    %edx,%eax
f0102378:	c1 f8 03             	sar    $0x3,%eax
f010237b:	89 c2                	mov    %eax,%edx
f010237d:	89 d0                	mov    %edx,%eax
f010237f:	c1 e0 02             	shl    $0x2,%eax
f0102382:	01 d0                	add    %edx,%eax
f0102384:	c1 e0 02             	shl    $0x2,%eax
f0102387:	01 d0                	add    %edx,%eax
f0102389:	c1 e0 02             	shl    $0x2,%eax
f010238c:	01 d0                	add    %edx,%eax
f010238e:	89 c1                	mov    %eax,%ecx
f0102390:	c1 e1 08             	shl    $0x8,%ecx
f0102393:	01 c8                	add    %ecx,%eax
f0102395:	89 c1                	mov    %eax,%ecx
f0102397:	c1 e1 10             	shl    $0x10,%ecx
f010239a:	01 c8                	add    %ecx,%eax
f010239c:	01 c0                	add    %eax,%eax
f010239e:	01 d0                	add    %edx,%eax
}
f01023a0:	5d                   	pop    %ebp
f01023a1:	c3                   	ret    

f01023a2 <to_physical_address>:

static inline uint32 to_physical_address(struct Frame_Info *ptr_frame_info)
{
f01023a2:	55                   	push   %ebp
f01023a3:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f01023a5:	ff 75 08             	pushl  0x8(%ebp)
f01023a8:	e8 bd ff ff ff       	call   f010236a <to_frame_number>
f01023ad:	83 c4 04             	add    $0x4,%esp
f01023b0:	c1 e0 0c             	shl    $0xc,%eax
}
f01023b3:	c9                   	leave  
f01023b4:	c3                   	ret    

f01023b5 <to_frame_info>:

static inline struct Frame_Info* to_frame_info(uint32 physical_address)
{
f01023b5:	55                   	push   %ebp
f01023b6:	89 e5                	mov    %esp,%ebp
f01023b8:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f01023bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01023be:	c1 e8 0c             	shr    $0xc,%eax
f01023c1:	89 c2                	mov    %eax,%edx
f01023c3:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f01023c8:	39 c2                	cmp    %eax,%edx
f01023ca:	72 14                	jb     f01023e0 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f01023cc:	83 ec 04             	sub    $0x4,%esp
f01023cf:	68 30 08 11 f0       	push   $0xf0110830
f01023d4:	6a 60                	push   $0x60
f01023d6:	68 55 08 11 f0       	push   $0xf0110855
f01023db:	e8 7c dd ff ff       	call   f010015c <_panic>
	return &frames_info[PPN(physical_address)];
f01023e0:	8b 15 84 52 45 f0    	mov    0xf0455284,%edx
f01023e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01023e9:	c1 e8 0c             	shr    $0xc,%eax
f01023ec:	89 c1                	mov    %eax,%ecx
f01023ee:	89 c8                	mov    %ecx,%eax
f01023f0:	01 c0                	add    %eax,%eax
f01023f2:	01 c8                	add    %ecx,%eax
f01023f4:	c1 e0 03             	shl    $0x3,%eax
f01023f7:	01 d0                	add    %edx,%eax
}
f01023f9:	c9                   	leave  
f01023fa:	c3                   	ret    

f01023fb <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f01023fb:	55                   	push   %ebp
f01023fc:	89 e5                	mov    %esp,%ebp
f01023fe:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0102401:	83 ec 08             	sub    $0x8,%esp
f0102404:	68 00 10 00 00       	push   $0x1000
f0102409:	68 00 10 00 00       	push   $0x1000
f010240e:	e8 4f 02 00 00       	call   f0102662 <boot_allocate_space>
f0102413:	83 c4 10             	add    $0x10,%esp
f0102416:	a3 90 52 45 f0       	mov    %eax,0xf0455290
	memset(ptr_page_directory, 0, PAGE_SIZE);
f010241b:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102420:	83 ec 04             	sub    $0x4,%esp
f0102423:	68 00 10 00 00       	push   $0x1000
f0102428:	6a 00                	push   $0x0
f010242a:	50                   	push   %eax
f010242b:	e8 6e c8 00 00       	call   f010ec9e <memset>
f0102430:	83 c4 10             	add    $0x10,%esp
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0102433:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102438:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010243b:	81 7d e8 ff ff ff ef 	cmpl   $0xefffffff,-0x18(%ebp)
f0102442:	77 14                	ja     f0102458 <initialize_kernel_VM+0x5d>
f0102444:	ff 75 e8             	pushl  -0x18(%ebp)
f0102447:	68 70 08 11 f0       	push   $0xf0110870
f010244c:	6a 53                	push   $0x53
f010244e:	68 a1 08 11 f0       	push   $0xf01108a1
f0102453:	e8 04 dd ff ff       	call   f010015c <_panic>
f0102458:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010245b:	05 00 00 00 10       	add    $0x10000000,%eax
f0102460:	a3 98 52 45 f0       	mov    %eax,0xf0455298
	// Map the kernel stack with VA range :
	//  [KERNEL_STACK_TOP-KERNEL_STACK_SIZE, KERNEL_STACK_TOP),
	// to physical address : "phys_stack_bottom".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_range(ptr_page_directory, KERNEL_STACK_TOP - KERNEL_STACK_SIZE, KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f0102465:	c7 45 e4 00 20 13 f0 	movl   $0xf0132000,-0x1c(%ebp)
f010246c:	81 7d e4 ff ff ff ef 	cmpl   $0xefffffff,-0x1c(%ebp)
f0102473:	77 14                	ja     f0102489 <initialize_kernel_VM+0x8e>
f0102475:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102478:	68 70 08 11 f0       	push   $0xf0110870
f010247d:	6a 5b                	push   $0x5b
f010247f:	68 a1 08 11 f0       	push   $0xf01108a1
f0102484:	e8 d3 dc ff ff       	call   f010015c <_panic>
f0102489:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010248c:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0102492:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102497:	83 ec 0c             	sub    $0xc,%esp
f010249a:	6a 02                	push   $0x2
f010249c:	52                   	push   %edx
f010249d:	68 00 80 00 00       	push   $0x8000
f01024a2:	68 00 80 bf ef       	push   $0xefbf8000
f01024a7:	50                   	push   %eax
f01024a8:	e8 17 02 00 00       	call   f01026c4 <boot_map_range>
f01024ad:	83 c4 20             	add    $0x20,%esp
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01024b0:	c7 45 f0 00 00 00 f0 	movl   $0xf0000000,-0x10(%ebp)
f01024b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	unsigned int nTables=0;
f01024be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01024c5:	eb 25                	jmp    f01024ec <initialize_kernel_VM+0xf1>
	{
		++nTables;
f01024c7:	ff 45 ec             	incl   -0x14(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f01024ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01024cd:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f01024d2:	83 ec 04             	sub    $0x4,%esp
f01024d5:	6a 01                	push   $0x1
f01024d7:	52                   	push   %edx
f01024d8:	50                   	push   %eax
f01024d9:	e8 5a 02 00 00       	call   f0102738 <boot_get_page_table>
f01024de:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f01024e1:	81 45 f0 00 00 40 00 	addl   $0x400000,-0x10(%ebp)
f01024e8:	83 55 f4 00          	adcl   $0x0,-0xc(%ebp)
f01024ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01024f0:	72 d5                	jb     f01024c7 <initialize_kernel_VM+0xcc>
f01024f2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01024f6:	77 06                	ja     f01024fe <initialize_kernel_VM+0x103>
f01024f8:	83 7d f0 fe          	cmpl   $0xfffffffe,-0x10(%ebp)
f01024fc:	76 c9                	jbe    f01024c7 <initialize_kernel_VM+0xcc>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct Frame_Info) ;
f01024fe:	8b 15 28 2a 45 f0    	mov    0xf0452a28,%edx
f0102504:	89 d0                	mov    %edx,%eax
f0102506:	01 c0                	add    %eax,%eax
f0102508:	01 d0                	add    %edx,%eax
f010250a:	c1 e0 03             	shl    $0x3,%eax
f010250d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0102510:	83 ec 08             	sub    $0x8,%esp
f0102513:	68 00 10 00 00       	push   $0x1000
f0102518:	ff 75 e0             	pushl  -0x20(%ebp)
f010251b:	e8 42 01 00 00       	call   f0102662 <boot_allocate_space>
f0102520:	83 c4 10             	add    $0x10,%esp
f0102523:	a3 84 52 45 f0       	mov    %eax,0xf0455284
	memset(frames_info, 0, array_size);
f0102528:	a1 84 52 45 f0       	mov    0xf0455284,%eax
f010252d:	83 ec 04             	sub    $0x4,%esp
f0102530:	ff 75 e0             	pushl  -0x20(%ebp)
f0102533:	6a 00                	push   $0x0
f0102535:	50                   	push   %eax
f0102536:	e8 63 c7 00 00       	call   f010ec9e <memset>
f010253b:	83 c4 10             	add    $0x10,%esp
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct Frame_Info);
f010253e:	c7 45 dc 00 c0 30 00 	movl   $0x30c000,-0x24(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0102545:	83 ec 08             	sub    $0x8,%esp
f0102548:	68 00 10 00 00       	push   $0x1000
f010254d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102550:	e8 0d 01 00 00       	call   f0102662 <boot_allocate_space>
f0102555:	83 c4 10             	add    $0x10,%esp
f0102558:	a3 70 52 45 f0       	mov    %eax,0xf0455270
	memset(disk_frames_info , 0, disk_array_size);
f010255d:	a1 70 52 45 f0       	mov    0xf0455270,%eax
f0102562:	83 ec 04             	sub    $0x4,%esp
f0102565:	ff 75 dc             	pushl  -0x24(%ebp)
f0102568:	6a 00                	push   $0x0
f010256a:	50                   	push   %eax
f010256b:	e8 2e c7 00 00       	call   f010ec9e <memset>
f0102570:	83 c4 10             	add    $0x10,%esp

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0102573:	e8 b1 fc ff ff       	call   f0102229 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("Max Envs = %d\n",NENV);
f0102578:	83 ec 08             	sub    $0x8,%esp
f010257b:	68 63 05 00 00       	push   $0x563
f0102580:	68 b7 08 11 f0       	push   $0xf01108b7
f0102585:	e8 d1 3a 00 00       	call   f010605b <cprintf>
f010258a:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f010258d:	c7 45 d8 e8 fd 0f 00 	movl   $0xffde8,-0x28(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0102594:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102597:	83 ec 08             	sub    $0x8,%esp
f010259a:	68 00 10 00 00       	push   $0x1000
f010259f:	50                   	push   %eax
f01025a0:	e8 bd 00 00 00       	call   f0102662 <boot_allocate_space>
f01025a5:	83 c4 10             	add    $0x10,%esp
f01025a8:	a3 34 a1 42 f0       	mov    %eax,0xf042a134
	memset(envs , 0, envs_size);
f01025ad:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01025b0:	a1 34 a1 42 f0       	mov    0xf042a134,%eax
f01025b5:	83 ec 04             	sub    $0x4,%esp
f01025b8:	52                   	push   %edx
f01025b9:	6a 00                	push   $0x0
f01025bb:	50                   	push   %eax
f01025bc:	e8 dd c6 00 00       	call   f010ec9e <memset>
f01025c1:	83 c4 10             	add    $0x10,%esp

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01025c4:	a1 34 a1 42 f0       	mov    0xf042a134,%eax
f01025c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01025cc:	81 7d d4 ff ff ff ef 	cmpl   $0xefffffff,-0x2c(%ebp)
f01025d3:	77 17                	ja     f01025ec <initialize_kernel_VM+0x1f1>
f01025d5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01025d8:	68 70 08 11 f0       	push   $0xf0110870
f01025dd:	68 a4 00 00 00       	push   $0xa4
f01025e2:	68 a1 08 11 f0       	push   $0xf01108a1
f01025e7:	e8 70 db ff ff       	call   f010015c <_panic>
f01025ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01025ef:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01025f5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01025f8:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f01025fd:	83 ec 0c             	sub    $0xc,%esp
f0102600:	6a 04                	push   $0x4
f0102602:	51                   	push   %ecx
f0102603:	52                   	push   %edx
f0102604:	68 00 00 c0 ee       	push   $0xeec00000
f0102609:	50                   	push   %eax
f010260a:	e8 b5 00 00 00       	call   f01026c4 <boot_map_range>
f010260f:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0102612:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f0102617:	05 ec 0e 00 00       	add    $0xeec,%eax
f010261c:	8b 15 90 52 45 f0    	mov    0xf0455290,%edx
f0102622:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f0102628:	8b 12                	mov    (%edx),%edx
f010262a:	83 ca 05             	or     $0x5,%edx
f010262d:	89 10                	mov    %edx,(%eax)
	if(USE_KHEAP)
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f010262f:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f0102634:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f010263a:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010263f:	83 ec 0c             	sub    $0xc,%esp
f0102642:	6a 02                	push   $0x2
f0102644:	6a 00                	push   $0x0
f0102646:	52                   	push   %edx
f0102647:	68 00 00 00 f0       	push   $0xf0000000
f010264c:	50                   	push   %eax
f010264d:	e8 72 00 00 00       	call   f01026c4 <boot_map_range>
f0102652:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}

	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0102655:	e8 3e f8 ff ff       	call   f0101e98 <check_boot_pgdir>

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010265a:	e8 ca fa ff ff       	call   f0102129 <turn_on_paging>
}
f010265f:	90                   	nop
f0102660:	c9                   	leave  
f0102661:	c3                   	ret    

f0102662 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
																		{
f0102662:	55                   	push   %ebp
f0102663:	89 e5                	mov    %esp,%ebp
f0102665:	83 ec 10             	sub    $0x10,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0102668:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f010266d:	85 c0                	test   %eax,%eax
f010266f:	75 0a                	jne    f010267b <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0102671:	c7 05 8c 52 45 f0 c0 	movl   $0xf05167c0,0xf045528c
f0102678:	67 51 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, PAGE_SIZE) ;
f010267b:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%ebp)
f0102682:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f0102687:	89 c2                	mov    %eax,%edx
f0102689:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010268c:	01 d0                	add    %edx,%eax
f010268e:	48                   	dec    %eax
f010268f:	89 45 f8             	mov    %eax,-0x8(%ebp)
f0102692:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0102695:	ba 00 00 00 00       	mov    $0x0,%edx
f010269a:	f7 75 fc             	divl   -0x4(%ebp)
f010269d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01026a0:	29 d0                	sub    %edx,%eax
f01026a2:	a3 8c 52 45 f0       	mov    %eax,0xf045528c

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01026a7:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f01026ac:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01026af:	8b 15 8c 52 45 f0    	mov    0xf045528c,%edx
f01026b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01026b8:	01 d0                	add    %edx,%eax
f01026ba:	a3 8c 52 45 f0       	mov    %eax,0xf045528c

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01026bf:	8b 45 f4             	mov    -0xc(%ebp),%eax

																		}
f01026c2:	c9                   	leave  
f01026c3:	c3                   	ret    

f01026c4 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01026c4:	55                   	push   %ebp
f01026c5:	89 e5                	mov    %esp,%ebp
f01026c7:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01026ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01026d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026d8:	eb 53                	jmp    f010272d <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f01026da:	83 ec 04             	sub    $0x4,%esp
f01026dd:	6a 01                	push   $0x1
f01026df:	ff 75 0c             	pushl  0xc(%ebp)
f01026e2:	ff 75 08             	pushl  0x8(%ebp)
f01026e5:	e8 4e 00 00 00       	call   f0102738 <boot_get_page_table>
f01026ea:	83 c4 10             	add    $0x10,%esp
f01026ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f01026f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01026f3:	c1 e8 0c             	shr    $0xc,%eax
f01026f6:	25 ff 03 00 00       	and    $0x3ff,%eax
f01026fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f01026fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102701:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102708:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010270b:	01 c2                	add    %eax,%edx
f010270d:	8b 45 18             	mov    0x18(%ebp),%eax
f0102710:	0b 45 14             	or     0x14(%ebp),%eax
f0102713:	83 c8 01             	or     $0x1,%eax
f0102716:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0102718:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f010271f:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0102726:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010272d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102730:	3b 45 10             	cmp    0x10(%ebp),%eax
f0102733:	72 a5                	jb     f01026da <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0102735:	90                   	nop
f0102736:	c9                   	leave  
f0102737:	c3                   	ret    

f0102738 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0102738:	55                   	push   %ebp
f0102739:	89 e5                	mov    %esp,%ebp
f010273b:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f010273e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102741:	c1 e8 16             	shr    $0x16,%eax
f0102744:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f0102747:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010274a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102751:	8b 45 08             	mov    0x8(%ebp),%eax
f0102754:	01 d0                	add    %edx,%eax
f0102756:	8b 00                	mov    (%eax),%eax
f0102758:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010275b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010275e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102763:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0102766:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102769:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010276c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010276f:	c1 e8 0c             	shr    $0xc,%eax
f0102772:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102775:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f010277a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010277d:	72 17                	jb     f0102796 <boot_get_page_table+0x5e>
f010277f:	ff 75 e8             	pushl  -0x18(%ebp)
f0102782:	68 c8 08 11 f0       	push   $0xf01108c8
f0102787:	68 1e 01 00 00       	push   $0x11e
f010278c:	68 a1 08 11 f0       	push   $0xf01108a1
f0102791:	e8 c6 d9 ff ff       	call   f010015c <_panic>
f0102796:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102799:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010279e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01027a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01027a5:	75 72                	jne    f0102819 <boot_get_page_table+0xe1>
	{
		if (create)
f01027a7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01027ab:	74 65                	je     f0102812 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01027ad:	83 ec 08             	sub    $0x8,%esp
f01027b0:	68 00 10 00 00       	push   $0x1000
f01027b5:	68 00 10 00 00       	push   $0x1000
f01027ba:	e8 a3 fe ff ff       	call   f0102662 <boot_allocate_space>
f01027bf:	83 c4 10             	add    $0x10,%esp
f01027c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01027c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01027c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01027cb:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01027d2:	77 17                	ja     f01027eb <boot_get_page_table+0xb3>
f01027d4:	ff 75 dc             	pushl  -0x24(%ebp)
f01027d7:	68 70 08 11 f0       	push   $0xf0110870
f01027dc:	68 24 01 00 00       	push   $0x124
f01027e1:	68 a1 08 11 f0       	push   $0xf01108a1
f01027e6:	e8 71 d9 ff ff       	call   f010015c <_panic>
f01027eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01027ee:	05 00 00 00 10       	add    $0x10000000,%eax
f01027f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f01027f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01027f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102800:	8b 45 08             	mov    0x8(%ebp),%eax
f0102803:	01 d0                	add    %edx,%eax
f0102805:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102808:	83 ca 03             	or     $0x3,%edx
f010280b:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f010280d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102810:	eb 0a                	jmp    f010281c <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0102812:	b8 00 00 00 00       	mov    $0x0,%eax
f0102817:	eb 03                	jmp    f010281c <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0102819:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f010281c:	c9                   	leave  
f010281d:	c3                   	ret    

f010281e <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f010281e:	55                   	push   %ebp
f010281f:	89 e5                	mov    %esp,%ebp
f0102821:	53                   	push   %ebx
f0102822:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&free_frame_list);
f0102825:	c7 05 74 52 45 f0 00 	movl   $0x0,0xf0455274
f010282c:	00 00 00 
f010282f:	c7 05 78 52 45 f0 00 	movl   $0x0,0xf0455278
f0102836:	00 00 00 
f0102839:	c7 05 80 52 45 f0 00 	movl   $0x0,0xf0455280
f0102840:	00 00 00 
	LIST_INIT(&modified_frame_list);
f0102843:	c7 05 60 52 45 f0 00 	movl   $0x0,0xf0455260
f010284a:	00 00 00 
f010284d:	c7 05 64 52 45 f0 00 	movl   $0x0,0xf0455264
f0102854:	00 00 00 
f0102857:	c7 05 6c 52 45 f0 00 	movl   $0x0,0xf045526c
f010285e:	00 00 00 

	frames_info[0].references = 1;
f0102861:	a1 84 52 45 f0       	mov    0xf0455284,%eax
f0102866:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f010286c:	a1 84 52 45 f0       	mov    0xf0455284,%eax
f0102871:	83 c0 18             	add    $0x18,%eax
f0102874:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f010287a:	a1 84 52 45 f0       	mov    0xf0455284,%eax
f010287f:	83 c0 30             	add    $0x30,%eax
f0102882:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0102888:	c7 05 88 52 45 f0 00 	movl   $0xf0001000,0xf0455288
f010288f:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0102892:	c7 05 94 52 45 f0 00 	movl   $0xf0002000,0xf0455294
f0102899:	20 00 f0 
	i =0;
f010289c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f01028a3:	eb 1f                	jmp    f01028c4 <initialize_paging+0xa6>
	{
		ptr_zero_page[i]=0;
f01028a5:	8b 15 88 52 45 f0    	mov    0xf0455288,%edx
f01028ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01028ae:	01 d0                	add    %edx,%eax
f01028b0:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f01028b3:	8b 15 94 52 45 f0    	mov    0xf0455294,%edx
f01028b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01028bc:	01 d0                	add    %edx,%eax
f01028be:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f01028c1:	ff 45 f4             	incl   -0xc(%ebp)
f01028c4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01028cb:	7e d8                	jle    f01028a5 <initialize_paging+0x87>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f01028cd:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01028d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d7:	05 ff ff 09 00       	add    $0x9ffff,%eax
f01028dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01028df:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028e2:	ba 00 00 00 00       	mov    $0x0,%edx
f01028e7:	f7 75 f0             	divl   -0x10(%ebp)
f01028ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ed:	29 d0                	sub    %edx,%eax
f01028ef:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01028f2:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f01028f9:	e9 bc 00 00 00       	jmp    f01029ba <initialize_paging+0x19c>
	{

		initialize_frame_info(&(frames_info[i]));
f01028fe:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102904:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102907:	89 d0                	mov    %edx,%eax
f0102909:	01 c0                	add    %eax,%eax
f010290b:	01 d0                	add    %edx,%eax
f010290d:	c1 e0 03             	shl    $0x3,%eax
f0102910:	01 c8                	add    %ecx,%eax
f0102912:	83 ec 0c             	sub    $0xc,%esp
f0102915:	50                   	push   %eax
f0102916:	e8 62 02 00 00       	call   f0102b7d <initialize_frame_info>
f010291b:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&free_frame_list, &frames_info[i]);
f010291e:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102924:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102927:	89 d0                	mov    %edx,%eax
f0102929:	01 c0                	add    %eax,%eax
f010292b:	01 d0                	add    %edx,%eax
f010292d:	c1 e0 03             	shl    $0x3,%eax
f0102930:	01 c8                	add    %ecx,%eax
f0102932:	8b 15 74 52 45 f0    	mov    0xf0455274,%edx
f0102938:	89 10                	mov    %edx,(%eax)
f010293a:	8b 00                	mov    (%eax),%eax
f010293c:	85 c0                	test   %eax,%eax
f010293e:	74 1f                	je     f010295f <initialize_paging+0x141>
f0102940:	8b 15 74 52 45 f0    	mov    0xf0455274,%edx
f0102946:	8b 1d 84 52 45 f0    	mov    0xf0455284,%ebx
f010294c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010294f:	89 c8                	mov    %ecx,%eax
f0102951:	01 c0                	add    %eax,%eax
f0102953:	01 c8                	add    %ecx,%eax
f0102955:	c1 e0 03             	shl    $0x3,%eax
f0102958:	01 d8                	add    %ebx,%eax
f010295a:	89 42 04             	mov    %eax,0x4(%edx)
f010295d:	eb 19                	jmp    f0102978 <initialize_paging+0x15a>
f010295f:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102965:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102968:	89 d0                	mov    %edx,%eax
f010296a:	01 c0                	add    %eax,%eax
f010296c:	01 d0                	add    %edx,%eax
f010296e:	c1 e0 03             	shl    $0x3,%eax
f0102971:	01 c8                	add    %ecx,%eax
f0102973:	a3 78 52 45 f0       	mov    %eax,0xf0455278
f0102978:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f010297e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102981:	89 d0                	mov    %edx,%eax
f0102983:	01 c0                	add    %eax,%eax
f0102985:	01 d0                	add    %edx,%eax
f0102987:	c1 e0 03             	shl    $0x3,%eax
f010298a:	01 c8                	add    %ecx,%eax
f010298c:	a3 74 52 45 f0       	mov    %eax,0xf0455274
f0102991:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102997:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010299a:	89 d0                	mov    %edx,%eax
f010299c:	01 c0                	add    %eax,%eax
f010299e:	01 d0                	add    %edx,%eax
f01029a0:	c1 e0 03             	shl    $0x3,%eax
f01029a3:	01 c8                	add    %ecx,%eax
f01029a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01029ac:	a1 80 52 45 f0       	mov    0xf0455280,%eax
f01029b1:	40                   	inc    %eax
f01029b2:	a3 80 52 45 f0       	mov    %eax,0xf0455280
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01029b7:	ff 45 f4             	incl   -0xc(%ebp)
f01029ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01029bd:	85 c0                	test   %eax,%eax
f01029bf:	79 05                	jns    f01029c6 <initialize_paging+0x1a8>
f01029c1:	05 ff 0f 00 00       	add    $0xfff,%eax
f01029c6:	c1 f8 0c             	sar    $0xc,%eax
f01029c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01029cc:	0f 8f 2c ff ff ff    	jg     f01028fe <initialize_paging+0xe0>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f01029d2:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f01029d9:	eb 1d                	jmp    f01029f8 <initialize_paging+0x1da>
	{
		frames_info[i].references = 1;
f01029db:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f01029e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01029e4:	89 d0                	mov    %edx,%eax
f01029e6:	01 c0                	add    %eax,%eax
f01029e8:	01 d0                	add    %edx,%eax
f01029ea:	c1 e0 03             	shl    $0x3,%eax
f01029ed:	01 c8                	add    %ecx,%eax
f01029ef:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f01029f5:	ff 45 f4             	incl   -0xc(%ebp)
f01029f8:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f01029ff:	7e da                	jle    f01029db <initialize_paging+0x1bd>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0102a01:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0102a08:	a1 8c 52 45 f0       	mov    0xf045528c,%eax
f0102a0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102a10:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0102a17:	77 17                	ja     f0102a30 <initialize_paging+0x212>
f0102a19:	ff 75 e0             	pushl  -0x20(%ebp)
f0102a1c:	68 70 08 11 f0       	push   $0xf0110870
f0102a21:	68 71 01 00 00       	push   $0x171
f0102a26:	68 a1 08 11 f0       	push   $0xf01108a1
f0102a2b:	e8 2c d7 ff ff       	call   f010015c <_panic>
f0102a30:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a33:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0102a39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a3c:	01 d0                	add    %edx,%eax
f0102a3e:	48                   	dec    %eax
f0102a3f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0102a42:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a45:	ba 00 00 00 00       	mov    $0x0,%edx
f0102a4a:	f7 75 e4             	divl   -0x1c(%ebp)
f0102a4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a50:	29 d0                	sub    %edx,%eax
f0102a52:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0102a55:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0102a5c:	eb 1d                	jmp    f0102a7b <initialize_paging+0x25d>
	{
		frames_info[i].references = 1;
f0102a5e:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102a64:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102a67:	89 d0                	mov    %edx,%eax
f0102a69:	01 c0                	add    %eax,%eax
f0102a6b:	01 d0                	add    %edx,%eax
f0102a6d:	c1 e0 03             	shl    $0x3,%eax
f0102a70:	01 c8                	add    %ecx,%eax
f0102a72:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0102a78:	ff 45 f4             	incl   -0xc(%ebp)
f0102a7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102a7e:	85 c0                	test   %eax,%eax
f0102a80:	79 05                	jns    f0102a87 <initialize_paging+0x269>
f0102a82:	05 ff 0f 00 00       	add    $0xfff,%eax
f0102a87:	c1 f8 0c             	sar    $0xc,%eax
f0102a8a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0102a8d:	7f cf                	jg     f0102a5e <initialize_paging+0x240>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0102a8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102a92:	85 c0                	test   %eax,%eax
f0102a94:	79 05                	jns    f0102a9b <initialize_paging+0x27d>
f0102a96:	05 ff 0f 00 00       	add    $0xfff,%eax
f0102a9b:	c1 f8 0c             	sar    $0xc,%eax
f0102a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0102aa1:	e9 bc 00 00 00       	jmp    f0102b62 <initialize_paging+0x344>
	{
		initialize_frame_info(&(frames_info[i]));
f0102aa6:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102aac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102aaf:	89 d0                	mov    %edx,%eax
f0102ab1:	01 c0                	add    %eax,%eax
f0102ab3:	01 d0                	add    %edx,%eax
f0102ab5:	c1 e0 03             	shl    $0x3,%eax
f0102ab8:	01 c8                	add    %ecx,%eax
f0102aba:	83 ec 0c             	sub    $0xc,%esp
f0102abd:	50                   	push   %eax
f0102abe:	e8 ba 00 00 00       	call   f0102b7d <initialize_frame_info>
f0102ac3:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&free_frame_list, &frames_info[i]);
f0102ac6:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102acc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102acf:	89 d0                	mov    %edx,%eax
f0102ad1:	01 c0                	add    %eax,%eax
f0102ad3:	01 d0                	add    %edx,%eax
f0102ad5:	c1 e0 03             	shl    $0x3,%eax
f0102ad8:	01 c8                	add    %ecx,%eax
f0102ada:	8b 15 74 52 45 f0    	mov    0xf0455274,%edx
f0102ae0:	89 10                	mov    %edx,(%eax)
f0102ae2:	8b 00                	mov    (%eax),%eax
f0102ae4:	85 c0                	test   %eax,%eax
f0102ae6:	74 1f                	je     f0102b07 <initialize_paging+0x2e9>
f0102ae8:	8b 15 74 52 45 f0    	mov    0xf0455274,%edx
f0102aee:	8b 1d 84 52 45 f0    	mov    0xf0455284,%ebx
f0102af4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102af7:	89 c8                	mov    %ecx,%eax
f0102af9:	01 c0                	add    %eax,%eax
f0102afb:	01 c8                	add    %ecx,%eax
f0102afd:	c1 e0 03             	shl    $0x3,%eax
f0102b00:	01 d8                	add    %ebx,%eax
f0102b02:	89 42 04             	mov    %eax,0x4(%edx)
f0102b05:	eb 19                	jmp    f0102b20 <initialize_paging+0x302>
f0102b07:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102b0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102b10:	89 d0                	mov    %edx,%eax
f0102b12:	01 c0                	add    %eax,%eax
f0102b14:	01 d0                	add    %edx,%eax
f0102b16:	c1 e0 03             	shl    $0x3,%eax
f0102b19:	01 c8                	add    %ecx,%eax
f0102b1b:	a3 78 52 45 f0       	mov    %eax,0xf0455278
f0102b20:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102b26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102b29:	89 d0                	mov    %edx,%eax
f0102b2b:	01 c0                	add    %eax,%eax
f0102b2d:	01 d0                	add    %edx,%eax
f0102b2f:	c1 e0 03             	shl    $0x3,%eax
f0102b32:	01 c8                	add    %ecx,%eax
f0102b34:	a3 74 52 45 f0       	mov    %eax,0xf0455274
f0102b39:	8b 0d 84 52 45 f0    	mov    0xf0455284,%ecx
f0102b3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102b42:	89 d0                	mov    %edx,%eax
f0102b44:	01 c0                	add    %eax,%eax
f0102b46:	01 d0                	add    %edx,%eax
f0102b48:	c1 e0 03             	shl    $0x3,%eax
f0102b4b:	01 c8                	add    %ecx,%eax
f0102b4d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102b54:	a1 80 52 45 f0       	mov    0xf0455280,%eax
f0102b59:	40                   	inc    %eax
f0102b5a:	a3 80 52 45 f0       	mov    %eax,0xf0455280
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0102b5f:	ff 45 f4             	incl   -0xc(%ebp)
f0102b62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102b65:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f0102b6a:	39 c2                	cmp    %eax,%edx
f0102b6c:	0f 82 34 ff ff ff    	jb     f0102aa6 <initialize_paging+0x288>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f0102b72:	e8 e6 71 00 00       	call   f0109d5d <initialize_disk_page_file>
}
f0102b77:	90                   	nop
f0102b78:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102b7b:	c9                   	leave  
f0102b7c:	c3                   	ret    

f0102b7d <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct Frame_Info *ptr_frame_info)
{
f0102b7d:	55                   	push   %ebp
f0102b7e:	89 e5                	mov    %esp,%ebp
f0102b80:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0102b83:	83 ec 04             	sub    $0x4,%esp
f0102b86:	6a 18                	push   $0x18
f0102b88:	6a 00                	push   $0x0
f0102b8a:	ff 75 08             	pushl  0x8(%ebp)
f0102b8d:	e8 0c c1 00 00       	call   f010ec9e <memset>
f0102b92:	83 c4 10             	add    $0x10,%esp
}
f0102b95:	90                   	nop
f0102b96:	c9                   	leave  
f0102b97:	c3                   	ret    

f0102b98 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct Frame_Info **ptr_frame_info)
{
f0102b98:	55                   	push   %ebp
f0102b99:	89 e5                	mov    %esp,%ebp
f0102b9b:	83 ec 08             	sub    $0x8,%esp
	*ptr_frame_info = LIST_FIRST(&free_frame_list);
f0102b9e:	8b 15 74 52 45 f0    	mov    0xf0455274,%edx
f0102ba4:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ba7:	89 10                	mov    %edx,(%eax)
	if (*ptr_frame_info == NULL)
f0102ba9:	8b 45 08             	mov    0x8(%ebp),%eax
f0102bac:	8b 00                	mov    (%eax),%eax
f0102bae:	85 c0                	test   %eax,%eax
f0102bb0:	75 17                	jne    f0102bc9 <allocate_frame+0x31>
	{
		//TODO: [PROJECT 2016 - BONUS5] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0102bb2:	83 ec 04             	sub    $0x4,%esp
f0102bb5:	68 f8 08 11 f0       	push   $0xf01108f8
f0102bba:	68 a1 01 00 00       	push   $0x1a1
f0102bbf:	68 a1 08 11 f0       	push   $0xf01108a1
f0102bc4:	e8 93 d5 ff ff       	call   f010015c <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the clock algorithm
	}

	LIST_REMOVE(&free_frame_list,*ptr_frame_info);
f0102bc9:	8b 45 08             	mov    0x8(%ebp),%eax
f0102bcc:	8b 00                	mov    (%eax),%eax
f0102bce:	8b 00                	mov    (%eax),%eax
f0102bd0:	85 c0                	test   %eax,%eax
f0102bd2:	74 14                	je     f0102be8 <allocate_frame+0x50>
f0102bd4:	8b 45 08             	mov    0x8(%ebp),%eax
f0102bd7:	8b 00                	mov    (%eax),%eax
f0102bd9:	8b 00                	mov    (%eax),%eax
f0102bdb:	8b 55 08             	mov    0x8(%ebp),%edx
f0102bde:	8b 12                	mov    (%edx),%edx
f0102be0:	8b 52 04             	mov    0x4(%edx),%edx
f0102be3:	89 50 04             	mov    %edx,0x4(%eax)
f0102be6:	eb 0d                	jmp    f0102bf5 <allocate_frame+0x5d>
f0102be8:	8b 45 08             	mov    0x8(%ebp),%eax
f0102beb:	8b 00                	mov    (%eax),%eax
f0102bed:	8b 40 04             	mov    0x4(%eax),%eax
f0102bf0:	a3 78 52 45 f0       	mov    %eax,0xf0455278
f0102bf5:	8b 45 08             	mov    0x8(%ebp),%eax
f0102bf8:	8b 00                	mov    (%eax),%eax
f0102bfa:	8b 40 04             	mov    0x4(%eax),%eax
f0102bfd:	85 c0                	test   %eax,%eax
f0102bff:	74 13                	je     f0102c14 <allocate_frame+0x7c>
f0102c01:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c04:	8b 00                	mov    (%eax),%eax
f0102c06:	8b 40 04             	mov    0x4(%eax),%eax
f0102c09:	8b 55 08             	mov    0x8(%ebp),%edx
f0102c0c:	8b 12                	mov    (%edx),%edx
f0102c0e:	8b 12                	mov    (%edx),%edx
f0102c10:	89 10                	mov    %edx,(%eax)
f0102c12:	eb 0c                	jmp    f0102c20 <allocate_frame+0x88>
f0102c14:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c17:	8b 00                	mov    (%eax),%eax
f0102c19:	8b 00                	mov    (%eax),%eax
f0102c1b:	a3 74 52 45 f0       	mov    %eax,0xf0455274
f0102c20:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c23:	8b 00                	mov    (%eax),%eax
f0102c25:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102c2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c2e:	8b 00                	mov    (%eax),%eax
f0102c30:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102c37:	a1 80 52 45 f0       	mov    0xf0455280,%eax
f0102c3c:	48                   	dec    %eax
f0102c3d:	a3 80 52 45 f0       	mov    %eax,0xf0455280

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/

	if((*ptr_frame_info)->isBuffered)
f0102c42:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c45:	8b 00                	mov    (%eax),%eax
f0102c47:	8a 40 14             	mov    0x14(%eax),%al
f0102c4a:	84 c0                	test   %al,%al
f0102c4c:	74 1d                	je     f0102c6b <allocate_frame+0xd3>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->environment,(*ptr_frame_info)->va);
f0102c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c51:	8b 00                	mov    (%eax),%eax
f0102c53:	8b 50 0c             	mov    0xc(%eax),%edx
f0102c56:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c59:	8b 00                	mov    (%eax),%eax
f0102c5b:	8b 40 10             	mov    0x10(%eax),%eax
f0102c5e:	83 ec 08             	sub    $0x8,%esp
f0102c61:	52                   	push   %edx
f0102c62:	50                   	push   %eax
f0102c63:	e8 55 15 00 00       	call   f01041bd <pt_clear_page_table_entry>
f0102c68:	83 c4 10             	add    $0x10,%esp
	}

	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f0102c6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0102c6e:	8b 00                	mov    (%eax),%eax
f0102c70:	83 ec 0c             	sub    $0xc,%esp
f0102c73:	50                   	push   %eax
f0102c74:	e8 04 ff ff ff       	call   f0102b7d <initialize_frame_info>
f0102c79:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102c7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102c81:	c9                   	leave  
f0102c82:	c3                   	ret    

f0102c83 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct Frame_Info *ptr_frame_info)
{
f0102c83:	55                   	push   %ebp
f0102c84:	89 e5                	mov    %esp,%ebp
f0102c86:	83 ec 08             	sub    $0x8,%esp
	/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
	initialize_frame_info(ptr_frame_info);
f0102c89:	83 ec 0c             	sub    $0xc,%esp
f0102c8c:	ff 75 08             	pushl  0x8(%ebp)
f0102c8f:	e8 e9 fe ff ff       	call   f0102b7d <initialize_frame_info>
f0102c94:	83 c4 10             	add    $0x10,%esp
	/*=============================================================================*/

	// Fill this function in
	LIST_INSERT_HEAD(&free_frame_list, ptr_frame_info);
f0102c97:	8b 15 74 52 45 f0    	mov    0xf0455274,%edx
f0102c9d:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ca0:	89 10                	mov    %edx,(%eax)
f0102ca2:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ca5:	8b 00                	mov    (%eax),%eax
f0102ca7:	85 c0                	test   %eax,%eax
f0102ca9:	74 0d                	je     f0102cb8 <free_frame+0x35>
f0102cab:	a1 74 52 45 f0       	mov    0xf0455274,%eax
f0102cb0:	8b 55 08             	mov    0x8(%ebp),%edx
f0102cb3:	89 50 04             	mov    %edx,0x4(%eax)
f0102cb6:	eb 08                	jmp    f0102cc0 <free_frame+0x3d>
f0102cb8:	8b 45 08             	mov    0x8(%ebp),%eax
f0102cbb:	a3 78 52 45 f0       	mov    %eax,0xf0455278
f0102cc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0102cc3:	a3 74 52 45 f0       	mov    %eax,0xf0455274
f0102cc8:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ccb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0102cd2:	a1 80 52 45 f0       	mov    0xf0455280,%eax
f0102cd7:	40                   	inc    %eax
f0102cd8:	a3 80 52 45 f0       	mov    %eax,0xf0455280
	//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));


}
f0102cdd:	90                   	nop
f0102cde:	c9                   	leave  
f0102cdf:	c3                   	ret    

f0102ce0 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct Frame_Info* ptr_frame_info)
{
f0102ce0:	55                   	push   %ebp
f0102ce1:	89 e5                	mov    %esp,%ebp
f0102ce3:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f0102ce6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ce9:	8b 40 08             	mov    0x8(%eax),%eax
f0102cec:	48                   	dec    %eax
f0102ced:	8b 55 08             	mov    0x8(%ebp),%edx
f0102cf0:	66 89 42 08          	mov    %ax,0x8(%edx)
f0102cf4:	8b 45 08             	mov    0x8(%ebp),%eax
f0102cf7:	8b 40 08             	mov    0x8(%eax),%eax
f0102cfa:	66 85 c0             	test   %ax,%ax
f0102cfd:	75 0e                	jne    f0102d0d <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0102cff:	83 ec 0c             	sub    $0xc,%esp
f0102d02:	ff 75 08             	pushl  0x8(%ebp)
f0102d05:	e8 79 ff ff ff       	call   f0102c83 <free_frame>
f0102d0a:	83 c4 10             	add    $0x10,%esp
}
f0102d0d:	90                   	nop
f0102d0e:	c9                   	leave  
f0102d0f:	c3                   	ret    

f0102d10 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const void *virtual_address, uint32 **ptr_page_table)
{
f0102d10:	55                   	push   %ebp
f0102d11:	89 e5                	mov    %esp,%ebp
f0102d13:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0102d16:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d19:	c1 e8 16             	shr    $0x16,%eax
f0102d1c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102d23:	8b 45 08             	mov    0x8(%ebp),%eax
f0102d26:	01 d0                	add    %edx,%eax
f0102d28:	8b 00                	mov    (%eax),%eax
f0102d2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0102d2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d30:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102d35:	77 1d                	ja     f0102d54 <get_page_table+0x44>
	{
		*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0102d37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d3a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102d3f:	83 ec 0c             	sub    $0xc,%esp
f0102d42:	50                   	push   %eax
f0102d43:	e8 5b 84 00 00       	call   f010b1a3 <kheap_virtual_address>
f0102d48:	83 c4 10             	add    $0x10,%esp
f0102d4b:	89 c2                	mov    %eax,%edx
f0102d4d:	8b 45 10             	mov    0x10(%ebp),%eax
f0102d50:	89 10                	mov    %edx,(%eax)
f0102d52:	eb 44                	jmp    f0102d98 <get_page_table+0x88>
	}
	else
	{
		*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0102d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d57:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102d5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102d5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102d62:	c1 e8 0c             	shr    $0xc,%eax
f0102d65:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102d68:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f0102d6d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0102d70:	72 17                	jb     f0102d89 <get_page_table+0x79>
f0102d72:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d75:	68 c8 08 11 f0       	push   $0xf01108c8
f0102d7a:	68 eb 01 00 00       	push   $0x1eb
f0102d7f:	68 a1 08 11 f0       	push   $0xf01108a1
f0102d84:	e8 d3 d3 ff ff       	call   f010015c <_panic>
f0102d89:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102d8c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102d91:	89 c2                	mov    %eax,%edx
f0102d93:	8b 45 10             	mov    0x10(%ebp),%eax
f0102d96:	89 10                	mov    %edx,(%eax)
	}

	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0102d98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d9b:	83 e0 01             	and    $0x1,%eax
f0102d9e:	85 c0                	test   %eax,%eax
f0102da0:	74 0a                	je     f0102dac <get_page_table+0x9c>
	{
		return TABLE_IN_MEMORY;
f0102da2:	b8 00 00 00 00       	mov    $0x0,%eax
f0102da7:	e9 ba 00 00 00       	jmp    f0102e66 <get_page_table+0x156>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f0102dac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102db0:	0f 84 a2 00 00 00    	je     f0102e58 <get_page_table+0x148>
	{
		// Put the faulted address in CR2 and then
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;
f0102db6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102db9:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f0102dbc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102dbf:	0f 22 d0             	mov    %eax,%cr2

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0102dc2:	83 ec 0c             	sub    $0xc,%esp
f0102dc5:	6a 00                	push   $0x0
f0102dc7:	e8 ed 48 00 00       	call   f01076b9 <fault_handler>
f0102dcc:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0102dcf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dd2:	c1 e8 16             	shr    $0x16,%eax
f0102dd5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102ddc:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ddf:	01 d0                	add    %edx,%eax
f0102de1:	8b 00                	mov    (%eax),%eax
f0102de3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0102de6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102de9:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102dee:	77 1d                	ja     f0102e0d <get_page_table+0xfd>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0102df0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102df3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102df8:	83 ec 0c             	sub    $0xc,%esp
f0102dfb:	50                   	push   %eax
f0102dfc:	e8 a2 83 00 00       	call   f010b1a3 <kheap_virtual_address>
f0102e01:	83 c4 10             	add    $0x10,%esp
f0102e04:	89 c2                	mov    %eax,%edx
f0102e06:	8b 45 10             	mov    0x10(%ebp),%eax
f0102e09:	89 10                	mov    %edx,(%eax)
f0102e0b:	eb 44                	jmp    f0102e51 <get_page_table+0x141>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0102e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e10:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102e15:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0102e18:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102e1b:	c1 e8 0c             	shr    $0xc,%eax
f0102e1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0102e21:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f0102e26:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0102e29:	72 17                	jb     f0102e42 <get_page_table+0x132>
f0102e2b:	ff 75 e8             	pushl  -0x18(%ebp)
f0102e2e:	68 c8 08 11 f0       	push   $0xf01108c8
f0102e33:	68 06 02 00 00       	push   $0x206
f0102e38:	68 a1 08 11 f0       	push   $0xf01108a1
f0102e3d:	e8 1a d3 ff ff       	call   f010015c <_panic>
f0102e42:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102e45:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102e4a:	89 c2                	mov    %eax,%edx
f0102e4c:	8b 45 10             	mov    0x10(%ebp),%eax
f0102e4f:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0102e51:	b8 00 00 00 00       	mov    $0x0,%eax
f0102e56:	eb 0e                	jmp    f0102e66 <get_page_table+0x156>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0102e58:	8b 45 10             	mov    0x10(%ebp),%eax
f0102e5b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f0102e61:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0102e66:	c9                   	leave  
f0102e67:	c3                   	ret    

f0102e68 <create_page_table>:

void * create_page_table(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f0102e68:	55                   	push   %ebp
f0102e69:	89 e5                	mov    %esp,%ebp
f0102e6b:	83 ec 18             	sub    $0x18,%esp
	// Write your code here, remove the panic and write your code
	//panic("create_page_table() is not implemented yet...!!");

	//Use kmalloc() to create a new page TABLE for the given virtual address and return the address of the created table
	//refer to the project documentation for the detailed steps
	uint32 *ptr_page_table = kmalloc(PAGE_SIZE);
f0102e6e:	83 ec 0c             	sub    $0xc,%esp
f0102e71:	68 00 10 00 00       	push   $0x1000
f0102e76:	e8 aa 7e 00 00       	call   f010ad25 <kmalloc>
f0102e7b:	83 c4 10             	add    $0x10,%esp
f0102e7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 phys_page_table = kheap_physical_address((uint32) ptr_page_table);
f0102e81:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102e84:	83 ec 0c             	sub    $0xc,%esp
f0102e87:	50                   	push   %eax
f0102e88:	e8 35 83 00 00       	call   f010b1c2 <kheap_physical_address>
f0102e8d:	83 c4 10             	add    $0x10,%esp
f0102e90:	89 45 ec             	mov    %eax,-0x14(%ebp)
	ptr_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,
f0102e93:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e96:	c1 e8 16             	shr    $0x16,%eax
f0102e99:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102ea0:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ea3:	01 d0                	add    %edx,%eax
f0102ea5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102ea8:	83 ca 07             	or     $0x7,%edx
f0102eab:	89 10                	mov    %edx,(%eax)
			PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	int i = 0;
f0102ead:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (; i < 1024; i++) {
f0102eb4:	eb 18                	jmp    f0102ece <create_page_table+0x66>
		ptr_page_table[i] = 0;
f0102eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102eb9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102ec0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102ec3:	01 d0                	add    %edx,%eax
f0102ec5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	uint32 phys_page_table = kheap_physical_address((uint32) ptr_page_table);
	ptr_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,
			PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	int i = 0;
	for (; i < 1024; i++) {
f0102ecb:	ff 45 f4             	incl   -0xc(%ebp)
f0102ece:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0102ed5:	7e df                	jle    f0102eb6 <create_page_table+0x4e>

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102ed7:	0f 20 d8             	mov    %cr3,%eax
f0102eda:	89 45 e8             	mov    %eax,-0x18(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102edd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102ee0:	0f 22 d8             	mov    %eax,%cr3
		ptr_page_table[i] = 0;
	}

	tlbflush();

	return ptr_page_table;
f0102ee3:	8b 45 f0             	mov    -0x10(%ebp),%eax


}
f0102ee6:	c9                   	leave  
f0102ee7:	c3                   	ret    

f0102ee8 <__static_cpt>:

void __static_cpt(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0102ee8:	55                   	push   %ebp
f0102ee9:	89 e5                	mov    %esp,%ebp
f0102eeb:	83 ec 28             	sub    $0x28,%esp
	struct Frame_Info* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0102eee:	83 ec 0c             	sub    $0xc,%esp
f0102ef1:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102ef4:	50                   	push   %eax
f0102ef5:	e8 9e fc ff ff       	call   f0102b98 <allocate_frame>
f0102efa:	83 c4 10             	add    $0x10,%esp
f0102efd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0102f00:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102f03:	83 ec 0c             	sub    $0xc,%esp
f0102f06:	50                   	push   %eax
f0102f07:	e8 96 f4 ff ff       	call   f01023a2 <to_physical_address>
f0102f0c:	83 c4 10             	add    $0x10,%esp
f0102f0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0102f12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102f15:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102f18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102f1b:	c1 e8 0c             	shr    $0xc,%eax
f0102f1e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0102f21:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f0102f26:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0102f29:	72 17                	jb     f0102f42 <__static_cpt+0x5a>
f0102f2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102f2e:	68 c8 08 11 f0       	push   $0xf01108c8
f0102f33:	68 32 02 00 00       	push   $0x232
f0102f38:	68 a1 08 11 f0       	push   $0xf01108a1
f0102f3d:	e8 1a d2 ff ff       	call   f010015c <_panic>
f0102f42:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102f45:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102f4a:	89 c2                	mov    %eax,%edx
f0102f4c:	8b 45 10             	mov    0x10(%ebp),%eax
f0102f4f:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0102f51:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102f54:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0102f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5d:	c1 e8 16             	shr    $0x16,%eax
f0102f60:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102f67:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f6a:	01 d0                	add    %edx,%eax
f0102f6c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102f6f:	83 ca 07             	or     $0x7,%edx
f0102f72:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0102f74:	8b 45 10             	mov    0x10(%ebp),%eax
f0102f77:	8b 00                	mov    (%eax),%eax
f0102f79:	83 ec 04             	sub    $0x4,%esp
f0102f7c:	68 00 10 00 00       	push   $0x1000
f0102f81:	6a 00                	push   $0x0
f0102f83:	50                   	push   %eax
f0102f84:	e8 15 bd 00 00       	call   f010ec9e <memset>
f0102f89:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102f8c:	0f 20 d8             	mov    %cr3,%eax
f0102f8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102f92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102f95:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0102f98:	90                   	nop
f0102f99:	c9                   	leave  
f0102f9a:	c3                   	ret    

f0102f9b <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct Frame_Info *ptr_frame_info, void *virtual_address, int perm)
{
f0102f9b:	55                   	push   %ebp
f0102f9c:	89 e5                	mov    %esp,%ebp
f0102f9e:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0102fa1:	ff 75 0c             	pushl  0xc(%ebp)
f0102fa4:	e8 f9 f3 ff ff       	call   f01023a2 <to_physical_address>
f0102fa9:	83 c4 04             	add    $0x4,%esp
f0102fac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102fb5:	50                   	push   %eax
f0102fb6:	ff 75 10             	pushl  0x10(%ebp)
f0102fb9:	ff 75 08             	pushl  0x8(%ebp)
f0102fbc:	e8 4f fd ff ff       	call   f0102d10 <get_page_table>
f0102fc1:	83 c4 10             	add    $0x10,%esp
f0102fc4:	83 f8 01             	cmp    $0x1,%eax
f0102fc7:	75 15                	jne    f0102fde <map_frame+0x43>
		//page_directory_entry = ptr_page_directory[PDX(virtual_address)];
		//ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
		=============================================================================================*/
		if(USE_KHEAP)
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0102fc9:	8b 45 10             	mov    0x10(%ebp),%eax
f0102fcc:	83 ec 08             	sub    $0x8,%esp
f0102fcf:	50                   	push   %eax
f0102fd0:	ff 75 08             	pushl  0x8(%ebp)
f0102fd3:	e8 90 fe ff ff       	call   f0102e68 <create_page_table>
f0102fd8:	83 c4 10             	add    $0x10,%esp
f0102fdb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			__static_cpt(ptr_page_directory, (uint32)virtual_address, &ptr_page_table);
		}

	}

	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f0102fde:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102fe1:	8b 55 10             	mov    0x10(%ebp),%edx
f0102fe4:	c1 ea 0c             	shr    $0xc,%edx
f0102fe7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0102fed:	c1 e2 02             	shl    $0x2,%edx
f0102ff0:	01 d0                	add    %edx,%eax
f0102ff2:	8b 00                	mov    (%eax),%eax
f0102ff4:	89 45 f0             	mov    %eax,-0x10(%ebp)

	}*/

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0102ff7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102ffa:	83 e0 01             	and    $0x1,%eax
f0102ffd:	85 c0                	test   %eax,%eax
f0102fff:	74 25                	je     f0103026 <map_frame+0x8b>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0103001:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103004:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103009:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010300c:	75 07                	jne    f0103015 <map_frame+0x7a>
			return 0;
f010300e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103013:	eb 43                	jmp    f0103058 <map_frame+0xbd>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0103015:	83 ec 08             	sub    $0x8,%esp
f0103018:	ff 75 10             	pushl  0x10(%ebp)
f010301b:	ff 75 08             	pushl  0x8(%ebp)
f010301e:	e8 a7 00 00 00       	call   f01030ca <unmap_frame>
f0103023:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0103026:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103029:	8b 40 08             	mov    0x8(%eax),%eax
f010302c:	40                   	inc    %eax
f010302d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103030:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0103034:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103037:	8b 55 10             	mov    0x10(%ebp),%edx
f010303a:	c1 ea 0c             	shr    $0xc,%edx
f010303d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103043:	c1 e2 02             	shl    $0x2,%edx
f0103046:	01 c2                	add    %eax,%edx
f0103048:	8b 45 14             	mov    0x14(%ebp),%eax
f010304b:	0b 45 f4             	or     -0xc(%ebp),%eax
f010304e:	83 c8 01             	or     $0x1,%eax
f0103051:	89 02                	mov    %eax,(%edx)

	return 0;
f0103053:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103058:	c9                   	leave  
f0103059:	c3                   	ret    

f010305a <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct Frame_Info * get_frame_info(uint32 *ptr_page_directory, void *virtual_address, uint32 **ptr_page_table)
																{
f010305a:	55                   	push   %ebp
f010305b:	89 e5                	mov    %esp,%ebp
f010305d:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0103060:	83 ec 04             	sub    $0x4,%esp
f0103063:	ff 75 10             	pushl  0x10(%ebp)
f0103066:	ff 75 0c             	pushl  0xc(%ebp)
f0103069:	ff 75 08             	pushl  0x8(%ebp)
f010306c:	e8 9f fc ff ff       	call   f0102d10 <get_page_table>
f0103071:	83 c4 10             	add    $0x10,%esp
f0103074:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0103077:	8b 45 10             	mov    0x10(%ebp),%eax
f010307a:	8b 00                	mov    (%eax),%eax
f010307c:	85 c0                	test   %eax,%eax
f010307e:	74 43                	je     f01030c3 <get_frame_info+0x69>
	{
		uint32 index_page_table = PTX(virtual_address);
f0103080:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103083:	c1 e8 0c             	shr    $0xc,%eax
f0103086:	25 ff 03 00 00       	and    $0x3ff,%eax
f010308b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010308e:	8b 45 10             	mov    0x10(%ebp),%eax
f0103091:	8b 00                	mov    (%eax),%eax
f0103093:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103096:	c1 e2 02             	shl    $0x2,%edx
f0103099:	01 d0                	add    %edx,%eax
f010309b:	8b 00                	mov    (%eax),%eax
f010309d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if( page_table_entry != 0)
f01030a0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01030a4:	74 16                	je     f01030bc <get_frame_info+0x62>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01030a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01030a9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01030ae:	83 ec 0c             	sub    $0xc,%esp
f01030b1:	50                   	push   %eax
f01030b2:	e8 fe f2 ff ff       	call   f01023b5 <to_frame_info>
f01030b7:	83 c4 10             	add    $0x10,%esp
f01030ba:	eb 0c                	jmp    f01030c8 <get_frame_info+0x6e>
		}
		return 0;
f01030bc:	b8 00 00 00 00       	mov    $0x0,%eax
f01030c1:	eb 05                	jmp    f01030c8 <get_frame_info+0x6e>
	}
	return 0;
f01030c3:	b8 00 00 00 00       	mov    $0x0,%eax
																}
f01030c8:	c9                   	leave  
f01030c9:	c3                   	ret    

f01030ca <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, void *virtual_address)
{
f01030ca:	55                   	push   %ebp
f01030cb:	89 e5                	mov    %esp,%ebp
f01030cd:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct Frame_Info* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01030d0:	83 ec 04             	sub    $0x4,%esp
f01030d3:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01030d6:	50                   	push   %eax
f01030d7:	ff 75 0c             	pushl  0xc(%ebp)
f01030da:	ff 75 08             	pushl  0x8(%ebp)
f01030dd:	e8 78 ff ff ff       	call   f010305a <get_frame_info>
f01030e2:	83 c4 10             	add    $0x10,%esp
f01030e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01030e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01030ec:	74 60                	je     f010314e <unmap_frame+0x84>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f01030ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030f1:	8a 40 14             	mov    0x14(%eax),%al
f01030f4:	84 c0                	test   %al,%al
f01030f6:	74 1d                	je     f0103115 <unmap_frame+0x4b>
f01030f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030fb:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0103100:	77 13                	ja     f0103115 <unmap_frame+0x4b>
			cprintf("Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0103102:	83 ec 08             	sub    $0x8,%esp
f0103105:	ff 75 0c             	pushl  0xc(%ebp)
f0103108:	68 48 09 11 f0       	push   $0xf0110948
f010310d:	e8 49 2f 00 00       	call   f010605b <cprintf>
f0103112:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0103115:	83 ec 0c             	sub    $0xc,%esp
f0103118:	ff 75 f4             	pushl  -0xc(%ebp)
f010311b:	e8 c0 fb ff ff       	call   f0102ce0 <decrement_references>
f0103120:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0103123:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103126:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103129:	c1 ea 0c             	shr    $0xc,%edx
f010312c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103132:	c1 e2 02             	shl    $0x2,%edx
f0103135:	01 d0                	add    %edx,%eax
f0103137:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		tlb_invalidate(ptr_page_directory, virtual_address);
f010313d:	83 ec 08             	sub    $0x8,%esp
f0103140:	ff 75 0c             	pushl  0xc(%ebp)
f0103143:	ff 75 08             	pushl  0x8(%ebp)
f0103146:	e8 c9 ef ff ff       	call   f0102114 <tlb_invalidate>
f010314b:	83 c4 10             	add    $0x10,%esp
	}
}
f010314e:	90                   	nop
f010314f:	c9                   	leave  
f0103150:	c3                   	ret    

f0103151 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct Frame_Info *ptr_frame_info, void *virtual_address, int perm)
{
f0103151:	55                   	push   %ebp
f0103152:	89 e5                	mov    %esp,%ebp
f0103154:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0103157:	ff 75 0c             	pushl  0xc(%ebp)
f010315a:	e8 43 f2 ff ff       	call   f01023a2 <to_physical_address>
f010315f:	83 c4 04             	add    $0x4,%esp
f0103162:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0103165:	8b 45 10             	mov    0x10(%ebp),%eax
f0103168:	c1 e8 16             	shr    $0x16,%eax
f010316b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103172:	8b 45 08             	mov    0x8(%ebp),%eax
f0103175:	01 d0                	add    %edx,%eax
f0103177:	8b 00                	mov    (%eax),%eax
f0103179:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010317c:	8b 45 10             	mov    0x10(%ebp),%eax
f010317f:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0103184:	77 19                	ja     f010319f <loadtime_map_frame+0x4e>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0103186:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103189:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010318e:	83 ec 0c             	sub    $0xc,%esp
f0103191:	50                   	push   %eax
f0103192:	e8 0c 80 00 00       	call   f010b1a3 <kheap_virtual_address>
f0103197:	83 c4 10             	add    $0x10,%esp
f010319a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010319d:	eb 40                	jmp    f01031df <loadtime_map_frame+0x8e>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010319f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01031a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01031a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01031aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01031ad:	c1 e8 0c             	shr    $0xc,%eax
f01031b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01031b3:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f01031b8:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f01031bb:	72 17                	jb     f01031d4 <loadtime_map_frame+0x83>
f01031bd:	ff 75 ec             	pushl  -0x14(%ebp)
f01031c0:	68 c8 08 11 f0       	push   $0xf01108c8
f01031c5:	68 e3 02 00 00       	push   $0x2e3
f01031ca:	68 a1 08 11 f0       	push   $0xf01108a1
f01031cf:	e8 88 cf ff ff       	call   f010015c <_panic>
f01031d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01031d7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01031dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f01031df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01031e3:	75 15                	jne    f01031fa <loadtime_map_frame+0xa9>
	{
		if(USE_KHEAP)
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01031e5:	8b 45 10             	mov    0x10(%ebp),%eax
f01031e8:	83 ec 08             	sub    $0x8,%esp
f01031eb:	50                   	push   %eax
f01031ec:	ff 75 08             	pushl  0x8(%ebp)
f01031ef:	e8 74 fc ff ff       	call   f0102e68 <create_page_table>
f01031f4:	83 c4 10             	add    $0x10,%esp
f01031f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		{
			__static_cpt(ptr_page_directory, (uint32)virtual_address, &ptr_page_table);
		}
	}

	ptr_frame_info->references++;
f01031fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031fd:	8b 40 08             	mov    0x8(%eax),%eax
f0103200:	40                   	inc    %eax
f0103201:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103204:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0103208:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010320b:	8b 55 10             	mov    0x10(%ebp),%edx
f010320e:	c1 ea 0c             	shr    $0xc,%edx
f0103211:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103217:	c1 e2 02             	shl    $0x2,%edx
f010321a:	01 c2                	add    %eax,%edx
f010321c:	8b 45 14             	mov    0x14(%ebp),%eax
f010321f:	0b 45 f4             	or     -0xc(%ebp),%eax
f0103222:	83 c8 01             	or     $0x1,%eax
f0103225:	89 02                	mov    %eax,(%edx)

	return 0;
f0103227:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010322c:	c9                   	leave  
f010322d:	c3                   	ret    

f010322e <allocateMem>:
//======================================================

// [1] allocateMem

void allocateMem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010322e:	55                   	push   %ebp
f010322f:	89 e5                	mov    %esp,%ebp
f0103231:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT 2016 - Dynamic Allocation] allocateMem() [Kernel Side]
		// Write your code here, remove the panic and write your code
		//panic("allocateMem() is not implemented yet...!!");


		 size=ROUNDUP(size,PAGE_SIZE );
f0103234:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010323b:	8b 55 10             	mov    0x10(%ebp),%edx
f010323e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103241:	01 d0                	add    %edx,%eax
f0103243:	48                   	dec    %eax
f0103244:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103247:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010324a:	ba 00 00 00 00       	mov    $0x0,%edx
f010324f:	f7 75 ec             	divl   -0x14(%ebp)
f0103252:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103255:	29 d0                	sub    %edx,%eax
f0103257:	89 45 10             	mov    %eax,0x10(%ebp)

		 if(size==0)
f010325a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010325e:	74 43                	je     f01032a3 <allocateMem+0x75>
		 		{
		 			return ;
		 		}
		 uint32 i,va;
		va=virtual_address;
f0103260:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103263:	89 45 f0             	mov    %eax,-0x10(%ebp)


		for(i=0;i<size;i+=PAGE_SIZE)
f0103266:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010326d:	eb 2a                	jmp    f0103299 <allocateMem+0x6b>
		{

			int ret = pf_add_empty_env_page(e, va, 0);
f010326f:	83 ec 04             	sub    $0x4,%esp
f0103272:	6a 00                	push   $0x0
f0103274:	ff 75 f0             	pushl  -0x10(%ebp)
f0103277:	ff 75 08             	pushl  0x8(%ebp)
f010327a:	e8 8d 6e 00 00       	call   f010a10c <pf_add_empty_env_page>
f010327f:	83 c4 10             	add    $0x10,%esp
f0103282:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if (ret == E_NO_PAGE_FILE_SPACE) {
f0103285:	83 7d e4 f8          	cmpl   $0xfffffff8,-0x1c(%ebp)
f0103289:	74 1b                	je     f01032a6 <allocateMem+0x78>

				//panic("\nERROR: No enough virtual space on the page file\n");

				return ;
			}
			va+=PAGE_SIZE;
f010328b:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
		 		}
		 uint32 i,va;
		va=virtual_address;


		for(i=0;i<size;i+=PAGE_SIZE)
f0103292:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0103299:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010329c:	3b 45 10             	cmp    0x10(%ebp),%eax
f010329f:	72 ce                	jb     f010326f <allocateMem+0x41>
f01032a1:	eb 04                	jmp    f01032a7 <allocateMem+0x79>

		 size=ROUNDUP(size,PAGE_SIZE );

		 if(size==0)
		 		{
		 			return ;
f01032a3:	90                   	nop
f01032a4:	eb 01                	jmp    f01032a7 <allocateMem+0x79>
			int ret = pf_add_empty_env_page(e, va, 0);
			if (ret == E_NO_PAGE_FILE_SPACE) {

				//panic("\nERROR: No enough virtual space on the page file\n");

				return ;
f01032a6:	90                   	nop
		}


		//This function should allocate ALL pages of the required range in the PAGE FILE
		//and allocate NOTHING in the main memory
}
f01032a7:	c9                   	leave  
f01032a8:	c3                   	ret    

f01032a9 <freeMem>:


// [2] freeMem

void freeMem(struct Env* e, uint32 virtual_address, uint32 size)
{
f01032a9:	55                   	push   %ebp
f01032aa:	89 e5                	mov    %esp,%ebp
f01032ac:	83 ec 38             	sub    $0x38,%esp
	//TODO: [PROJECT 2016 - Dynamic Deallocation] freeMem() [Kernel Side]
	// Write your code here, remove the panic and write your code
	//panic("freeMem() is not implemented yet...!!");

	//virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
	size = ROUNDUP(size, PAGE_SIZE);
f01032af:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f01032b6:	8b 55 10             	mov    0x10(%ebp),%edx
f01032b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01032bc:	01 d0                	add    %edx,%eax
f01032be:	48                   	dec    %eax
f01032bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01032c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01032c5:	ba 00 00 00 00       	mov    $0x0,%edx
f01032ca:	f7 75 e4             	divl   -0x1c(%ebp)
f01032cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01032d0:	29 d0                	sub    %edx,%eax
f01032d2:	89 45 10             	mov    %eax,0x10(%ebp)

	if (size == 0) {
f01032d5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01032d9:	0f 84 67 01 00 00    	je     f0103446 <freeMem+0x19d>
		return;
	}

	int i = 0;
f01032df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//1. Free ALL pages of the given range from the Page File

	uint32 vir = virtual_address;
f01032e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < size; i += PAGE_SIZE)
f01032ec:	eb 1f                	jmp    f010330d <freeMem+0x64>
			{

				pf_remove_env_page(e, vir);
f01032ee:	83 ec 08             	sub    $0x8,%esp
f01032f1:	ff 75 f0             	pushl  -0x10(%ebp)
f01032f4:	ff 75 08             	pushl  0x8(%ebp)
f01032f7:	e8 4f 71 00 00       	call   f010a44b <pf_remove_env_page>
f01032fc:	83 c4 10             	add    $0x10,%esp

				vir += PAGE_SIZE;
f01032ff:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	int i = 0;

	//1. Free ALL pages of the given range from the Page File

	uint32 vir = virtual_address;
			for (; i < size; i += PAGE_SIZE)
f0103306:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010330d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103310:	3b 45 10             	cmp    0x10(%ebp),%eax
f0103313:	72 d9                	jb     f01032ee <freeMem+0x45>

	//2. Free ONLY pages that are resident in the working set from the memory
	//int j = 0;


	for (i = 0; i <e->page_WS_max_size; i++) {
f0103315:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010331c:	e9 12 01 00 00       	jmp    f0103433 <freeMem+0x18a>

		if (e->ptr_pageWorkingSet[i].empty==0) {
f0103321:	8b 45 08             	mov    0x8(%ebp),%eax
f0103324:	8b 48 78             	mov    0x78(%eax),%ecx
f0103327:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010332a:	89 d0                	mov    %edx,%eax
f010332c:	01 c0                	add    %eax,%eax
f010332e:	01 d0                	add    %edx,%eax
f0103330:	c1 e0 02             	shl    $0x2,%eax
f0103333:	01 c8                	add    %ecx,%eax
f0103335:	8a 40 04             	mov    0x4(%eax),%al
f0103338:	84 c0                	test   %al,%al
f010333a:	0f 85 f0 00 00 00    	jne    f0103430 <freeMem+0x187>
			uint32 va2 = env_page_ws_get_virtual_address(e, i);
f0103340:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103343:	83 ec 08             	sub    $0x8,%esp
f0103346:	50                   	push   %eax
f0103347:	ff 75 08             	pushl  0x8(%ebp)
f010334a:	e8 79 04 00 00       	call   f01037c8 <env_page_ws_get_virtual_address>
f010334f:	83 c4 10             	add    $0x10,%esp
f0103352:	89 45 dc             	mov    %eax,-0x24(%ebp)

			if (va2 >= virtual_address && va2 < virtual_address + size) {
f0103355:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103358:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010335b:	0f 82 cf 00 00 00    	jb     f0103430 <freeMem+0x187>
f0103361:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103364:	8b 45 10             	mov    0x10(%ebp),%eax
f0103367:	01 d0                	add    %edx,%eax
f0103369:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010336c:	0f 86 be 00 00 00    	jbe    f0103430 <freeMem+0x187>
				uint32 *ptr_page_table = NULL;
f0103372:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				get_page_table(e->env_page_directory, (void*) va2,
f0103379:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010337c:	8b 45 08             	mov    0x8(%ebp),%eax
f010337f:	8b 40 5c             	mov    0x5c(%eax),%eax
f0103382:	83 ec 04             	sub    $0x4,%esp
f0103385:	8d 4d d4             	lea    -0x2c(%ebp),%ecx
f0103388:	51                   	push   %ecx
f0103389:	52                   	push   %edx
f010338a:	50                   	push   %eax
f010338b:	e8 80 f9 ff ff       	call   f0102d10 <get_page_table>
f0103390:	83 c4 10             	add    $0x10,%esp
						&ptr_page_table);
				unmap_frame(e->env_page_directory, (void*) va2);
f0103393:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0103396:	8b 45 08             	mov    0x8(%ebp),%eax
f0103399:	8b 40 5c             	mov    0x5c(%eax),%eax
f010339c:	83 ec 08             	sub    $0x8,%esp
f010339f:	52                   	push   %edx
f01033a0:	50                   	push   %eax
f01033a1:	e8 24 fd ff ff       	call   f01030ca <unmap_frame>
f01033a6:	83 c4 10             	add    $0x10,%esp
				//kfree( (void*) va2);
				env_page_ws_clear_entry(e, i);
f01033a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01033ac:	83 ec 08             	sub    $0x8,%esp
f01033af:	50                   	push   %eax
f01033b0:	ff 75 08             	pushl  0x8(%ebp)
f01033b3:	e8 96 03 00 00       	call   f010374e <env_page_ws_clear_entry>
f01033b8:	83 c4 10             	add    $0x10,%esp
                pt_clear_page_table_entry(e,va2);
f01033bb:	83 ec 08             	sub    $0x8,%esp
f01033be:	ff 75 dc             	pushl  -0x24(%ebp)
f01033c1:	ff 75 08             	pushl  0x8(%ebp)
f01033c4:	e8 f4 0d 00 00       	call   f01041bd <pt_clear_page_table_entry>
f01033c9:	83 c4 10             	add    $0x10,%esp

				uint32 f = 0;
f01033cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				uint32 k = 0;
f01033d3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				for (; k < 1024; k++) {
f01033da:	eb 25                	jmp    f0103401 <freeMem+0x158>

					int c=(ptr_page_table[k]>>12);
f01033dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01033df:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01033e2:	c1 e2 02             	shl    $0x2,%edx
f01033e5:	01 d0                	add    %edx,%eax
f01033e7:	8b 00                	mov    (%eax),%eax
f01033e9:	c1 e8 0c             	shr    $0xc,%eax
f01033ec:	89 45 d8             	mov    %eax,-0x28(%ebp)
					if (c != 0) {
f01033ef:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01033f3:	74 09                	je     f01033fe <freeMem+0x155>
						f = 1;
f01033f5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

						break;
f01033fc:	eb 0c                	jmp    f010340a <freeMem+0x161>
				env_page_ws_clear_entry(e, i);
                pt_clear_page_table_entry(e,va2);

				uint32 f = 0;
				uint32 k = 0;
				for (; k < 1024; k++) {
f01033fe:	ff 45 e8             	incl   -0x18(%ebp)
f0103401:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
f0103408:	76 d2                	jbe    f01033dc <freeMem+0x133>
						f = 1;

						break;
					}
				}
				if (f == 0) {
f010340a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010340e:	75 20                	jne    f0103430 <freeMem+0x187>
					//3. Removes ONLY the empty page tables (i.e. not used) (no pages are mapped in the table)
					kfree((void*) ptr_page_table);
f0103410:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103413:	83 ec 0c             	sub    $0xc,%esp
f0103416:	50                   	push   %eax
f0103417:	e8 82 7c 00 00       	call   f010b09e <kfree>
f010341c:	83 c4 10             	add    $0x10,%esp
					pd_clear_page_dir_entry(e, va2);
f010341f:	83 ec 08             	sub    $0x8,%esp
f0103422:	ff 75 dc             	pushl  -0x24(%ebp)
f0103425:	ff 75 08             	pushl  0x8(%ebp)
f0103428:	e8 54 0b 00 00       	call   f0103f81 <pd_clear_page_dir_entry>
f010342d:	83 c4 10             	add    $0x10,%esp

	//2. Free ONLY pages that are resident in the working set from the memory
	//int j = 0;


	for (i = 0; i <e->page_WS_max_size; i++) {
f0103430:	ff 45 f4             	incl   -0xc(%ebp)
f0103433:	8b 45 08             	mov    0x8(%ebp),%eax
f0103436:	8b 50 74             	mov    0x74(%eax),%edx
f0103439:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010343c:	39 c2                	cmp    %eax,%edx
f010343e:	0f 87 dd fe ff ff    	ja     f0103321 <freeMem+0x78>
f0103444:	eb 01                	jmp    f0103447 <freeMem+0x19e>

	//virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
	size = ROUNDUP(size, PAGE_SIZE);

	if (size == 0) {
		return;
f0103446:	90                   	nop
	}




}
f0103447:	c9                   	leave  
f0103448:	c3                   	ret    

f0103449 <__freeMem_with_buffering>:


void __freeMem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size) {
f0103449:	55                   	push   %ebp
f010344a:	89 e5                	mov    %esp,%ebp

}
f010344c:	90                   	nop
f010344d:	5d                   	pop    %ebp
f010344e:	c3                   	ret    

f010344f <moveMem>:

//================= [BONUS] =====================
// [3] moveMem

void moveMem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010344f:	55                   	push   %ebp
f0103450:	89 e5                	mov    %esp,%ebp
f0103452:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT 2016 - BONUS4] realloc() [Kernel Side]
	//your code is here, remove the panic and write your code
	panic("moveMem() is not implemented yet...!!");
f0103455:	83 ec 04             	sub    $0x4,%esp
f0103458:	68 6c 09 11 f0       	push   $0xf011096c
f010345d:	68 87 03 00 00       	push   $0x387
f0103462:	68 a1 08 11 f0       	push   $0xf01108a1
f0103467:	e8 f0 cc ff ff       	call   f010015c <_panic>

f010346c <calculate_required_frames>:
// calculate_required_frames:
// calculates the new allocatino size required for given address+size,
// we are not interested in knowing if pages or tables actually exist in memory or the page file,
// we are interested in knowing whether they are allocated or not.
uint32 calculate_required_frames(uint32* ptr_page_directory, uint32 start_virtual_address, uint32 size)
{
f010346c:	55                   	push   %ebp
f010346d:	89 e5                	mov    %esp,%ebp
f010346f:	83 ec 28             	sub    $0x28,%esp
	LOG_STATMENT(cprintf("calculate_required_frames: Starting at address %x",start_virtual_address));
	//calculate the required page tables
	uint32 number_of_tables = 0;
f0103472:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	long i = 0;
f0103479:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32 current_virtual_address = ROUNDDOWN(start_virtual_address, PAGE_SIZE*1024);
f0103480:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103483:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103486:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103489:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010348e:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for(; current_virtual_address < (start_virtual_address+size); current_virtual_address+= PAGE_SIZE*1024)
f0103491:	eb 27                	jmp    f01034ba <calculate_required_frames+0x4e>
	{
		uint32 *ptr_page_table;
		get_page_table(ptr_page_directory, (void*) current_virtual_address, &ptr_page_table);
f0103493:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103496:	83 ec 04             	sub    $0x4,%esp
f0103499:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010349c:	52                   	push   %edx
f010349d:	50                   	push   %eax
f010349e:	ff 75 08             	pushl  0x8(%ebp)
f01034a1:	e8 6a f8 ff ff       	call   f0102d10 <get_page_table>
f01034a6:	83 c4 10             	add    $0x10,%esp

		if(ptr_page_table == 0)
f01034a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01034ac:	85 c0                	test   %eax,%eax
f01034ae:	75 03                	jne    f01034b3 <calculate_required_frames+0x47>
		{
			(number_of_tables)++;
f01034b0:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 number_of_tables = 0;

	long i = 0;
	uint32 current_virtual_address = ROUNDDOWN(start_virtual_address, PAGE_SIZE*1024);

	for(; current_virtual_address < (start_virtual_address+size); current_virtual_address+= PAGE_SIZE*1024)
f01034b3:	81 45 f0 00 00 40 00 	addl   $0x400000,-0x10(%ebp)
f01034ba:	8b 55 0c             	mov    0xc(%ebp),%edx
f01034bd:	8b 45 10             	mov    0x10(%ebp),%eax
f01034c0:	01 d0                	add    %edx,%eax
f01034c2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034c5:	77 cc                	ja     f0103493 <calculate_required_frames+0x27>
			(number_of_tables)++;
		}
	}

	//calc the required page frames
	uint32 number_of_pages = 0;
f01034c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	current_virtual_address = ROUNDDOWN(start_virtual_address, PAGE_SIZE);
f01034ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01034d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01034d7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01034dc:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for(; current_virtual_address < (start_virtual_address+size); current_virtual_address+= PAGE_SIZE)
f01034df:	eb 24                	jmp    f0103505 <calculate_required_frames+0x99>
	{
		uint32 *ptr_page_table;
		if (get_frame_info(ptr_page_directory, (void*) current_virtual_address, &ptr_page_table) == 0)
f01034e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034e4:	83 ec 04             	sub    $0x4,%esp
f01034e7:	8d 55 d8             	lea    -0x28(%ebp),%edx
f01034ea:	52                   	push   %edx
f01034eb:	50                   	push   %eax
f01034ec:	ff 75 08             	pushl  0x8(%ebp)
f01034ef:	e8 66 fb ff ff       	call   f010305a <get_frame_info>
f01034f4:	83 c4 10             	add    $0x10,%esp
f01034f7:	85 c0                	test   %eax,%eax
f01034f9:	75 03                	jne    f01034fe <calculate_required_frames+0x92>
		{
			(number_of_pages)++;
f01034fb:	ff 45 ec             	incl   -0x14(%ebp)

	//calc the required page frames
	uint32 number_of_pages = 0;
	current_virtual_address = ROUNDDOWN(start_virtual_address, PAGE_SIZE);

	for(; current_virtual_address < (start_virtual_address+size); current_virtual_address+= PAGE_SIZE)
f01034fe:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0103505:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103508:	8b 45 10             	mov    0x10(%ebp),%eax
f010350b:	01 d0                	add    %edx,%eax
f010350d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103510:	77 cf                	ja     f01034e1 <calculate_required_frames+0x75>
		}
	}

	//return total number of frames
	LOG_STATMENT(cprintf("calculate_required_frames: Done!"));
	return number_of_tables+number_of_pages;
f0103512:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103515:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103518:	01 d0                	add    %edx,%eax
}
f010351a:	c9                   	leave  
f010351b:	c3                   	ret    

f010351c <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f010351c:	55                   	push   %ebp
f010351d:	89 e5                	mov    %esp,%ebp
f010351f:	57                   	push   %edi
f0103520:	56                   	push   %esi
f0103521:	53                   	push   %ebx
f0103522:	83 ec 20             	sub    $0x20,%esp
	}
	cprintf("finished loop detction\n");
	 */
	//calculate the free frames from the free frame list
	struct Frame_Info *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f0103525:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	uint32 totalFreeBuffered = 0 ;
f010352c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32 totalModified = 0 ;
f0103533:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)


	LIST_FOREACH(ptr, &free_frame_list)
f010353a:	a1 74 52 45 f0       	mov    0xf0455274,%eax
f010353f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103542:	eb 1a                	jmp    f010355e <calculate_available_frames+0x42>
	{
		if (ptr->isBuffered)
f0103544:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103547:	8a 40 14             	mov    0x14(%eax),%al
f010354a:	84 c0                	test   %al,%al
f010354c:	74 05                	je     f0103553 <calculate_available_frames+0x37>
			totalFreeBuffered++ ;
f010354e:	ff 45 e8             	incl   -0x18(%ebp)
f0103551:	eb 03                	jmp    f0103556 <calculate_available_frames+0x3a>
		else
			totalFreeUnBuffered++ ;
f0103553:	ff 45 ec             	incl   -0x14(%ebp)
	uint32 totalFreeUnBuffered = 0 ;
	uint32 totalFreeBuffered = 0 ;
	uint32 totalModified = 0 ;


	LIST_FOREACH(ptr, &free_frame_list)
f0103556:	a1 7c 52 45 f0       	mov    0xf045527c,%eax
f010355b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010355e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103562:	74 07                	je     f010356b <calculate_available_frames+0x4f>
f0103564:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103567:	8b 00                	mov    (%eax),%eax
f0103569:	eb 05                	jmp    f0103570 <calculate_available_frames+0x54>
f010356b:	b8 00 00 00 00       	mov    $0x0,%eax
f0103570:	a3 7c 52 45 f0       	mov    %eax,0xf045527c
f0103575:	a1 7c 52 45 f0       	mov    0xf045527c,%eax
f010357a:	85 c0                	test   %eax,%eax
f010357c:	75 c6                	jne    f0103544 <calculate_available_frames+0x28>
f010357e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103582:	75 c0                	jne    f0103544 <calculate_available_frames+0x28>
			totalFreeUnBuffered++ ;
	}



	LIST_FOREACH(ptr, &modified_frame_list)
f0103584:	a1 60 52 45 f0       	mov    0xf0455260,%eax
f0103589:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010358c:	eb 0b                	jmp    f0103599 <calculate_available_frames+0x7d>
	{
		totalModified++ ;
f010358e:	ff 45 e4             	incl   -0x1c(%ebp)
			totalFreeUnBuffered++ ;
	}



	LIST_FOREACH(ptr, &modified_frame_list)
f0103591:	a1 68 52 45 f0       	mov    0xf0455268,%eax
f0103596:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103599:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010359d:	74 07                	je     f01035a6 <calculate_available_frames+0x8a>
f010359f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01035a2:	8b 00                	mov    (%eax),%eax
f01035a4:	eb 05                	jmp    f01035ab <calculate_available_frames+0x8f>
f01035a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01035ab:	a3 68 52 45 f0       	mov    %eax,0xf0455268
f01035b0:	a1 68 52 45 f0       	mov    0xf0455268,%eax
f01035b5:	85 c0                	test   %eax,%eax
f01035b7:	75 d5                	jne    f010358e <calculate_available_frames+0x72>
f01035b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01035bd:	75 cf                	jne    f010358e <calculate_available_frames+0x72>
		totalModified++ ;
	}


	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f01035bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01035c2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f01035c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01035c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	counters.modified = totalModified;
f01035cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return counters;
f01035d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01035d4:	89 c3                	mov    %eax,%ebx
f01035d6:	8d 45 d8             	lea    -0x28(%ebp),%eax
f01035d9:	ba 03 00 00 00       	mov    $0x3,%edx
f01035de:	89 df                	mov    %ebx,%edi
f01035e0:	89 c6                	mov    %eax,%esi
f01035e2:	89 d1                	mov    %edx,%ecx
f01035e4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f01035e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01035e9:	83 c4 20             	add    $0x20,%esp
f01035ec:	5b                   	pop    %ebx
f01035ed:	5e                   	pop    %esi
f01035ee:	5f                   	pop    %edi
f01035ef:	5d                   	pop    %ebp
f01035f0:	c2 04 00             	ret    $0x4

f01035f3 <env_page_ws_get_size>:

///============================================================================================
/// Dealing with environment working set

inline uint32 env_page_ws_get_size(struct Env *e)
{
f01035f3:	55                   	push   %ebp
f01035f4:	89 e5                	mov    %esp,%ebp
f01035f6:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f01035f9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0103600:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<e->page_WS_max_size; i++) if(e->ptr_pageWorkingSet[i].empty == 0) counter++;
f0103607:	eb 21                	jmp    f010362a <env_page_ws_get_size+0x37>
f0103609:	8b 45 08             	mov    0x8(%ebp),%eax
f010360c:	8b 48 78             	mov    0x78(%eax),%ecx
f010360f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0103612:	89 d0                	mov    %edx,%eax
f0103614:	01 c0                	add    %eax,%eax
f0103616:	01 d0                	add    %edx,%eax
f0103618:	c1 e0 02             	shl    $0x2,%eax
f010361b:	01 c8                	add    %ecx,%eax
f010361d:	8a 40 04             	mov    0x4(%eax),%al
f0103620:	84 c0                	test   %al,%al
f0103622:	75 03                	jne    f0103627 <env_page_ws_get_size+0x34>
f0103624:	ff 45 f8             	incl   -0x8(%ebp)
f0103627:	ff 45 fc             	incl   -0x4(%ebp)
f010362a:	8b 45 08             	mov    0x8(%ebp),%eax
f010362d:	8b 50 74             	mov    0x74(%eax),%edx
f0103630:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0103633:	39 c2                	cmp    %eax,%edx
f0103635:	77 d2                	ja     f0103609 <env_page_ws_get_size+0x16>
	return counter;
f0103637:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010363a:	c9                   	leave  
f010363b:	c3                   	ret    

f010363c <env_page_ws_invalidate>:

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010363c:	55                   	push   %ebp
f010363d:	89 e5                	mov    %esp,%ebp
f010363f:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0103642:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<e->page_WS_max_size; i++)
f0103649:	eb 4c                	jmp    f0103697 <env_page_ws_invalidate+0x5b>
	{
		if(ROUNDDOWN(e->ptr_pageWorkingSet[i].virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010364b:	8b 45 08             	mov    0x8(%ebp),%eax
f010364e:	8b 48 78             	mov    0x78(%eax),%ecx
f0103651:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103654:	89 d0                	mov    %edx,%eax
f0103656:	01 c0                	add    %eax,%eax
f0103658:	01 d0                	add    %edx,%eax
f010365a:	c1 e0 02             	shl    $0x2,%eax
f010365d:	01 c8                	add    %ecx,%eax
f010365f:	8b 00                	mov    (%eax),%eax
f0103661:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103664:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103667:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010366c:	89 c2                	mov    %eax,%edx
f010366e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103671:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103674:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103677:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010367c:	39 c2                	cmp    %eax,%edx
f010367e:	75 14                	jne    f0103694 <env_page_ws_invalidate+0x58>
		{
			env_page_ws_clear_entry(e, i);
f0103680:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103683:	83 ec 08             	sub    $0x8,%esp
f0103686:	50                   	push   %eax
f0103687:	ff 75 08             	pushl  0x8(%ebp)
f010368a:	e8 bf 00 00 00       	call   f010374e <env_page_ws_clear_entry>
f010368f:	83 c4 10             	add    $0x10,%esp
			break;
f0103692:	eb 10                	jmp    f01036a4 <env_page_ws_invalidate+0x68>
}

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<e->page_WS_max_size; i++)
f0103694:	ff 45 f4             	incl   -0xc(%ebp)
f0103697:	8b 45 08             	mov    0x8(%ebp),%eax
f010369a:	8b 50 74             	mov    0x74(%eax),%edx
f010369d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01036a0:	39 c2                	cmp    %eax,%edx
f01036a2:	77 a7                	ja     f010364b <env_page_ws_invalidate+0xf>
		{
			env_page_ws_clear_entry(e, i);
			break;
		}
	}
}
f01036a4:	90                   	nop
f01036a5:	c9                   	leave  
f01036a6:	c3                   	ret    

f01036a7 <env_page_ws_set_entry>:

inline void env_page_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f01036a7:	55                   	push   %ebp
f01036a8:	89 e5                	mov    %esp,%ebp
f01036aa:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < e->page_WS_max_size);
f01036ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01036b0:	8b 40 74             	mov    0x74(%eax),%eax
f01036b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01036b6:	77 19                	ja     f01036d1 <env_page_ws_set_entry+0x2a>
f01036b8:	68 94 09 11 f0       	push   $0xf0110994
f01036bd:	68 ca 09 11 f0       	push   $0xf01109ca
f01036c2:	68 17 04 00 00       	push   $0x417
f01036c7:	68 a1 08 11 f0       	push   $0xf01108a1
f01036cc:	e8 8b ca ff ff       	call   f010015c <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f01036d1:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01036d8:	76 19                	jbe    f01036f3 <env_page_ws_set_entry+0x4c>
f01036da:	68 e0 09 11 f0       	push   $0xf01109e0
f01036df:	68 ca 09 11 f0       	push   $0xf01109ca
f01036e4:	68 18 04 00 00       	push   $0x418
f01036e9:	68 a1 08 11 f0       	push   $0xf01108a1
f01036ee:	e8 69 ca ff ff       	call   f010015c <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f01036f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01036f6:	8b 48 78             	mov    0x78(%eax),%ecx
f01036f9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01036fc:	89 d0                	mov    %edx,%eax
f01036fe:	01 c0                	add    %eax,%eax
f0103700:	01 d0                	add    %edx,%eax
f0103702:	c1 e0 02             	shl    $0x2,%eax
f0103705:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0103708:	8b 45 10             	mov    0x10(%ebp),%eax
f010370b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010370e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103711:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103716:	89 02                	mov    %eax,(%edx)
	e->ptr_pageWorkingSet[entry_index].empty = 0;
f0103718:	8b 45 08             	mov    0x8(%ebp),%eax
f010371b:	8b 48 78             	mov    0x78(%eax),%ecx
f010371e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103721:	89 d0                	mov    %edx,%eax
f0103723:	01 c0                	add    %eax,%eax
f0103725:	01 d0                	add    %edx,%eax
f0103727:	c1 e0 02             	shl    $0x2,%eax
f010372a:	01 c8                	add    %ecx,%eax
f010372c:	c6 40 04 00          	movb   $0x0,0x4(%eax)

	e->ptr_pageWorkingSet[entry_index].time_stamp = 0x80000000;
f0103730:	8b 45 08             	mov    0x8(%ebp),%eax
f0103733:	8b 48 78             	mov    0x78(%eax),%ecx
f0103736:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103739:	89 d0                	mov    %edx,%eax
f010373b:	01 c0                	add    %eax,%eax
f010373d:	01 d0                	add    %edx,%eax
f010373f:	c1 e0 02             	shl    $0x2,%eax
f0103742:	01 c8                	add    %ecx,%eax
f0103744:	c7 40 08 00 00 00 80 	movl   $0x80000000,0x8(%eax)
	//e->ptr_pageWorkingSet[entry_index].time_stamp = time;
	return;
f010374b:	90                   	nop
}
f010374c:	c9                   	leave  
f010374d:	c3                   	ret    

f010374e <env_page_ws_clear_entry>:

inline void env_page_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010374e:	55                   	push   %ebp
f010374f:	89 e5                	mov    %esp,%ebp
f0103751:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0103754:	8b 45 08             	mov    0x8(%ebp),%eax
f0103757:	8b 40 74             	mov    0x74(%eax),%eax
f010375a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010375d:	77 19                	ja     f0103778 <env_page_ws_clear_entry+0x2a>
f010375f:	68 14 0a 11 f0       	push   $0xf0110a14
f0103764:	68 ca 09 11 f0       	push   $0xf01109ca
f0103769:	68 23 04 00 00       	push   $0x423
f010376e:	68 a1 08 11 f0       	push   $0xf01108a1
f0103773:	e8 e4 c9 ff ff       	call   f010015c <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = 0;
f0103778:	8b 45 08             	mov    0x8(%ebp),%eax
f010377b:	8b 48 78             	mov    0x78(%eax),%ecx
f010377e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103781:	89 d0                	mov    %edx,%eax
f0103783:	01 c0                	add    %eax,%eax
f0103785:	01 d0                	add    %edx,%eax
f0103787:	c1 e0 02             	shl    $0x2,%eax
f010378a:	01 c8                	add    %ecx,%eax
f010378c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 1;
f0103792:	8b 45 08             	mov    0x8(%ebp),%eax
f0103795:	8b 48 78             	mov    0x78(%eax),%ecx
f0103798:	8b 55 0c             	mov    0xc(%ebp),%edx
f010379b:	89 d0                	mov    %edx,%eax
f010379d:	01 c0                	add    %eax,%eax
f010379f:	01 d0                	add    %edx,%eax
f01037a1:	c1 e0 02             	shl    $0x2,%eax
f01037a4:	01 c8                	add    %ecx,%eax
f01037a6:	c6 40 04 01          	movb   $0x1,0x4(%eax)
	e->ptr_pageWorkingSet[entry_index].time_stamp = 0;
f01037aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01037ad:	8b 48 78             	mov    0x78(%eax),%ecx
f01037b0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01037b3:	89 d0                	mov    %edx,%eax
f01037b5:	01 c0                	add    %eax,%eax
f01037b7:	01 d0                	add    %edx,%eax
f01037b9:	c1 e0 02             	shl    $0x2,%eax
f01037bc:	01 c8                	add    %ecx,%eax
f01037be:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
f01037c5:	90                   	nop
f01037c6:	c9                   	leave  
f01037c7:	c3                   	ret    

f01037c8 <env_page_ws_get_virtual_address>:

inline uint32 env_page_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f01037c8:	55                   	push   %ebp
f01037c9:	89 e5                	mov    %esp,%ebp
f01037cb:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f01037ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01037d1:	8b 40 74             	mov    0x74(%eax),%eax
f01037d4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01037d7:	77 19                	ja     f01037f2 <env_page_ws_get_virtual_address+0x2a>
f01037d9:	68 14 0a 11 f0       	push   $0xf0110a14
f01037de:	68 ca 09 11 f0       	push   $0xf01109ca
f01037e3:	68 2b 04 00 00       	push   $0x42b
f01037e8:	68 a1 08 11 f0       	push   $0xf01108a1
f01037ed:	e8 6a c9 ff ff       	call   f010015c <_panic>
	return ROUNDDOWN(e->ptr_pageWorkingSet[entry_index].virtual_address,PAGE_SIZE);
f01037f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01037f5:	8b 48 78             	mov    0x78(%eax),%ecx
f01037f8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01037fb:	89 d0                	mov    %edx,%eax
f01037fd:	01 c0                	add    %eax,%eax
f01037ff:	01 d0                	add    %edx,%eax
f0103801:	c1 e0 02             	shl    $0x2,%eax
f0103804:	01 c8                	add    %ecx,%eax
f0103806:	8b 00                	mov    (%eax),%eax
f0103808:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010380b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010380e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0103813:	c9                   	leave  
f0103814:	c3                   	ret    

f0103815 <env_page_ws_get_time_stamp>:

inline uint32 env_page_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0103815:	55                   	push   %ebp
f0103816:	89 e5                	mov    %esp,%ebp
f0103818:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f010381b:	8b 45 08             	mov    0x8(%ebp),%eax
f010381e:	8b 40 74             	mov    0x74(%eax),%eax
f0103821:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0103824:	77 19                	ja     f010383f <env_page_ws_get_time_stamp+0x2a>
f0103826:	68 14 0a 11 f0       	push   $0xf0110a14
f010382b:	68 ca 09 11 f0       	push   $0xf01109ca
f0103830:	68 31 04 00 00       	push   $0x431
f0103835:	68 a1 08 11 f0       	push   $0xf01108a1
f010383a:	e8 1d c9 ff ff       	call   f010015c <_panic>
	return e->ptr_pageWorkingSet[entry_index].time_stamp;
f010383f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103842:	8b 48 78             	mov    0x78(%eax),%ecx
f0103845:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103848:	89 d0                	mov    %edx,%eax
f010384a:	01 c0                	add    %eax,%eax
f010384c:	01 d0                	add    %edx,%eax
f010384e:	c1 e0 02             	shl    $0x2,%eax
f0103851:	01 c8                	add    %ecx,%eax
f0103853:	8b 40 08             	mov    0x8(%eax),%eax
}
f0103856:	c9                   	leave  
f0103857:	c3                   	ret    

f0103858 <env_page_ws_is_entry_empty>:

inline uint32 env_page_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0103858:	55                   	push   %ebp
f0103859:	89 e5                	mov    %esp,%ebp
	return e->ptr_pageWorkingSet[entry_index].empty;
f010385b:	8b 45 08             	mov    0x8(%ebp),%eax
f010385e:	8b 48 78             	mov    0x78(%eax),%ecx
f0103861:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103864:	89 d0                	mov    %edx,%eax
f0103866:	01 c0                	add    %eax,%eax
f0103868:	01 d0                	add    %edx,%eax
f010386a:	c1 e0 02             	shl    $0x2,%eax
f010386d:	01 c8                	add    %ecx,%eax
f010386f:	8a 40 04             	mov    0x4(%eax),%al
f0103872:	0f b6 c0             	movzbl %al,%eax
}
f0103875:	5d                   	pop    %ebp
f0103876:	c3                   	ret    

f0103877 <env_page_ws_print>:

void env_page_ws_print(struct Env *curenv)
{
f0103877:	55                   	push   %ebp
f0103878:	89 e5                	mov    %esp,%ebp
f010387a:	83 ec 28             	sub    $0x28,%esp
	uint32 i;
	cprintf("PAGE WS:\n");
f010387d:	83 ec 0c             	sub    $0xc,%esp
f0103880:	68 4c 0a 11 f0       	push   $0xf0110a4c
f0103885:	e8 d1 27 00 00       	call   f010605b <cprintf>
f010388a:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< (curenv->page_WS_max_size); i++ )
f010388d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103894:	e9 4e 01 00 00       	jmp    f01039e7 <env_page_ws_print+0x170>
	{
		if (curenv->ptr_pageWorkingSet[i].empty)
f0103899:	8b 45 08             	mov    0x8(%ebp),%eax
f010389c:	8b 48 78             	mov    0x78(%eax),%ecx
f010389f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01038a2:	89 d0                	mov    %edx,%eax
f01038a4:	01 c0                	add    %eax,%eax
f01038a6:	01 d0                	add    %edx,%eax
f01038a8:	c1 e0 02             	shl    $0x2,%eax
f01038ab:	01 c8                	add    %ecx,%eax
f01038ad:	8a 40 04             	mov    0x4(%eax),%al
f01038b0:	84 c0                	test   %al,%al
f01038b2:	74 43                	je     f01038f7 <env_page_ws_print+0x80>
		{
			cprintf("EMPTY LOCATION");
f01038b4:	83 ec 0c             	sub    $0xc,%esp
f01038b7:	68 56 0a 11 f0       	push   $0xf0110a56
f01038bc:	e8 9a 27 00 00       	call   f010605b <cprintf>
f01038c1:	83 c4 10             	add    $0x10,%esp
			if(i==curenv->page_last_WS_index )
f01038c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01038c7:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f01038cd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01038d0:	75 10                	jne    f01038e2 <env_page_ws_print+0x6b>
			{
				cprintf("		<--");
f01038d2:	83 ec 0c             	sub    $0xc,%esp
f01038d5:	68 65 0a 11 f0       	push   $0xf0110a65
f01038da:	e8 7c 27 00 00       	call   f010605b <cprintf>
f01038df:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f01038e2:	83 ec 0c             	sub    $0xc,%esp
f01038e5:	68 6b 0a 11 f0       	push   $0xf0110a6b
f01038ea:	e8 6c 27 00 00       	call   f010605b <cprintf>
f01038ef:	83 c4 10             	add    $0x10,%esp
			continue;
f01038f2:	e9 ed 00 00 00       	jmp    f01039e4 <env_page_ws_print+0x16d>
		}
		uint32 virtual_address = curenv->ptr_pageWorkingSet[i].virtual_address;
f01038f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01038fa:	8b 48 78             	mov    0x78(%eax),%ecx
f01038fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103900:	89 d0                	mov    %edx,%eax
f0103902:	01 c0                	add    %eax,%eax
f0103904:	01 d0                	add    %edx,%eax
f0103906:	c1 e0 02             	shl    $0x2,%eax
f0103909:	01 c8                	add    %ecx,%eax
f010390b:	8b 00                	mov    (%eax),%eax
f010390d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 time_stamp = curenv->ptr_pageWorkingSet[i].time_stamp;
f0103910:	8b 45 08             	mov    0x8(%ebp),%eax
f0103913:	8b 48 78             	mov    0x78(%eax),%ecx
f0103916:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103919:	89 d0                	mov    %edx,%eax
f010391b:	01 c0                	add    %eax,%eax
f010391d:	01 d0                	add    %edx,%eax
f010391f:	c1 e0 02             	shl    $0x2,%eax
f0103922:	01 c8                	add    %ecx,%eax
f0103924:	8b 40 08             	mov    0x8(%eax),%eax
f0103927:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 perm = pt_get_page_permissions(curenv, virtual_address) ;
f010392a:	83 ec 08             	sub    $0x8,%esp
f010392d:	ff 75 f0             	pushl  -0x10(%ebp)
f0103930:	ff 75 08             	pushl  0x8(%ebp)
f0103933:	e8 e3 09 00 00       	call   f010431b <pt_get_page_permissions>
f0103938:	83 c4 10             	add    $0x10,%esp
f010393b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010393e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103941:	83 e0 40             	and    $0x40,%eax
f0103944:	85 c0                	test   %eax,%eax
f0103946:	0f 95 c0             	setne  %al
f0103949:	88 45 e7             	mov    %al,-0x19(%ebp)
		char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010394c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010394f:	83 e0 20             	and    $0x20,%eax
f0103952:	85 c0                	test   %eax,%eax
f0103954:	0f 95 c0             	setne  %al
f0103957:	88 45 e6             	mov    %al,-0x1a(%ebp)
		char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010395a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010395d:	25 00 02 00 00       	and    $0x200,%eax
f0103962:	85 c0                	test   %eax,%eax
f0103964:	0f 95 c0             	setne  %al
f0103967:	88 45 e5             	mov    %al,-0x1b(%ebp)


		cprintf("address @ %d = %x",i, curenv->ptr_pageWorkingSet[i].virtual_address);
f010396a:	8b 45 08             	mov    0x8(%ebp),%eax
f010396d:	8b 48 78             	mov    0x78(%eax),%ecx
f0103970:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103973:	89 d0                	mov    %edx,%eax
f0103975:	01 c0                	add    %eax,%eax
f0103977:	01 d0                	add    %edx,%eax
f0103979:	c1 e0 02             	shl    $0x2,%eax
f010397c:	01 c8                	add    %ecx,%eax
f010397e:	8b 00                	mov    (%eax),%eax
f0103980:	83 ec 04             	sub    $0x4,%esp
f0103983:	50                   	push   %eax
f0103984:	ff 75 f4             	pushl  -0xc(%ebp)
f0103987:	68 6d 0a 11 f0       	push   $0xf0110a6d
f010398c:	e8 ca 26 00 00       	call   f010605b <cprintf>
f0103991:	83 c4 10             	add    $0x10,%esp

		cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x", isUsed, isModified, isBuffered, time_stamp) ;
f0103994:	0f be 4d e5          	movsbl -0x1b(%ebp),%ecx
f0103998:	0f be 55 e7          	movsbl -0x19(%ebp),%edx
f010399c:	0f be 45 e6          	movsbl -0x1a(%ebp),%eax
f01039a0:	83 ec 0c             	sub    $0xc,%esp
f01039a3:	ff 75 ec             	pushl  -0x14(%ebp)
f01039a6:	51                   	push   %ecx
f01039a7:	52                   	push   %edx
f01039a8:	50                   	push   %eax
f01039a9:	68 80 0a 11 f0       	push   $0xf0110a80
f01039ae:	e8 a8 26 00 00       	call   f010605b <cprintf>
f01039b3:	83 c4 20             	add    $0x20,%esp

		if(i==curenv->page_last_WS_index )
f01039b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01039b9:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f01039bf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01039c2:	75 10                	jne    f01039d4 <env_page_ws_print+0x15d>
		{
			cprintf(" <--");
f01039c4:	83 ec 0c             	sub    $0xc,%esp
f01039c7:	68 b7 0a 11 f0       	push   $0xf0110ab7
f01039cc:	e8 8a 26 00 00       	call   f010605b <cprintf>
f01039d1:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f01039d4:	83 ec 0c             	sub    $0xc,%esp
f01039d7:	68 6b 0a 11 f0       	push   $0xf0110a6b
f01039dc:	e8 7a 26 00 00       	call   f010605b <cprintf>
f01039e1:	83 c4 10             	add    $0x10,%esp

void env_page_ws_print(struct Env *curenv)
{
	uint32 i;
	cprintf("PAGE WS:\n");
	for(i=0; i< (curenv->page_WS_max_size); i++ )
f01039e4:	ff 45 f4             	incl   -0xc(%ebp)
f01039e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01039ea:	8b 40 74             	mov    0x74(%eax),%eax
f01039ed:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01039f0:	0f 87 a3 fe ff ff    	ja     f0103899 <env_page_ws_print+0x22>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f01039f6:	90                   	nop
f01039f7:	c9                   	leave  
f01039f8:	c3                   	ret    

f01039f9 <env_table_ws_print>:

// Table Working Set =========================================================

void env_table_ws_print(struct Env *curenv)
{
f01039f9:	55                   	push   %ebp
f01039fa:	89 e5                	mov    %esp,%ebp
f01039fc:	53                   	push   %ebx
f01039fd:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f0103a00:	83 ec 0c             	sub    $0xc,%esp
f0103a03:	68 bc 0a 11 f0       	push   $0xf0110abc
f0103a08:	e8 4e 26 00 00       	call   f010605b <cprintf>
f0103a0d:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f0103a10:	83 ec 0c             	sub    $0xc,%esp
f0103a13:	68 f1 0a 11 f0       	push   $0xf0110af1
f0103a18:	e8 3e 26 00 00       	call   f010605b <cprintf>
f0103a1d:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0103a20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103a27:	e9 0c 01 00 00       	jmp    f0103b38 <env_table_ws_print+0x13f>
	{
		if (curenv->__ptr_tws[i].empty)
f0103a2c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103a2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103a32:	89 d0                	mov    %edx,%eax
f0103a34:	01 c0                	add    %eax,%eax
f0103a36:	01 d0                	add    %edx,%eax
f0103a38:	c1 e0 02             	shl    $0x2,%eax
f0103a3b:	01 c8                	add    %ecx,%eax
f0103a3d:	83 e8 80             	sub    $0xffffff80,%eax
f0103a40:	8a 00                	mov    (%eax),%al
f0103a42:	84 c0                	test   %al,%al
f0103a44:	74 43                	je     f0103a89 <env_table_ws_print+0x90>
		{
			cprintf("EMPTY LOCATION");
f0103a46:	83 ec 0c             	sub    $0xc,%esp
f0103a49:	68 56 0a 11 f0       	push   $0xf0110a56
f0103a4e:	e8 08 26 00 00       	call   f010605b <cprintf>
f0103a53:	83 c4 10             	add    $0x10,%esp
			if(i==curenv->table_last_WS_index )
f0103a56:	8b 45 08             	mov    0x8(%ebp),%eax
f0103a59:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
f0103a5f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103a62:	75 10                	jne    f0103a74 <env_table_ws_print+0x7b>
			{
				cprintf("		<--");
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	68 65 0a 11 f0       	push   $0xf0110a65
f0103a6c:	e8 ea 25 00 00       	call   f010605b <cprintf>
f0103a71:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0103a74:	83 ec 0c             	sub    $0xc,%esp
f0103a77:	68 6b 0a 11 f0       	push   $0xf0110a6b
f0103a7c:	e8 da 25 00 00       	call   f010605b <cprintf>
f0103a81:	83 c4 10             	add    $0x10,%esp
			continue;
f0103a84:	e9 ac 00 00 00       	jmp    f0103b35 <env_table_ws_print+0x13c>
		}
		uint32 virtual_address = curenv->__ptr_tws[i].virtual_address;
f0103a89:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103a8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103a8f:	89 d0                	mov    %edx,%eax
f0103a91:	01 c0                	add    %eax,%eax
f0103a93:	01 d0                	add    %edx,%eax
f0103a95:	c1 e0 02             	shl    $0x2,%eax
f0103a98:	01 c8                	add    %ecx,%eax
f0103a9a:	83 c0 7c             	add    $0x7c,%eax
f0103a9d:	8b 00                	mov    (%eax),%eax
f0103a9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, curenv->__ptr_tws[i].virtual_address);
f0103aa2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103aa5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103aa8:	89 d0                	mov    %edx,%eax
f0103aaa:	01 c0                	add    %eax,%eax
f0103aac:	01 d0                	add    %edx,%eax
f0103aae:	c1 e0 02             	shl    $0x2,%eax
f0103ab1:	01 c8                	add    %ecx,%eax
f0103ab3:	83 c0 7c             	add    $0x7c,%eax
f0103ab6:	8b 00                	mov    (%eax),%eax
f0103ab8:	83 ec 04             	sub    $0x4,%esp
f0103abb:	50                   	push   %eax
f0103abc:	ff 75 f4             	pushl  -0xc(%ebp)
f0103abf:	68 fc 0a 11 f0       	push   $0xf0110afc
f0103ac4:	e8 92 25 00 00       	call   f010605b <cprintf>
f0103ac9:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(curenv, virtual_address), curenv->__ptr_tws[i].time_stamp);
f0103acc:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103acf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ad2:	89 d0                	mov    %edx,%eax
f0103ad4:	01 c0                	add    %eax,%eax
f0103ad6:	01 d0                	add    %edx,%eax
f0103ad8:	c1 e0 02             	shl    $0x2,%eax
f0103adb:	01 c8                	add    %ecx,%eax
f0103add:	05 84 00 00 00       	add    $0x84,%eax
f0103ae2:	8b 18                	mov    (%eax),%ebx
f0103ae4:	83 ec 08             	sub    $0x8,%esp
f0103ae7:	ff 75 f0             	pushl  -0x10(%ebp)
f0103aea:	ff 75 08             	pushl  0x8(%ebp)
f0103aed:	e8 29 04 00 00       	call   f0103f1b <pd_is_table_used>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 04             	sub    $0x4,%esp
f0103af8:	53                   	push   %ebx
f0103af9:	50                   	push   %eax
f0103afa:	68 14 0b 11 f0       	push   $0xf0110b14
f0103aff:	e8 57 25 00 00       	call   f010605b <cprintf>
f0103b04:	83 c4 10             	add    $0x10,%esp
		if(i==curenv->table_last_WS_index )
f0103b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b0a:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
f0103b10:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103b13:	75 10                	jne    f0103b25 <env_table_ws_print+0x12c>
		{
			cprintf(" <--");
f0103b15:	83 ec 0c             	sub    $0xc,%esp
f0103b18:	68 b7 0a 11 f0       	push   $0xf0110ab7
f0103b1d:	e8 39 25 00 00       	call   f010605b <cprintf>
f0103b22:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f0103b25:	83 ec 0c             	sub    $0xc,%esp
f0103b28:	68 6b 0a 11 f0       	push   $0xf0110a6b
f0103b2d:	e8 29 25 00 00       	call   f010605b <cprintf>
f0103b32:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *curenv)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0103b35:	ff 45 f4             	incl   -0xc(%ebp)
f0103b38:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0103b3c:	0f 86 ea fe ff ff    	jbe    f0103a2c <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f0103b42:	90                   	nop
f0103b43:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103b46:	c9                   	leave  
f0103b47:	c3                   	ret    

f0103b48 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f0103b48:	55                   	push   %ebp
f0103b49:	89 e5                	mov    %esp,%ebp
f0103b4b:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0103b4e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0103b55:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f0103b5c:	eb 20                	jmp    f0103b7e <env_table_ws_get_size+0x36>
f0103b5e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103b61:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0103b64:	89 d0                	mov    %edx,%eax
f0103b66:	01 c0                	add    %eax,%eax
f0103b68:	01 d0                	add    %edx,%eax
f0103b6a:	c1 e0 02             	shl    $0x2,%eax
f0103b6d:	01 c8                	add    %ecx,%eax
f0103b6f:	83 e8 80             	sub    $0xffffff80,%eax
f0103b72:	8a 00                	mov    (%eax),%al
f0103b74:	84 c0                	test   %al,%al
f0103b76:	75 03                	jne    f0103b7b <env_table_ws_get_size+0x33>
f0103b78:	ff 45 f8             	incl   -0x8(%ebp)
f0103b7b:	ff 45 fc             	incl   -0x4(%ebp)
f0103b7e:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f0103b82:	7e da                	jle    f0103b5e <env_table_ws_get_size+0x16>
	return counter;
f0103b84:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0103b87:	c9                   	leave  
f0103b88:	c3                   	ret    

f0103b89 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0103b89:	55                   	push   %ebp
f0103b8a:	89 e5                	mov    %esp,%ebp
f0103b8c:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0103b8f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f0103b96:	eb 4c                	jmp    f0103be4 <env_table_ws_invalidate+0x5b>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0103b98:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103b9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103b9e:	89 d0                	mov    %edx,%eax
f0103ba0:	01 c0                	add    %eax,%eax
f0103ba2:	01 d0                	add    %edx,%eax
f0103ba4:	c1 e0 02             	shl    $0x2,%eax
f0103ba7:	01 c8                	add    %ecx,%eax
f0103ba9:	83 c0 7c             	add    $0x7c,%eax
f0103bac:	8b 00                	mov    (%eax),%eax
f0103bae:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103bb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103bb4:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0103bb9:	89 c2                	mov    %eax,%edx
f0103bbb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103bbe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103bc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103bc4:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0103bc9:	39 c2                	cmp    %eax,%edx
f0103bcb:	75 14                	jne    f0103be1 <env_table_ws_invalidate+0x58>
		{
			env_table_ws_clear_entry(e, i);
f0103bcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103bd0:	83 ec 08             	sub    $0x8,%esp
f0103bd3:	50                   	push   %eax
f0103bd4:	ff 75 08             	pushl  0x8(%ebp)
f0103bd7:	e8 b8 00 00 00       	call   f0103c94 <env_table_ws_clear_entry>
f0103bdc:	83 c4 10             	add    $0x10,%esp
			break;
f0103bdf:	eb 09                	jmp    f0103bea <env_table_ws_invalidate+0x61>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f0103be1:	ff 45 f4             	incl   -0xc(%ebp)
f0103be4:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0103be8:	7e ae                	jle    f0103b98 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f0103bea:	90                   	nop
f0103beb:	c9                   	leave  
f0103bec:	c3                   	ret    

f0103bed <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f0103bed:	55                   	push   %ebp
f0103bee:	89 e5                	mov    %esp,%ebp
f0103bf0:	53                   	push   %ebx
f0103bf1:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0103bf4:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0103bf8:	76 19                	jbe    f0103c13 <env_table_ws_set_entry+0x26>
f0103bfa:	68 38 0b 11 f0       	push   $0xf0110b38
f0103bff:	68 ca 09 11 f0       	push   $0xf01109ca
f0103c04:	68 94 04 00 00       	push   $0x494
f0103c09:	68 a1 08 11 f0       	push   $0xf01108a1
f0103c0e:	e8 49 c5 ff ff       	call   f010015c <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0103c13:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0103c1a:	76 19                	jbe    f0103c35 <env_table_ws_set_entry+0x48>
f0103c1c:	68 e0 09 11 f0       	push   $0xf01109e0
f0103c21:	68 ca 09 11 f0       	push   $0xf01109ca
f0103c26:	68 95 04 00 00       	push   $0x495
f0103c2b:	68 a1 08 11 f0       	push   $0xf01108a1
f0103c30:	e8 27 c5 ff ff       	call   f010015c <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f0103c35:	8b 45 10             	mov    0x10(%ebp),%eax
f0103c38:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0103c3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103c3e:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0103c43:	89 c1                	mov    %eax,%ecx
f0103c45:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0103c48:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103c4b:	89 d0                	mov    %edx,%eax
f0103c4d:	01 c0                	add    %eax,%eax
f0103c4f:	01 d0                	add    %edx,%eax
f0103c51:	c1 e0 02             	shl    $0x2,%eax
f0103c54:	01 d8                	add    %ebx,%eax
f0103c56:	83 c0 7c             	add    $0x7c,%eax
f0103c59:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f0103c5b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103c5e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103c61:	89 d0                	mov    %edx,%eax
f0103c63:	01 c0                	add    %eax,%eax
f0103c65:	01 d0                	add    %edx,%eax
f0103c67:	c1 e0 02             	shl    $0x2,%eax
f0103c6a:	01 c8                	add    %ecx,%eax
f0103c6c:	83 e8 80             	sub    $0xffffff80,%eax
f0103c6f:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0103c72:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103c75:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103c78:	89 d0                	mov    %edx,%eax
f0103c7a:	01 c0                	add    %eax,%eax
f0103c7c:	01 d0                	add    %edx,%eax
f0103c7e:	c1 e0 02             	shl    $0x2,%eax
f0103c81:	01 c8                	add    %ecx,%eax
f0103c83:	05 84 00 00 00       	add    $0x84,%eax
f0103c88:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f0103c8e:	90                   	nop
}
f0103c8f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103c92:	c9                   	leave  
f0103c93:	c3                   	ret    

f0103c94 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0103c94:	55                   	push   %ebp
f0103c95:	89 e5                	mov    %esp,%ebp
f0103c97:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0103c9a:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0103c9e:	76 19                	jbe    f0103cb9 <env_table_ws_clear_entry+0x25>
f0103ca0:	68 38 0b 11 f0       	push   $0xf0110b38
f0103ca5:	68 ca 09 11 f0       	push   $0xf01109ca
f0103caa:	68 a0 04 00 00       	push   $0x4a0
f0103caf:	68 a1 08 11 f0       	push   $0xf01108a1
f0103cb4:	e8 a3 c4 ff ff       	call   f010015c <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f0103cb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103cbc:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103cbf:	89 d0                	mov    %edx,%eax
f0103cc1:	01 c0                	add    %eax,%eax
f0103cc3:	01 d0                	add    %edx,%eax
f0103cc5:	c1 e0 02             	shl    $0x2,%eax
f0103cc8:	01 c8                	add    %ecx,%eax
f0103cca:	83 c0 7c             	add    $0x7c,%eax
f0103ccd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f0103cd3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103cd6:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103cd9:	89 d0                	mov    %edx,%eax
f0103cdb:	01 c0                	add    %eax,%eax
f0103cdd:	01 d0                	add    %edx,%eax
f0103cdf:	c1 e0 02             	shl    $0x2,%eax
f0103ce2:	01 c8                	add    %ecx,%eax
f0103ce4:	83 e8 80             	sub    $0xffffff80,%eax
f0103ce7:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f0103cea:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103ced:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103cf0:	89 d0                	mov    %edx,%eax
f0103cf2:	01 c0                	add    %eax,%eax
f0103cf4:	01 d0                	add    %edx,%eax
f0103cf6:	c1 e0 02             	shl    $0x2,%eax
f0103cf9:	01 c8                	add    %ecx,%eax
f0103cfb:	05 84 00 00 00       	add    $0x84,%eax
f0103d00:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0103d06:	90                   	nop
f0103d07:	c9                   	leave  
f0103d08:	c3                   	ret    

f0103d09 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0103d09:	55                   	push   %ebp
f0103d0a:	89 e5                	mov    %esp,%ebp
f0103d0c:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0103d0f:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0103d13:	76 19                	jbe    f0103d2e <env_table_ws_get_virtual_address+0x25>
f0103d15:	68 38 0b 11 f0       	push   $0xf0110b38
f0103d1a:	68 ca 09 11 f0       	push   $0xf01109ca
f0103d1f:	68 a8 04 00 00       	push   $0x4a8
f0103d24:	68 a1 08 11 f0       	push   $0xf01108a1
f0103d29:	e8 2e c4 ff ff       	call   f010015c <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f0103d2e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103d31:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103d34:	89 d0                	mov    %edx,%eax
f0103d36:	01 c0                	add    %eax,%eax
f0103d38:	01 d0                	add    %edx,%eax
f0103d3a:	c1 e0 02             	shl    $0x2,%eax
f0103d3d:	01 c8                	add    %ecx,%eax
f0103d3f:	83 c0 7c             	add    $0x7c,%eax
f0103d42:	8b 00                	mov    (%eax),%eax
f0103d44:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0103d47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103d4a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f0103d4f:	c9                   	leave  
f0103d50:	c3                   	ret    

f0103d51 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0103d51:	55                   	push   %ebp
f0103d52:	89 e5                	mov    %esp,%ebp
f0103d54:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0103d57:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0103d5b:	76 19                	jbe    f0103d76 <env_table_ws_get_time_stamp+0x25>
f0103d5d:	68 38 0b 11 f0       	push   $0xf0110b38
f0103d62:	68 ca 09 11 f0       	push   $0xf01109ca
f0103d67:	68 af 04 00 00       	push   $0x4af
f0103d6c:	68 a1 08 11 f0       	push   $0xf01108a1
f0103d71:	e8 e6 c3 ff ff       	call   f010015c <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f0103d76:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103d79:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103d7c:	89 d0                	mov    %edx,%eax
f0103d7e:	01 c0                	add    %eax,%eax
f0103d80:	01 d0                	add    %edx,%eax
f0103d82:	c1 e0 02             	shl    $0x2,%eax
f0103d85:	01 c8                	add    %ecx,%eax
f0103d87:	05 84 00 00 00       	add    $0x84,%eax
f0103d8c:	8b 00                	mov    (%eax),%eax
}
f0103d8e:	c9                   	leave  
f0103d8f:	c3                   	ret    

f0103d90 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0103d90:	55                   	push   %ebp
f0103d91:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f0103d93:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103d96:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103d99:	89 d0                	mov    %edx,%eax
f0103d9b:	01 c0                	add    %eax,%eax
f0103d9d:	01 d0                	add    %edx,%eax
f0103d9f:	c1 e0 02             	shl    $0x2,%eax
f0103da2:	01 c8                	add    %ecx,%eax
f0103da4:	83 e8 80             	sub    $0xffffff80,%eax
f0103da7:	8a 00                	mov    (%eax),%al
f0103da9:	0f b6 c0             	movzbl %al,%eax
}
f0103dac:	5d                   	pop    %ebp
f0103dad:	c3                   	ret    

f0103dae <addTableToTableWorkingSet>:

void addTableToTableWorkingSet(struct Env *e, uint32 tableAddress)
{
f0103dae:	55                   	push   %ebp
f0103daf:	89 e5                	mov    %esp,%ebp
f0103db1:	83 ec 10             	sub    $0x10,%esp
	tableAddress = ROUNDDOWN(tableAddress, PAGE_SIZE*1024);
f0103db4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103db7:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0103dba:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0103dbd:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0103dc2:	89 45 0c             	mov    %eax,0xc(%ebp)
	e->__ptr_tws[e->table_last_WS_index].virtual_address = tableAddress;
f0103dc5:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc8:	8b 90 d8 02 00 00    	mov    0x2d8(%eax),%edx
f0103dce:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103dd1:	89 d0                	mov    %edx,%eax
f0103dd3:	01 c0                	add    %eax,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 c8                	add    %ecx,%eax
f0103ddc:	8d 50 7c             	lea    0x7c(%eax),%edx
f0103ddf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103de2:	89 02                	mov    %eax,(%edx)
	e->__ptr_tws[e->table_last_WS_index].empty = 0;
f0103de4:	8b 45 08             	mov    0x8(%ebp),%eax
f0103de7:	8b 90 d8 02 00 00    	mov    0x2d8(%eax),%edx
f0103ded:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103df0:	89 d0                	mov    %edx,%eax
f0103df2:	01 c0                	add    %eax,%eax
f0103df4:	01 d0                	add    %edx,%eax
f0103df6:	c1 e0 02             	shl    $0x2,%eax
f0103df9:	01 c8                	add    %ecx,%eax
f0103dfb:	83 e8 80             	sub    $0xffffff80,%eax
f0103dfe:	c6 00 00             	movb   $0x0,(%eax)
	e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f0103e01:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e04:	8b 90 d8 02 00 00    	mov    0x2d8(%eax),%edx
f0103e0a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103e0d:	89 d0                	mov    %edx,%eax
f0103e0f:	01 c0                	add    %eax,%eax
f0103e11:	01 d0                	add    %edx,%eax
f0103e13:	c1 e0 02             	shl    $0x2,%eax
f0103e16:	01 c8                	add    %ecx,%eax
f0103e18:	05 84 00 00 00       	add    $0x84,%eax
f0103e1d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//e->__ptr_tws[e->table_last_WS_index].time_stamp = time;

	e->table_last_WS_index ++;
f0103e23:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e26:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
f0103e2c:	8d 50 01             	lea    0x1(%eax),%edx
f0103e2f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e32:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%eax)
	e->table_last_WS_index %= __TWS_MAX_SIZE;
f0103e38:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e3b:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
f0103e41:	b9 32 00 00 00       	mov    $0x32,%ecx
f0103e46:	ba 00 00 00 00       	mov    $0x0,%edx
f0103e4b:	f7 f1                	div    %ecx
f0103e4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e50:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%eax)
}
f0103e56:	90                   	nop
f0103e57:	c9                   	leave  
f0103e58:	c3                   	ret    

f0103e59 <bufferList_add_page>:
///****************************************************************************************///
///******************************* PAGE BUFFERING FUNCTIONS ******************************///
///****************************************************************************************///

void bufferList_add_page(struct Linked_List* bufferList,struct Frame_Info *ptr_frame_info)
{
f0103e59:	55                   	push   %ebp
f0103e5a:	89 e5                	mov    %esp,%ebp
			}
		}

	}
	 */
	LIST_INSERT_TAIL(bufferList, ptr_frame_info);
f0103e5c:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e5f:	8b 50 04             	mov    0x4(%eax),%edx
f0103e62:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103e65:	89 50 04             	mov    %edx,0x4(%eax)
f0103e68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103e6b:	8b 40 04             	mov    0x4(%eax),%eax
f0103e6e:	85 c0                	test   %eax,%eax
f0103e70:	74 0d                	je     f0103e7f <bufferList_add_page+0x26>
f0103e72:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e75:	8b 40 04             	mov    0x4(%eax),%eax
f0103e78:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103e7b:	89 10                	mov    %edx,(%eax)
f0103e7d:	eb 08                	jmp    f0103e87 <bufferList_add_page+0x2e>
f0103e7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e82:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103e85:	89 10                	mov    %edx,(%eax)
f0103e87:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e8a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103e8d:	89 50 04             	mov    %edx,0x4(%eax)
f0103e90:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103e93:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e99:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e9c:	8b 40 0c             	mov    0xc(%eax),%eax
f0103e9f:	8d 50 01             	lea    0x1(%eax),%edx
f0103ea2:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ea5:	89 50 0c             	mov    %edx,0xc(%eax)
}
f0103ea8:	90                   	nop
f0103ea9:	5d                   	pop    %ebp
f0103eaa:	c3                   	ret    

f0103eab <bufferlist_remove_page>:
void bufferlist_remove_page(struct Linked_List* bufferList, struct Frame_Info *ptr_frame_info)
{
f0103eab:	55                   	push   %ebp
f0103eac:	89 e5                	mov    %esp,%ebp
	LIST_REMOVE(bufferList, ptr_frame_info);
f0103eae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103eb1:	8b 00                	mov    (%eax),%eax
f0103eb3:	85 c0                	test   %eax,%eax
f0103eb5:	74 10                	je     f0103ec7 <bufferlist_remove_page+0x1c>
f0103eb7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103eba:	8b 00                	mov    (%eax),%eax
f0103ebc:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103ebf:	8b 52 04             	mov    0x4(%edx),%edx
f0103ec2:	89 50 04             	mov    %edx,0x4(%eax)
f0103ec5:	eb 0c                	jmp    f0103ed3 <bufferlist_remove_page+0x28>
f0103ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103eca:	8b 50 04             	mov    0x4(%eax),%edx
f0103ecd:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ed0:	89 50 04             	mov    %edx,0x4(%eax)
f0103ed3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ed6:	8b 40 04             	mov    0x4(%eax),%eax
f0103ed9:	85 c0                	test   %eax,%eax
f0103edb:	74 0f                	je     f0103eec <bufferlist_remove_page+0x41>
f0103edd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ee0:	8b 40 04             	mov    0x4(%eax),%eax
f0103ee3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103ee6:	8b 12                	mov    (%edx),%edx
f0103ee8:	89 10                	mov    %edx,(%eax)
f0103eea:	eb 0a                	jmp    f0103ef6 <bufferlist_remove_page+0x4b>
f0103eec:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103eef:	8b 10                	mov    (%eax),%edx
f0103ef1:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ef4:	89 10                	mov    %edx,(%eax)
f0103ef6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ef9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103eff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f02:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103f09:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f0c:	8b 40 0c             	mov    0xc(%eax),%eax
f0103f0f:	8d 50 ff             	lea    -0x1(%eax),%edx
f0103f12:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f15:	89 50 0c             	mov    %edx,0xc(%eax)
}
f0103f18:	90                   	nop
f0103f19:	5d                   	pop    %ebp
f0103f1a:	c3                   	ret    

f0103f1b <pd_is_table_used>:

///============================================================================================
/// Dealing with page and page table entry flags

inline uint32 pd_is_table_used(struct Env* ptr_env, uint32 virtual_address)
{
f0103f1b:	55                   	push   %ebp
f0103f1c:	89 e5                	mov    %esp,%ebp
	return ( (ptr_env->env_page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0103f1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f21:	8b 40 5c             	mov    0x5c(%eax),%eax
f0103f24:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103f27:	c1 ea 16             	shr    $0x16,%edx
f0103f2a:	c1 e2 02             	shl    $0x2,%edx
f0103f2d:	01 d0                	add    %edx,%eax
f0103f2f:	8b 00                	mov    (%eax),%eax
f0103f31:	83 e0 20             	and    $0x20,%eax
f0103f34:	85 c0                	test   %eax,%eax
f0103f36:	0f 95 c0             	setne  %al
f0103f39:	0f b6 c0             	movzbl %al,%eax
}
f0103f3c:	5d                   	pop    %ebp
f0103f3d:	c3                   	ret    

f0103f3e <pd_set_table_unused>:

inline void pd_set_table_unused(struct Env* ptr_env, uint32 virtual_address)
{
f0103f3e:	55                   	push   %ebp
f0103f3f:	89 e5                	mov    %esp,%ebp
f0103f41:	83 ec 08             	sub    $0x8,%esp
	ptr_env->env_page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0103f44:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f47:	8b 40 5c             	mov    0x5c(%eax),%eax
f0103f4a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103f4d:	c1 ea 16             	shr    $0x16,%edx
f0103f50:	c1 e2 02             	shl    $0x2,%edx
f0103f53:	01 c2                	add    %eax,%edx
f0103f55:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f58:	8b 40 5c             	mov    0x5c(%eax),%eax
f0103f5b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0103f5e:	c1 e9 16             	shr    $0x16,%ecx
f0103f61:	c1 e1 02             	shl    $0x2,%ecx
f0103f64:	01 c8                	add    %ecx,%eax
f0103f66:	8b 00                	mov    (%eax),%eax
f0103f68:	83 e0 df             	and    $0xffffffdf,%eax
f0103f6b:	89 02                	mov    %eax,(%edx)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0103f6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f70:	83 ec 08             	sub    $0x8,%esp
f0103f73:	50                   	push   %eax
f0103f74:	6a 00                	push   $0x0
f0103f76:	e8 99 e1 ff ff       	call   f0102114 <tlb_invalidate>
f0103f7b:	83 c4 10             	add    $0x10,%esp
}
f0103f7e:	90                   	nop
f0103f7f:	c9                   	leave  
f0103f80:	c3                   	ret    

f0103f81 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(struct Env* ptr_env, uint32 virtual_address)
{
f0103f81:	55                   	push   %ebp
f0103f82:	89 e5                	mov    %esp,%ebp
f0103f84:	83 ec 10             	sub    $0x10,%esp
	uint32 * ptr_pgdir = ptr_env->env_page_directory ;
f0103f87:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f8a:	8b 40 5c             	mov    0x5c(%eax),%eax
f0103f8d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	ptr_pgdir[PDX(virtual_address)] = 0 ;
f0103f90:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f93:	c1 e8 16             	shr    $0x16,%eax
f0103f96:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103f9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0103fa0:	01 d0                	add    %edx,%eax
f0103fa2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0103fa8:	0f 20 d8             	mov    %cr3,%eax
f0103fab:	89 45 f8             	mov    %eax,-0x8(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0103fae:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0103fb1:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0103fb4:	90                   	nop
f0103fb5:	c9                   	leave  
f0103fb6:	c3                   	ret    

f0103fb7 <pt_set_page_permissions>:

extern int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress);
extern int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress);

inline void pt_set_page_permissions(struct Env* ptr_env, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0103fb7:	55                   	push   %ebp
f0103fb8:	89 e5                	mov    %esp,%ebp
f0103fba:	83 ec 28             	sub    $0x28,%esp
	uint32 * ptr_pgdir = ptr_env->env_page_directory ;
f0103fbd:	8b 45 08             	mov    0x8(%ebp),%eax
f0103fc0:	8b 40 5c             	mov    0x5c(%eax),%eax
f0103fc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32* ptr_page_table;
	//if(get_page_table(ptr_pgdir, (void *)virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
	//	panic("function pt_set_page_unmodified() called with invalid virtual address\n") ;

	uint32 	page_directory_entry = ptr_pgdir[PDX(virtual_address)] ;
f0103fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fc9:	c1 e8 16             	shr    $0x16,%eax
f0103fcc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103fd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103fd6:	01 d0                	add    %edx,%eax
f0103fd8:	8b 00                	mov    (%eax),%eax
f0103fda:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0103fdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103fe0:	83 e0 01             	and    $0x1,%eax
f0103fe3:	85 c0                	test   %eax,%eax
f0103fe5:	0f 84 d6 00 00 00    	je     f01040c1 <pt_set_page_permissions+0x10a>
	{
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0103feb:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0103ff2:	77 19                	ja     f010400d <pt_set_page_permissions+0x56>
		{
			ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0103ff4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103ff7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103ffc:	83 ec 0c             	sub    $0xc,%esp
f0103fff:	50                   	push   %eax
f0104000:	e8 9e 71 00 00       	call   f010b1a3 <kheap_virtual_address>
f0104005:	83 c4 10             	add    $0x10,%esp
f0104008:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010400b:	eb 40                	jmp    f010404d <pt_set_page_permissions+0x96>
		}
		else
		{
			ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010400d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104010:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104015:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0104018:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010401b:	c1 e8 0c             	shr    $0xc,%eax
f010401e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0104021:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f0104026:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0104029:	72 17                	jb     f0104042 <pt_set_page_permissions+0x8b>
f010402b:	ff 75 e8             	pushl  -0x18(%ebp)
f010402e:	68 c8 08 11 f0       	push   $0xf01108c8
f0104033:	68 2e 05 00 00       	push   $0x52e
f0104038:	68 a1 08 11 f0       	push   $0xf01108a1
f010403d:	e8 1a c1 ff ff       	call   f010015c <_panic>
f0104042:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104045:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010404a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		}
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f010404d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104050:	c1 e8 0c             	shr    $0xc,%eax
f0104053:	25 ff 03 00 00       	and    $0x3ff,%eax
f0104058:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010405f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104062:	01 c2                	add    %eax,%edx
f0104064:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104067:	c1 e8 0c             	shr    $0xc,%eax
f010406a:	25 ff 03 00 00       	and    $0x3ff,%eax
f010406f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0104076:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104079:	01 c8                	add    %ecx,%eax
f010407b:	8b 00                	mov    (%eax),%eax
f010407d:	0b 45 10             	or     0x10(%ebp),%eax
f0104080:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0104082:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104085:	c1 e8 0c             	shr    $0xc,%eax
f0104088:	25 ff 03 00 00       	and    $0x3ff,%eax
f010408d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104094:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104097:	01 d0                	add    %edx,%eax
f0104099:	8b 55 0c             	mov    0xc(%ebp),%edx
f010409c:	c1 ea 0c             	shr    $0xc,%edx
f010409f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01040a5:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f01040ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01040af:	01 ca                	add    %ecx,%edx
f01040b1:	8b 12                	mov    (%edx),%edx
f01040b3:	8b 4d 14             	mov    0x14(%ebp),%ecx
f01040b6:	f7 d1                	not    %ecx
f01040b8:	21 ca                	and    %ecx,%edx
f01040ba:	89 10                	mov    %edx,(%eax)
f01040bc:	e9 e8 00 00 00       	jmp    f01041a9 <pt_set_page_permissions+0x1f2>

	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01040c1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01040c5:	0f 84 c7 00 00 00    	je     f0104192 <pt_set_page_permissions+0x1db>
	{
		//cprintf("Warning %d: pt_is_page_modified() is called while the page table is on disk!!\n", ++cnt);
		//Temporary read the table from page file into main memory
		int success = __pf_read_env_table(ptr_env, virtual_address, (void*) ptr_temp_page);
f01040cb:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f01040d0:	83 ec 04             	sub    $0x4,%esp
f01040d3:	50                   	push   %eax
f01040d4:	ff 75 0c             	pushl  0xc(%ebp)
f01040d7:	ff 75 08             	pushl  0x8(%ebp)
f01040da:	e8 a9 67 00 00       	call   f010a888 <__pf_read_env_table>
f01040df:	83 c4 10             	add    $0x10,%esp
f01040e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
		ptr_page_table = (uint32*) ptr_temp_page;
f01040e5:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f01040ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(success == E_TABLE_NOT_EXIST_IN_PF)
f01040ed:	83 7d e0 f6          	cmpl   $0xfffffff6,-0x20(%ebp)
f01040f1:	75 17                	jne    f010410a <pt_set_page_permissions+0x153>
			panic("pt_set_page_permissions: table not found in PF when expected to find one !. please revise your table fault\
f01040f3:	83 ec 04             	sub    $0x4,%esp
f01040f6:	68 6c 0b 11 f0       	push   $0xf0110b6c
f01040fb:	68 3c 05 00 00       	push   $0x53c
f0104100:	68 a1 08 11 f0       	push   $0xf01108a1
f0104105:	e8 52 c0 ff ff       	call   f010015c <_panic>
			handling code");

		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f010410a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010410d:	c1 e8 0c             	shr    $0xc,%eax
f0104110:	25 ff 03 00 00       	and    $0x3ff,%eax
f0104115:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010411c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411f:	01 c2                	add    %eax,%edx
f0104121:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104124:	c1 e8 0c             	shr    $0xc,%eax
f0104127:	25 ff 03 00 00       	and    $0x3ff,%eax
f010412c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0104133:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104136:	01 c8                	add    %ecx,%eax
f0104138:	8b 00                	mov    (%eax),%eax
f010413a:	0b 45 10             	or     0x10(%ebp),%eax
f010413d:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f010413f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104142:	c1 e8 0c             	shr    $0xc,%eax
f0104145:	25 ff 03 00 00       	and    $0x3ff,%eax
f010414a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104151:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104154:	01 d0                	add    %edx,%eax
f0104156:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104159:	c1 ea 0c             	shr    $0xc,%edx
f010415c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104162:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0104169:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010416c:	01 ca                	add    %ecx,%edx
f010416e:	8b 12                	mov    (%edx),%edx
f0104170:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0104173:	f7 d1                	not    %ecx
f0104175:	21 ca                	and    %ecx,%edx
f0104177:	89 10                	mov    %edx,(%eax)

		__pf_write_env_table(ptr_env, virtual_address, (void*) ptr_temp_page);
f0104179:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f010417e:	83 ec 04             	sub    $0x4,%esp
f0104181:	50                   	push   %eax
f0104182:	ff 75 0c             	pushl  0xc(%ebp)
f0104185:	ff 75 08             	pushl  0x8(%ebp)
f0104188:	e8 56 66 00 00       	call   f010a7e3 <__pf_write_env_table>
f010418d:	83 c4 10             	add    $0x10,%esp
f0104190:	eb 17                	jmp    f01041a9 <pt_set_page_permissions+0x1f2>
	}
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0104192:	83 ec 04             	sub    $0x4,%esp
f0104195:	68 e8 0b 11 f0       	push   $0xf0110be8
f010419a:	68 46 05 00 00       	push   $0x546
f010419f:	68 a1 08 11 f0       	push   $0xf01108a1
f01041a4:	e8 b3 bf ff ff       	call   f010015c <_panic>
	}

	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01041a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	6a 00                	push   $0x0
f01041b2:	e8 5d df ff ff       	call   f0102114 <tlb_invalidate>
f01041b7:	83 c4 10             	add    $0x10,%esp
}
f01041ba:	90                   	nop
f01041bb:	c9                   	leave  
f01041bc:	c3                   	ret    

f01041bd <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(struct Env* ptr_env, uint32 virtual_address)
{
f01041bd:	55                   	push   %ebp
f01041be:	89 e5                	mov    %esp,%ebp
f01041c0:	83 ec 28             	sub    $0x28,%esp
	uint32 * ptr_pgdir = ptr_env->env_page_directory ;
f01041c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01041c6:	8b 40 5c             	mov    0x5c(%eax),%eax
f01041c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32* ptr_page_table;
	//if(get_page_table(ptr_pgdir, (void *)virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
	//	panic("function pt_set_page_unmodified() called with invalid virtual address\n") ;

	uint32 	page_directory_entry = ptr_pgdir[PDX(virtual_address)] ;
f01041cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01041cf:	c1 e8 16             	shr    $0x16,%eax
f01041d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01041d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041dc:	01 d0                	add    %edx,%eax
f01041de:	8b 00                	mov    (%eax),%eax
f01041e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f01041e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041e6:	83 e0 01             	and    $0x1,%eax
f01041e9:	85 c0                	test   %eax,%eax
f01041eb:	0f 84 84 00 00 00    	je     f0104275 <pt_clear_page_table_entry+0xb8>
	{
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01041f1:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01041f8:	77 19                	ja     f0104213 <pt_clear_page_table_entry+0x56>
		{
			ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01041fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041fd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104202:	83 ec 0c             	sub    $0xc,%esp
f0104205:	50                   	push   %eax
f0104206:	e8 98 6f 00 00       	call   f010b1a3 <kheap_virtual_address>
f010420b:	83 c4 10             	add    $0x10,%esp
f010420e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104211:	eb 40                	jmp    f0104253 <pt_clear_page_table_entry+0x96>
		}
		else
		{
			ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0104213:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104216:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010421b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010421e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104221:	c1 e8 0c             	shr    $0xc,%eax
f0104224:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0104227:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f010422c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010422f:	72 17                	jb     f0104248 <pt_clear_page_table_entry+0x8b>
f0104231:	ff 75 e8             	pushl  -0x18(%ebp)
f0104234:	68 c8 08 11 f0       	push   $0xf01108c8
f0104239:	68 5c 05 00 00       	push   $0x55c
f010423e:	68 a1 08 11 f0       	push   $0xf01108a1
f0104243:	e8 14 bf ff ff       	call   f010015c <_panic>
f0104248:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010424b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104250:	89 45 f4             	mov    %eax,-0xc(%ebp)
		}

		ptr_page_table[PTX(virtual_address)] = 0 ;
f0104253:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104256:	c1 e8 0c             	shr    $0xc,%eax
f0104259:	25 ff 03 00 00       	and    $0x3ff,%eax
f010425e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104265:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104268:	01 d0                	add    %edx,%eax
f010426a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104270:	e9 92 00 00 00       	jmp    f0104307 <pt_clear_page_table_entry+0x14a>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f0104275:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0104279:	74 75                	je     f01042f0 <pt_clear_page_table_entry+0x133>
	{
		//cprintf("Warning %d: pt_is_page_modified() is called while the page table is on disk!!\n", ++cnt);
		//Temporary read the table from page file into main memory

		int success = __pf_read_env_table(ptr_env, virtual_address, (void*) ptr_temp_page);
f010427b:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f0104280:	83 ec 04             	sub    $0x4,%esp
f0104283:	50                   	push   %eax
f0104284:	ff 75 0c             	pushl  0xc(%ebp)
f0104287:	ff 75 08             	pushl  0x8(%ebp)
f010428a:	e8 f9 65 00 00       	call   f010a888 <__pf_read_env_table>
f010428f:	83 c4 10             	add    $0x10,%esp
f0104292:	89 45 e0             	mov    %eax,-0x20(%ebp)
		ptr_page_table = (uint32*) ptr_temp_page;
f0104295:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f010429a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(success == E_TABLE_NOT_EXIST_IN_PF)
f010429d:	83 7d e0 f6          	cmpl   $0xfffffff6,-0x20(%ebp)
f01042a1:	75 17                	jne    f01042ba <pt_clear_page_table_entry+0xfd>
			panic("pt_clear_page_table_entry: table not found in PF when expected to find one !. please revise your table fault\
f01042a3:	83 ec 04             	sub    $0x4,%esp
f01042a6:	68 5c 0c 11 f0       	push   $0xf0110c5c
f01042ab:	68 6a 05 00 00       	push   $0x56a
f01042b0:	68 a1 08 11 f0       	push   $0xf01108a1
f01042b5:	e8 a2 be ff ff       	call   f010015c <_panic>
			handling code");

		ptr_page_table[PTX(virtual_address)] = 0 ;
f01042ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042bd:	c1 e8 0c             	shr    $0xc,%eax
f01042c0:	25 ff 03 00 00       	and    $0x3ff,%eax
f01042c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01042cf:	01 d0                	add    %edx,%eax
f01042d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

		__pf_write_env_table(ptr_env, virtual_address, (void*) ptr_temp_page);
f01042d7:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f01042dc:	83 ec 04             	sub    $0x4,%esp
f01042df:	50                   	push   %eax
f01042e0:	ff 75 0c             	pushl  0xc(%ebp)
f01042e3:	ff 75 08             	pushl  0x8(%ebp)
f01042e6:	e8 f8 64 00 00       	call   f010a7e3 <__pf_write_env_table>
f01042eb:	83 c4 10             	add    $0x10,%esp
f01042ee:	eb 17                	jmp    f0104307 <pt_clear_page_table_entry+0x14a>
	}
	else
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f01042f0:	83 ec 04             	sub    $0x4,%esp
f01042f3:	68 dc 0c 11 f0       	push   $0xf0110cdc
f01042f8:	68 71 05 00 00       	push   $0x571
f01042fd:	68 a1 08 11 f0       	push   $0xf01108a1
f0104302:	e8 55 be ff ff       	call   f010015c <_panic>


	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0104307:	8b 45 0c             	mov    0xc(%ebp),%eax
f010430a:	83 ec 08             	sub    $0x8,%esp
f010430d:	50                   	push   %eax
f010430e:	6a 00                	push   $0x0
f0104310:	e8 ff dd ff ff       	call   f0102114 <tlb_invalidate>
f0104315:	83 c4 10             	add    $0x10,%esp
}
f0104318:	90                   	nop
f0104319:	c9                   	leave  
f010431a:	c3                   	ret    

f010431b <pt_get_page_permissions>:

inline uint32 pt_get_page_permissions(struct Env* ptr_env, uint32 virtual_address )
{
f010431b:	55                   	push   %ebp
f010431c:	89 e5                	mov    %esp,%ebp
f010431e:	83 ec 28             	sub    $0x28,%esp
	uint32 * ptr_pgdir = ptr_env->env_page_directory ;
f0104321:	8b 45 08             	mov    0x8(%ebp),%eax
f0104324:	8b 40 5c             	mov    0x5c(%eax),%eax
f0104327:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32* ptr_page_table;

	uint32 	page_directory_entry = ptr_pgdir[PDX(virtual_address)] ;
f010432a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010432d:	c1 e8 16             	shr    $0x16,%eax
f0104330:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104337:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010433a:	01 d0                	add    %edx,%eax
f010433c:	8b 00                	mov    (%eax),%eax
f010433e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0104341:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104344:	83 e0 01             	and    $0x1,%eax
f0104347:	85 c0                	test   %eax,%eax
f0104349:	74 67                	je     f01043b2 <pt_get_page_permissions+0x97>
	{
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010434b:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104352:	77 1c                	ja     f0104370 <pt_get_page_permissions+0x55>
		{
			ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0104354:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104357:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010435c:	83 ec 0c             	sub    $0xc,%esp
f010435f:	50                   	push   %eax
f0104360:	e8 3e 6e 00 00       	call   f010b1a3 <kheap_virtual_address>
f0104365:	83 c4 10             	add    $0x10,%esp
f0104368:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010436b:	e9 8e 00 00 00       	jmp    f01043fe <pt_get_page_permissions+0xe3>
		}
		else
		{
			ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0104370:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104373:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104378:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010437b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010437e:	c1 e8 0c             	shr    $0xc,%eax
f0104381:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0104384:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f0104389:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f010438c:	72 17                	jb     f01043a5 <pt_get_page_permissions+0x8a>
f010438e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104391:	68 c8 08 11 f0       	push   $0xf01108c8
f0104396:	68 85 05 00 00       	push   $0x585
f010439b:	68 a1 08 11 f0       	push   $0xf01108a1
f01043a0:	e8 b7 bd ff ff       	call   f010015c <_panic>
f01043a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01043a8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01043ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01043b0:	eb 4c                	jmp    f01043fe <pt_get_page_permissions+0xe3>
		}
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01043b2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01043b6:	74 3f                	je     f01043f7 <pt_get_page_permissions+0xdc>
	{
		//cprintf("Warning %d: pt_is_page_modified() is called while the page table is on disk!!\n", ++cnt);
		//Temporary read the table from page file into main memory
		int success = __pf_read_env_table(ptr_env, virtual_address, (void*) ptr_temp_page);
f01043b8:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f01043bd:	83 ec 04             	sub    $0x4,%esp
f01043c0:	50                   	push   %eax
f01043c1:	ff 75 0c             	pushl  0xc(%ebp)
f01043c4:	ff 75 08             	pushl  0x8(%ebp)
f01043c7:	e8 bc 64 00 00       	call   f010a888 <__pf_read_env_table>
f01043cc:	83 c4 10             	add    $0x10,%esp
f01043cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_page_table = (uint32*) ptr_temp_page;
f01043d2:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f01043d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(success == E_TABLE_NOT_EXIST_IN_PF)
f01043da:	83 7d e8 f6          	cmpl   $0xfffffff6,-0x18(%ebp)
f01043de:	75 1e                	jne    f01043fe <pt_get_page_permissions+0xe3>
			panic("pt_get_page_permissions: table not found in PF when expected to find one !. please revise your table fault\
f01043e0:	83 ec 04             	sub    $0x4,%esp
f01043e3:	68 54 0d 11 f0       	push   $0xf0110d54
f01043e8:	68 90 05 00 00       	push   $0x590
f01043ed:	68 a1 08 11 f0       	push   $0xf01108a1
f01043f2:	e8 65 bd ff ff       	call   f010015c <_panic>
			handling code");
	}
	else
		return 0;
f01043f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01043fc:	eb 1e                	jmp    f010441c <pt_get_page_permissions+0x101>
	//panic("function pt_get_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;

	//	if(get_page_table(ptr_pgdir, (void *)virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
	//		panic("function pt_is_page_modified() called with invalid virtual address\n") ;

	return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f01043fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104401:	c1 e8 0c             	shr    $0xc,%eax
f0104404:	25 ff 03 00 00       	and    $0x3ff,%eax
f0104409:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104410:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104413:	01 d0                	add    %edx,%eax
f0104415:	8b 00                	mov    (%eax),%eax
f0104417:	25 ff 0f 00 00       	and    $0xfff,%eax
}
f010441c:	c9                   	leave  
f010441d:	c3                   	ret    

f010441e <add_frame_to_storage>:
//=============================================================
// 2014
//=============================================================
// [1] Add a frame info to the storage of frames at the given index
inline void add_frame_to_storage(uint32* frames_storage, struct Frame_Info* ptr_frame_info, uint32 index)
{
f010441e:	55                   	push   %ebp
f010441f:	89 e5                	mov    %esp,%ebp
f0104421:	53                   	push   %ebx
f0104422:	83 ec 14             	sub    $0x14,%esp
	uint32 va = index * PAGE_SIZE ;
f0104425:	8b 45 10             	mov    0x10(%ebp),%eax
f0104428:	c1 e0 0c             	shl    $0xc,%eax
f010442b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	int r = get_page_table(frames_storage, (void*) va, &ptr_page_table);
f010442e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104431:	83 ec 04             	sub    $0x4,%esp
f0104434:	8d 55 ec             	lea    -0x14(%ebp),%edx
f0104437:	52                   	push   %edx
f0104438:	50                   	push   %eax
f0104439:	ff 75 08             	pushl  0x8(%ebp)
f010443c:	e8 cf e8 ff ff       	call   f0102d10 <get_page_table>
f0104441:	83 c4 10             	add    $0x10,%esp
f0104444:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(r == TABLE_NOT_EXIST)
f0104447:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010444b:	75 14                	jne    f0104461 <add_frame_to_storage+0x43>
	{
		if(USE_KHEAP)
		{
			ptr_page_table = create_page_table(frames_storage, (uint32)va);
f010444d:	83 ec 08             	sub    $0x8,%esp
f0104450:	ff 75 f4             	pushl  -0xc(%ebp)
f0104453:	ff 75 08             	pushl  0x8(%ebp)
f0104456:	e8 0d ea ff ff       	call   f0102e68 <create_page_table>
f010445b:	83 c4 10             	add    $0x10,%esp
f010445e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			__static_cpt(frames_storage, (uint32)va, &ptr_page_table);
		}

	}
	ptr_page_table[PTX(va)] = CONSTRUCT_ENTRY(to_physical_address(ptr_frame_info), 0 | PERM_PRESENT);
f0104461:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104464:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104467:	c1 ea 0c             	shr    $0xc,%edx
f010446a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104470:	c1 e2 02             	shl    $0x2,%edx
f0104473:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
f0104476:	83 ec 0c             	sub    $0xc,%esp
f0104479:	ff 75 0c             	pushl  0xc(%ebp)
f010447c:	e8 21 df ff ff       	call   f01023a2 <to_physical_address>
f0104481:	83 c4 10             	add    $0x10,%esp
f0104484:	83 c8 01             	or     $0x1,%eax
f0104487:	89 03                	mov    %eax,(%ebx)
}
f0104489:	90                   	nop
f010448a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010448d:	c9                   	leave  
f010448e:	c3                   	ret    

f010448f <get_frame_from_storage>:

// [2] Get a frame info from the storage of frames at the given index
inline struct Frame_Info* get_frame_from_storage(uint32* frames_storage, uint32 index)
						{
f010448f:	55                   	push   %ebp
f0104490:	89 e5                	mov    %esp,%ebp
f0104492:	83 ec 18             	sub    $0x18,%esp
	struct Frame_Info* ptr_frame_info;
	uint32 *ptr_page_table ;
	uint32 va = index * PAGE_SIZE ;
f0104495:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104498:	c1 e0 0c             	shl    $0xc,%eax
f010449b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_frame_info = get_frame_info(frames_storage, (void*) va, &ptr_page_table);
f010449e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044a1:	83 ec 04             	sub    $0x4,%esp
f01044a4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01044a7:	52                   	push   %edx
f01044a8:	50                   	push   %eax
f01044a9:	ff 75 08             	pushl  0x8(%ebp)
f01044ac:	e8 a9 eb ff ff       	call   f010305a <get_frame_info>
f01044b1:	83 c4 10             	add    $0x10,%esp
f01044b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return ptr_frame_info;
f01044b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
						}
f01044ba:	c9                   	leave  
f01044bb:	c3                   	ret    

f01044bc <clear_frames_storage>:

// [3] Clear the storage of frames
inline void clear_frames_storage(uint32* frames_storage)
{
f01044bc:	55                   	push   %ebp
f01044bd:	89 e5                	mov    %esp,%ebp
f01044bf:	83 ec 18             	sub    $0x18,%esp
	int fourMega = 1024 * PAGE_SIZE ;
f01044c2:	c7 45 f0 00 00 40 00 	movl   $0x400000,-0x10(%ebp)
	int i ;
	for (i = 0 ; i < 1024 ; i++)
f01044c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01044d0:	eb 5b                	jmp    f010452d <clear_frames_storage+0x71>
	{
		if (frames_storage[i] != 0)
f01044d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01044dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01044df:	01 d0                	add    %edx,%eax
f01044e1:	8b 00                	mov    (%eax),%eax
f01044e3:	85 c0                	test   %eax,%eax
f01044e5:	74 43                	je     f010452a <clear_frames_storage+0x6e>
		{
			if(USE_KHEAP)
			{
				kfree((void*)kheap_virtual_address(EXTRACT_ADDRESS(frames_storage[i])));
f01044e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01044f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01044f4:	01 d0                	add    %edx,%eax
f01044f6:	8b 00                	mov    (%eax),%eax
f01044f8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044fd:	83 ec 0c             	sub    $0xc,%esp
f0104500:	50                   	push   %eax
f0104501:	e8 9d 6c 00 00       	call   f010b1a3 <kheap_virtual_address>
f0104506:	83 c4 10             	add    $0x10,%esp
f0104509:	83 ec 0c             	sub    $0xc,%esp
f010450c:	50                   	push   %eax
f010450d:	e8 8c 6b 00 00       	call   f010b09e <kfree>
f0104512:	83 c4 10             	add    $0x10,%esp
			}
			else
			{
				free_frame(to_frame_info(EXTRACT_ADDRESS(frames_storage[i])));
			}
			frames_storage[i] = 0;
f0104515:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104518:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010451f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104522:	01 d0                	add    %edx,%eax
f0104524:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
// [3] Clear the storage of frames
inline void clear_frames_storage(uint32* frames_storage)
{
	int fourMega = 1024 * PAGE_SIZE ;
	int i ;
	for (i = 0 ; i < 1024 ; i++)
f010452a:	ff 45 f4             	incl   -0xc(%ebp)
f010452d:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0104534:	7e 9c                	jle    f01044d2 <clear_frames_storage+0x16>
				free_frame(to_frame_info(EXTRACT_ADDRESS(frames_storage[i])));
			}
			frames_storage[i] = 0;
		}
	}
}
f0104536:	90                   	nop
f0104537:	c9                   	leave  
f0104538:	c3                   	ret    

f0104539 <setUHeapPlacementStrategyFIRSTFIT>:
//********************************************************************************//
/*2015*/
void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f0104539:	55                   	push   %ebp
f010453a:	89 e5                	mov    %esp,%ebp
f010453c:	c7 05 2c 2a 45 f0 01 	movl   $0x1,0xf0452a2c
f0104543:	00 00 00 
f0104546:	90                   	nop
f0104547:	5d                   	pop    %ebp
f0104548:	c3                   	ret    

f0104549 <setUHeapPlacementStrategyBESTFIT>:
void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f0104549:	55                   	push   %ebp
f010454a:	89 e5                	mov    %esp,%ebp
f010454c:	c7 05 2c 2a 45 f0 02 	movl   $0x2,0xf0452a2c
f0104553:	00 00 00 
f0104556:	90                   	nop
f0104557:	5d                   	pop    %ebp
f0104558:	c3                   	ret    

f0104559 <setUHeapPlacementStrategyNEXTFIT>:
void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f0104559:	55                   	push   %ebp
f010455a:	89 e5                	mov    %esp,%ebp
f010455c:	c7 05 2c 2a 45 f0 03 	movl   $0x3,0xf0452a2c
f0104563:	00 00 00 
f0104566:	90                   	nop
f0104567:	5d                   	pop    %ebp
f0104568:	c3                   	ret    

f0104569 <setUHeapPlacementStrategyWORSTFIT>:
void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f0104569:	55                   	push   %ebp
f010456a:	89 e5                	mov    %esp,%ebp
f010456c:	c7 05 2c 2a 45 f0 04 	movl   $0x4,0xf0452a2c
f0104573:	00 00 00 
f0104576:	90                   	nop
f0104577:	5d                   	pop    %ebp
f0104578:	c3                   	ret    

f0104579 <isUHeapPlacementStrategyFIRSTFIT>:

uint32 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f0104579:	55                   	push   %ebp
f010457a:	89 e5                	mov    %esp,%ebp
f010457c:	a1 2c 2a 45 f0       	mov    0xf0452a2c,%eax
f0104581:	83 f8 01             	cmp    $0x1,%eax
f0104584:	75 07                	jne    f010458d <isUHeapPlacementStrategyFIRSTFIT+0x14>
f0104586:	b8 01 00 00 00       	mov    $0x1,%eax
f010458b:	eb 05                	jmp    f0104592 <isUHeapPlacementStrategyFIRSTFIT+0x19>
f010458d:	b8 00 00 00 00       	mov    $0x0,%eax
f0104592:	5d                   	pop    %ebp
f0104593:	c3                   	ret    

f0104594 <isUHeapPlacementStrategyBESTFIT>:
uint32 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0104594:	55                   	push   %ebp
f0104595:	89 e5                	mov    %esp,%ebp
f0104597:	a1 2c 2a 45 f0       	mov    0xf0452a2c,%eax
f010459c:	83 f8 02             	cmp    $0x2,%eax
f010459f:	75 07                	jne    f01045a8 <isUHeapPlacementStrategyBESTFIT+0x14>
f01045a1:	b8 01 00 00 00       	mov    $0x1,%eax
f01045a6:	eb 05                	jmp    f01045ad <isUHeapPlacementStrategyBESTFIT+0x19>
f01045a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01045ad:	5d                   	pop    %ebp
f01045ae:	c3                   	ret    

f01045af <isUHeapPlacementStrategyNEXTFIT>:
uint32 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f01045af:	55                   	push   %ebp
f01045b0:	89 e5                	mov    %esp,%ebp
f01045b2:	a1 2c 2a 45 f0       	mov    0xf0452a2c,%eax
f01045b7:	83 f8 03             	cmp    $0x3,%eax
f01045ba:	75 07                	jne    f01045c3 <isUHeapPlacementStrategyNEXTFIT+0x14>
f01045bc:	b8 01 00 00 00       	mov    $0x1,%eax
f01045c1:	eb 05                	jmp    f01045c8 <isUHeapPlacementStrategyNEXTFIT+0x19>
f01045c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01045c8:	5d                   	pop    %ebp
f01045c9:	c3                   	ret    

f01045ca <isUHeapPlacementStrategyWORSTFIT>:
uint32 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f01045ca:	55                   	push   %ebp
f01045cb:	89 e5                	mov    %esp,%ebp
f01045cd:	a1 2c 2a 45 f0       	mov    0xf0452a2c,%eax
f01045d2:	83 f8 04             	cmp    $0x4,%eax
f01045d5:	75 07                	jne    f01045de <isUHeapPlacementStrategyWORSTFIT+0x14>
f01045d7:	b8 01 00 00 00       	mov    $0x1,%eax
f01045dc:	eb 05                	jmp    f01045e3 <isUHeapPlacementStrategyWORSTFIT+0x19>
f01045de:	b8 00 00 00 00       	mov    $0x0,%eax
f01045e3:	5d                   	pop    %ebp
f01045e4:	c3                   	ret    

f01045e5 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct Frame_Info* to_frame_info(uint32 physical_address)
{
f01045e5:	55                   	push   %ebp
f01045e6:	89 e5                	mov    %esp,%ebp
f01045e8:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f01045eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ee:	c1 e8 0c             	shr    $0xc,%eax
f01045f1:	89 c2                	mov    %eax,%edx
f01045f3:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f01045f8:	39 c2                	cmp    %eax,%edx
f01045fa:	72 14                	jb     f0104610 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f01045fc:	83 ec 04             	sub    $0x4,%esp
f01045ff:	68 d0 0d 11 f0       	push   $0xf0110dd0
f0104604:	6a 60                	push   $0x60
f0104606:	68 f5 0d 11 f0       	push   $0xf0110df5
f010460b:	e8 4c bb ff ff       	call   f010015c <_panic>
	return &frames_info[PPN(physical_address)];
f0104610:	8b 15 84 52 45 f0    	mov    0xf0455284,%edx
f0104616:	8b 45 08             	mov    0x8(%ebp),%eax
f0104619:	c1 e8 0c             	shr    $0xc,%eax
f010461c:	89 c1                	mov    %eax,%ecx
f010461e:	89 c8                	mov    %ecx,%eax
f0104620:	01 c0                	add    %eax,%eax
f0104622:	01 c8                	add    %ecx,%eax
f0104624:	c1 e0 03             	shl    $0x3,%eax
f0104627:	01 d0                	add    %edx,%eax
}
f0104629:	c9                   	leave  
f010462a:	c3                   	ret    

f010462b <allocate_environment>:
// On success, the new environment is stored in *e.
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e) {
f010462b:	55                   	push   %ebp
f010462c:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010462e:	8b 15 3c a1 42 f0    	mov    0xf042a13c,%edx
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	89 10                	mov    %edx,(%eax)
f0104639:	8b 45 08             	mov    0x8(%ebp),%eax
f010463c:	8b 00                	mov    (%eax),%eax
f010463e:	85 c0                	test   %eax,%eax
f0104640:	75 07                	jne    f0104649 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f0104642:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f0104647:	eb 11                	jmp    f010465a <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f0104649:	8b 45 08             	mov    0x8(%ebp),%eax
f010464c:	8b 00                	mov    (%eax),%eax
f010464e:	c7 40 54 05 00 00 00 	movl   $0x5,0x54(%eax)
	return 0;
f0104655:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010465a:	5d                   	pop    %ebp
f010465b:	c3                   	ret    

f010465c <free_environment>:

// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e) {
f010465c:	55                   	push   %ebp
f010465d:	89 e5                	mov    %esp,%ebp
f010465f:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f0104662:	83 ec 04             	sub    $0x4,%esp
f0104665:	68 f8 02 00 00       	push   $0x2f8
f010466a:	6a 00                	push   $0x0
f010466c:	ff 75 08             	pushl  0x8(%ebp)
f010466f:	e8 2a a6 00 00       	call   f010ec9e <memset>
f0104674:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f0104677:	8b 45 08             	mov    0x8(%ebp),%eax
f010467a:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f0104681:	8b 15 3c a1 42 f0    	mov    0xf042a13c,%edx
f0104687:	8b 45 08             	mov    0x8(%ebp),%eax
f010468a:	89 50 44             	mov    %edx,0x44(%eax)
f010468d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104690:	8b 40 44             	mov    0x44(%eax),%eax
f0104693:	85 c0                	test   %eax,%eax
f0104695:	74 0d                	je     f01046a4 <free_environment+0x48>
f0104697:	a1 3c a1 42 f0       	mov    0xf042a13c,%eax
f010469c:	8b 55 08             	mov    0x8(%ebp),%edx
f010469f:	89 50 48             	mov    %edx,0x48(%eax)
f01046a2:	eb 08                	jmp    f01046ac <free_environment+0x50>
f01046a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01046a7:	a3 40 a1 42 f0       	mov    %eax,0xf042a140
f01046ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01046af:	a3 3c a1 42 f0       	mov    %eax,0xf042a13c
f01046b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01046b7:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f01046be:	a1 48 a1 42 f0       	mov    0xf042a148,%eax
f01046c3:	40                   	inc    %eax
f01046c4:	a3 48 a1 42 f0       	mov    %eax,0xf042a148
}
f01046c9:	90                   	nop
f01046ca:	c9                   	leave  
f01046cb:	c3                   	ret    

f01046cc <create_user_page_WS>:

void * create_user_page_WS(unsigned int numOfElements) {
f01046cc:	55                   	push   %ebp
f01046cd:	89 e5                	mov    %esp,%ebp
f01046cf:	83 ec 18             	sub    $0x18,%esp
	//refer to the project documentation for the detailed steps

	//change this "return" according to your answer

	uint32* ptr = (uint32*) kmalloc(
			numOfElements * sizeof(struct WorkingSetElement));
f01046d2:	8b 55 08             	mov    0x8(%ebp),%edx
f01046d5:	89 d0                	mov    %edx,%eax
f01046d7:	01 c0                	add    %eax,%eax
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c1 e0 02             	shl    $0x2,%eax
	//Use kmalloc() to allocate a new space for a working set with numOfElements elements
	//refer to the project documentation for the detailed steps

	//change this "return" according to your answer

	uint32* ptr = (uint32*) kmalloc(
f01046de:	83 ec 0c             	sub    $0xc,%esp
f01046e1:	50                   	push   %eax
f01046e2:	e8 3e 66 00 00       	call   f010ad25 <kmalloc>
f01046e7:	83 c4 10             	add    $0x10,%esp
f01046ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
			numOfElements * sizeof(struct WorkingSetElement));
	return (void*) ptr;
f01046ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01046f0:	c9                   	leave  
f01046f1:	c3                   	ret    

f01046f2 <create_user_directory>:

void * create_user_directory() {
f01046f2:	55                   	push   %ebp
f01046f3:	89 e5                	mov    %esp,%ebp
f01046f5:	83 ec 18             	sub    $0x18,%esp

	//Use kmalloc() to allocate a new directory
	//refer to the project documentation for the detailed steps

	//change this "return" according to your answer
	uint32 *ptr_page_directory = kmalloc(PAGE_SIZE);
f01046f8:	83 ec 0c             	sub    $0xc,%esp
f01046fb:	68 00 10 00 00       	push   $0x1000
f0104700:	e8 20 66 00 00       	call   f010ad25 <kmalloc>
f0104705:	83 c4 10             	add    $0x10,%esp
f0104708:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memset(ptr_page_directory, 0, PAGE_SIZE);
f010470b:	83 ec 04             	sub    $0x4,%esp
f010470e:	68 00 10 00 00       	push   $0x1000
f0104713:	6a 00                	push   $0x0
f0104715:	ff 75 f0             	pushl  -0x10(%ebp)
f0104718:	e8 81 a5 00 00       	call   f010ec9e <memset>
f010471d:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0104720:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (; i < 1024; i++) {
f0104727:	eb 18                	jmp    f0104741 <create_user_directory+0x4f>
		ptr_page_directory[i] = 0;
f0104729:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010472c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104733:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104736:	01 d0                	add    %edx,%eax
f0104738:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	//change this "return" according to your answer
	uint32 *ptr_page_directory = kmalloc(PAGE_SIZE);
	memset(ptr_page_directory, 0, PAGE_SIZE);
	int i = 0;
	for (; i < 1024; i++) {
f010473e:	ff 45 f4             	incl   -0xc(%ebp)
f0104741:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0104748:	7e df                	jle    f0104729 <create_user_directory+0x37>
		ptr_page_directory[i] = 0;
	}
	return ptr_page_directory;
f010474a:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f010474d:	c9                   	leave  
f010474e:	c3                   	ret    

f010474f <initialize_environment>:
// and initialize the kernel portion of the new environment's address space.
// Do NOT (yet) map anything into the user portion
// of the environment's virtual address space.
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory,
		unsigned int phys_user_page_directory) {
f010474f:	55                   	push   %ebp
f0104750:	89 e5                	mov    %esp,%ebp
f0104752:	53                   	push   %ebx
f0104753:	83 ec 24             	sub    $0x24,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f0104756:	8b 45 08             	mov    0x8(%ebp),%eax
f0104759:	8b 55 0c             	mov    0xc(%ebp),%edx
f010475c:	89 50 5c             	mov    %edx,0x5c(%eax)
	e->env_cr3 = phys_user_page_directory;
f010475f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104762:	8b 55 10             	mov    0x10(%ebp),%edx
f0104765:	89 50 60             	mov    %edx,0x60(%eax)

	//[TODODONE]: copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0; i < PDX(USER_TOP); i++) {
f0104768:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010476f:	eb 17                	jmp    f0104788 <initialize_environment+0x39>
		e->env_page_directory[i] = 0;
f0104771:	8b 45 08             	mov    0x8(%ebp),%eax
f0104774:	8b 40 5c             	mov    0x5c(%eax),%eax
f0104777:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010477a:	c1 e2 02             	shl    $0x2,%edx
f010477d:	01 d0                	add    %edx,%eax
f010477f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//[TODODONE]: copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0; i < PDX(USER_TOP); i++) {
f0104785:	ff 45 f4             	incl   -0xc(%ebp)
f0104788:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010478b:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0104790:	76 df                	jbe    f0104771 <initialize_environment+0x22>
		e->env_page_directory[i] = 0;
	}

	for (i = PDX(USER_TOP); i < 1024; i++) {
f0104792:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f0104799:	eb 22                	jmp    f01047bd <initialize_environment+0x6e>
		e->env_page_directory[i] = ptr_page_directory[i];
f010479b:	8b 45 08             	mov    0x8(%ebp),%eax
f010479e:	8b 40 5c             	mov    0x5c(%eax),%eax
f01047a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01047a4:	c1 e2 02             	shl    $0x2,%edx
f01047a7:	01 c2                	add    %eax,%edx
f01047a9:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f01047ae:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01047b1:	c1 e1 02             	shl    $0x2,%ecx
f01047b4:	01 c8                	add    %ecx,%eax
f01047b6:	8b 00                	mov    (%eax),%eax
f01047b8:	89 02                	mov    %eax,(%edx)
	//[TODODONE]: copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0; i < PDX(USER_TOP); i++) {
		e->env_page_directory[i] = 0;
	}

	for (i = PDX(USER_TOP); i < 1024; i++) {
f01047ba:	ff 45 f4             	incl   -0xc(%ebp)
f01047bd:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01047c4:	7e d5                	jle    f010479b <initialize_environment+0x4c>
	}

	// Allocate the page working set for both kernel and user
#if USE_KHEAP == 1
	{
		e->__uptr_pws = (struct WorkingSetElement*) USER_PAGES_WS_START;
f01047c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01047c9:	c7 80 f4 02 00 00 00 	movl   $0xa0000000,0x2f4(%eax)
f01047d0:	00 00 a0 

		e->ptr_pageWorkingSet = create_user_page_WS(e->page_WS_max_size);
f01047d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01047d6:	8b 40 74             	mov    0x74(%eax),%eax
f01047d9:	83 ec 0c             	sub    $0xc,%esp
f01047dc:	50                   	push   %eax
f01047dd:	e8 ea fe ff ff       	call   f01046cc <create_user_page_WS>
f01047e2:	83 c4 10             	add    $0x10,%esp
f01047e5:	89 c2                	mov    %eax,%edx
f01047e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047ea:	89 50 78             	mov    %edx,0x78(%eax)

		unsigned int sva = (unsigned int) e->ptr_pageWorkingSet;
f01047ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01047f0:	8b 40 78             	mov    0x78(%eax),%eax
f01047f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 nBytes = sizeof(struct WorkingSetElement) * e->page_WS_max_size;
f01047f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01047f9:	8b 50 74             	mov    0x74(%eax),%edx
f01047fc:	89 d0                	mov    %edx,%eax
f01047fe:	01 c0                	add    %eax,%eax
f0104800:	01 d0                	add    %edx,%eax
f0104802:	c1 e0 02             	shl    $0x2,%eax
f0104805:	89 45 e8             	mov    %eax,-0x18(%ebp)
		unsigned int dva = (unsigned int) (e->__uptr_pws);
f0104808:	8b 45 08             	mov    0x8(%ebp),%eax
f010480b:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
f0104811:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for (sva = (uint32) (e->ptr_pageWorkingSet);
f0104814:	8b 45 08             	mov    0x8(%ebp),%eax
f0104817:	8b 40 78             	mov    0x78(%eax),%eax
f010481a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010481d:	eb 45                	jmp    f0104864 <initialize_environment+0x115>
				sva < ((uint32) (e->ptr_pageWorkingSet) + nBytes); sva +=
						PAGE_SIZE, dva += PAGE_SIZE) {
			unsigned int pa = kheap_physical_address(sva);
f010481f:	83 ec 0c             	sub    $0xc,%esp
f0104822:	ff 75 f0             	pushl  -0x10(%ebp)
f0104825:	e8 98 69 00 00       	call   f010b1c2 <kheap_physical_address>
f010482a:	83 c4 10             	add    $0x10,%esp
f010482d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			map_frame(e->env_page_directory, to_frame_info(pa), (void*) dva,
f0104830:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0104833:	83 ec 0c             	sub    $0xc,%esp
f0104836:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104839:	e8 a7 fd ff ff       	call   f01045e5 <to_frame_info>
f010483e:	83 c4 10             	add    $0x10,%esp
f0104841:	89 c2                	mov    %eax,%edx
f0104843:	8b 45 08             	mov    0x8(%ebp),%eax
f0104846:	8b 40 5c             	mov    0x5c(%eax),%eax
f0104849:	6a 04                	push   $0x4
f010484b:	53                   	push   %ebx
f010484c:	52                   	push   %edx
f010484d:	50                   	push   %eax
f010484e:	e8 48 e7 ff ff       	call   f0102f9b <map_frame>
f0104853:	83 c4 10             	add    $0x10,%esp

		unsigned int sva = (unsigned int) e->ptr_pageWorkingSet;
		uint32 nBytes = sizeof(struct WorkingSetElement) * e->page_WS_max_size;
		unsigned int dva = (unsigned int) (e->__uptr_pws);
		for (sva = (uint32) (e->ptr_pageWorkingSet);
				sva < ((uint32) (e->ptr_pageWorkingSet) + nBytes); sva +=
f0104856:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
						PAGE_SIZE, dva += PAGE_SIZE) {
f010485d:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)

		unsigned int sva = (unsigned int) e->ptr_pageWorkingSet;
		uint32 nBytes = sizeof(struct WorkingSetElement) * e->page_WS_max_size;
		unsigned int dva = (unsigned int) (e->__uptr_pws);
		for (sva = (uint32) (e->ptr_pageWorkingSet);
				sva < ((uint32) (e->ptr_pageWorkingSet) + nBytes); sva +=
f0104864:	8b 45 08             	mov    0x8(%ebp),%eax
f0104867:	8b 40 78             	mov    0x78(%eax),%eax
f010486a:	89 c2                	mov    %eax,%edx
f010486c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010486f:	01 d0                	add    %edx,%eax
		e->ptr_pageWorkingSet = create_user_page_WS(e->page_WS_max_size);

		unsigned int sva = (unsigned int) e->ptr_pageWorkingSet;
		uint32 nBytes = sizeof(struct WorkingSetElement) * e->page_WS_max_size;
		unsigned int dva = (unsigned int) (e->__uptr_pws);
		for (sva = (uint32) (e->ptr_pageWorkingSet);
f0104871:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0104874:	77 a9                	ja     f010481f <initialize_environment+0xd0>
		( ((struct Env*)(UENVS+sizeof(struct Env)*env_index))->ptr_pageWorkingSet );
	}
#endif

	//initialize environment working set
	for (i = 0; i < (e->page_WS_max_size); i++) {
f0104876:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010487d:	eb 50                	jmp    f01048cf <initialize_environment+0x180>
		e->ptr_pageWorkingSet[i].virtual_address = 0;
f010487f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104882:	8b 48 78             	mov    0x78(%eax),%ecx
f0104885:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104888:	89 d0                	mov    %edx,%eax
f010488a:	01 c0                	add    %eax,%eax
f010488c:	01 d0                	add    %edx,%eax
f010488e:	c1 e0 02             	shl    $0x2,%eax
f0104891:	01 c8                	add    %ecx,%eax
f0104893:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].empty = 1;
f0104899:	8b 45 08             	mov    0x8(%ebp),%eax
f010489c:	8b 48 78             	mov    0x78(%eax),%ecx
f010489f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01048a2:	89 d0                	mov    %edx,%eax
f01048a4:	01 c0                	add    %eax,%eax
f01048a6:	01 d0                	add    %edx,%eax
f01048a8:	c1 e0 02             	shl    $0x2,%eax
f01048ab:	01 c8                	add    %ecx,%eax
f01048ad:	c6 40 04 01          	movb   $0x1,0x4(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0;
f01048b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01048b4:	8b 48 78             	mov    0x78(%eax),%ecx
f01048b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01048ba:	89 d0                	mov    %edx,%eax
f01048bc:	01 c0                	add    %eax,%eax
f01048be:	01 d0                	add    %edx,%eax
f01048c0:	c1 e0 02             	shl    $0x2,%eax
f01048c3:	01 c8                	add    %ecx,%eax
f01048c5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		( ((struct Env*)(UENVS+sizeof(struct Env)*env_index))->ptr_pageWorkingSet );
	}
#endif

	//initialize environment working set
	for (i = 0; i < (e->page_WS_max_size); i++) {
f01048cc:	ff 45 f4             	incl   -0xc(%ebp)
f01048cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01048d2:	8b 50 74             	mov    0x74(%eax),%edx
f01048d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01048d8:	39 c2                	cmp    %eax,%edx
f01048da:	77 a3                	ja     f010487f <initialize_environment+0x130>
		e->ptr_pageWorkingSet[i].virtual_address = 0;
		e->ptr_pageWorkingSet[i].empty = 1;
		e->ptr_pageWorkingSet[i].time_stamp = 0;
	}
	e->page_last_WS_index = 0;
f01048dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01048df:	c7 80 d4 02 00 00 00 	movl   $0x0,0x2d4(%eax)
f01048e6:	00 00 00 

	for (i = 0; i < __TWS_MAX_SIZE; i++) {
f01048e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01048f0:	eb 50                	jmp    f0104942 <initialize_environment+0x1f3>
		e->__ptr_tws[i].virtual_address = 0;
f01048f2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01048f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01048f8:	89 d0                	mov    %edx,%eax
f01048fa:	01 c0                	add    %eax,%eax
f01048fc:	01 d0                	add    %edx,%eax
f01048fe:	c1 e0 02             	shl    $0x2,%eax
f0104901:	01 c8                	add    %ecx,%eax
f0104903:	83 c0 7c             	add    $0x7c,%eax
f0104906:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010490c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010490f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104912:	89 d0                	mov    %edx,%eax
f0104914:	01 c0                	add    %eax,%eax
f0104916:	01 d0                	add    %edx,%eax
f0104918:	c1 e0 02             	shl    $0x2,%eax
f010491b:	01 c8                	add    %ecx,%eax
f010491d:	83 e8 80             	sub    $0xffffff80,%eax
f0104920:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0;
f0104923:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0104926:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104929:	89 d0                	mov    %edx,%eax
f010492b:	01 c0                	add    %eax,%eax
f010492d:	01 d0                	add    %edx,%eax
f010492f:	c1 e0 02             	shl    $0x2,%eax
f0104932:	01 c8                	add    %ecx,%eax
f0104934:	05 84 00 00 00       	add    $0x84,%eax
f0104939:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].empty = 1;
		e->ptr_pageWorkingSet[i].time_stamp = 0;
	}
	e->page_last_WS_index = 0;

	for (i = 0; i < __TWS_MAX_SIZE; i++) {
f010493f:	ff 45 f4             	incl   -0xc(%ebp)
f0104942:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0104946:	7e aa                	jle    f01048f2 <initialize_environment+0x1a3>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0;
	}

	e->table_last_WS_index = 0;
f0104948:	8b 45 08             	mov    0x8(%ebp),%eax
f010494b:	c7 80 d8 02 00 00 00 	movl   $0x0,0x2d8(%eax)
f0104952:	00 00 00 

	e->pageFaultsCounter = 0;
f0104955:	8b 45 08             	mov    0x8(%ebp),%eax
f0104958:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%eax)
f010495f:	00 00 00 
	e->tableFaultsCounter = 0;
f0104962:	8b 45 08             	mov    0x8(%ebp),%eax
f0104965:	c7 80 e0 02 00 00 00 	movl   $0x0,0x2e0(%eax)
f010496c:	00 00 00 

	e->nModifiedPages = 0;
f010496f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104972:	c7 80 e4 02 00 00 00 	movl   $0x0,0x2e4(%eax)
f0104979:	00 00 00 
	e->nNotModifiedPages = 0;
f010497c:	8b 45 08             	mov    0x8(%ebp),%eax
f010497f:	c7 80 e8 02 00 00 00 	movl   $0x0,0x2e8(%eax)
f0104986:	00 00 00 

	e->shared_free_address = USER_SHARED_MEM_START;
f0104989:	8b 45 08             	mov    0x8(%ebp),%eax
f010498c:	c7 80 f0 02 00 00 00 	movl   $0xa0000000,0x2f0(%eax)
f0104993:	00 00 a0 

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f0104996:	83 ec 0c             	sub    $0xc,%esp
f0104999:	ff 75 08             	pushl  0x8(%ebp)
f010499c:	e8 91 0c 00 00       	call   f0105632 <complete_environment_initialization>
f01049a1:	83 c4 10             	add    $0x10,%esp
}
f01049a4:	90                   	nop
f01049a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01049a8:	c9                   	leave  
f01049a9:	c3                   	ret    

f01049aa <program_segment_alloc_map_copy_workingset>:
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e,
		struct ProgramSegment* seg, uint32* allocated_pages,
		uint32 remaining_ws_pages, uint32* lastTableNumber) {
f01049aa:	55                   	push   %ebp
f01049ab:	89 e5                	mov    %esp,%ebp
f01049ad:	83 ec 48             	sub    $0x48,%esp
	void *vaddr = seg->virtual_address;
f01049b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049b3:	8b 40 0c             	mov    0xc(%eax),%eax
f01049b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f01049b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049bc:	8b 40 08             	mov    0x8(%eax),%eax
f01049bf:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32 )vaddr + length, PAGE_SIZE);
f01049c2:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f01049c9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01049cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01049cf:	01 c2                	add    %eax,%edx
f01049d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01049d4:	01 d0                	add    %edx,%eax
f01049d6:	48                   	dec    %eax
f01049d7:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01049da:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01049dd:	ba 00 00 00 00       	mov    $0x0,%edx
f01049e2:	f7 75 dc             	divl   -0x24(%ebp)
f01049e5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01049e8:	29 d0                	sub    %edx,%eax
f01049ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32 )vaddr, PAGE_SIZE);
f01049ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01049f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01049f3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01049f6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01049fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r;
	uint32 i = 0;
f01049fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct Frame_Info *p = NULL;
f0104a05:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)

	*allocated_pages = 0;
f0104a0c:	8b 45 10             	mov    0x10(%ebp),%eax
f0104a0f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp") != 0)
f0104a15:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f0104a1c:	0f 85 68 01 00 00    	jne    f0104b8a <program_segment_alloc_map_copy_workingset+0x1e0>
f0104a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a25:	8b 80 ec 02 00 00    	mov    0x2ec(%eax),%eax
f0104a2b:	83 ec 08             	sub    $0x8,%esp
f0104a2e:	68 bd 0e 11 f0       	push   $0xf0110ebd
f0104a33:	50                   	push   %eax
f0104a34:	e8 83 a1 00 00       	call   f010ebbc <strcmp>
f0104a39:	83 c4 10             	add    $0x10,%esp
f0104a3c:	85 c0                	test   %eax,%eax
f0104a3e:	0f 84 46 01 00 00    	je     f0104b8a <program_segment_alloc_map_copy_workingset+0x1e0>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages : 6;
f0104a44:	8b 45 14             	mov    0x14(%ebp),%eax
f0104a47:	83 f8 06             	cmp    $0x6,%eax
f0104a4a:	76 05                	jbe    f0104a51 <program_segment_alloc_map_copy_workingset+0xa7>
f0104a4c:	b8 06 00 00 00       	mov    $0x6,%eax
f0104a51:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i < remaining_ws_pages; i++, iVA += PAGE_SIZE) {
f0104a54:	e9 31 01 00 00       	jmp    f0104b8a <program_segment_alloc_map_copy_workingset+0x1e0>
		// Allocate a page
		allocate_frame(&p);
f0104a59:	83 ec 0c             	sub    $0xc,%esp
f0104a5c:	8d 45 c0             	lea    -0x40(%ebp),%eax
f0104a5f:	50                   	push   %eax
f0104a60:	e8 33 e1 ff ff       	call   f0102b98 <allocate_frame>
f0104a65:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, (void *) iVA,
f0104a68:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0104a6b:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0104a6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a71:	8b 40 5c             	mov    0x5c(%eax),%eax
f0104a74:	6a 06                	push   $0x6
f0104a76:	51                   	push   %ecx
f0104a77:	52                   	push   %edx
f0104a78:	50                   	push   %eax
f0104a79:	e8 d3 e6 ff ff       	call   f0103151 <loadtime_map_frame>
f0104a7e:	83 c4 10             	add    $0x10,%esp

		LOG_STATMENT(
				cprintf("Updating working set entry # %d",
						e->page_last_WS_index));

		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
f0104a81:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a84:	8b 48 78             	mov    0x78(%eax),%ecx
f0104a87:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a8a:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f0104a90:	89 d0                	mov    %edx,%eax
f0104a92:	01 c0                	add    %eax,%eax
f0104a94:	01 d0                	add    %edx,%eax
f0104a96:	c1 e0 02             	shl    $0x2,%eax
f0104a99:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0104a9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104a9f:	89 02                	mov    %eax,(%edx)
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
f0104aa1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104aa4:	8b 48 78             	mov    0x78(%eax),%ecx
f0104aa7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104aaa:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f0104ab0:	89 d0                	mov    %edx,%eax
f0104ab2:	01 c0                	add    %eax,%eax
f0104ab4:	01 d0                	add    %edx,%eax
f0104ab6:	c1 e0 02             	shl    $0x2,%eax
f0104ab9:	01 c8                	add    %ecx,%eax
f0104abb:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
f0104abf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ac2:	8b 48 78             	mov    0x78(%eax),%ecx
f0104ac5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ac8:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f0104ace:	89 d0                	mov    %edx,%eax
f0104ad0:	01 c0                	add    %eax,%eax
f0104ad2:	01 d0                	add    %edx,%eax
f0104ad4:	c1 e0 02             	shl    $0x2,%eax
f0104ad7:	01 c8                	add    %ecx,%eax
f0104ad9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

		e->page_last_WS_index++;
f0104ae0:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae3:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f0104ae9:	8d 50 01             	lea    0x1(%eax),%edx
f0104aec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104aef:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)
		e->page_last_WS_index %= (e->page_WS_max_size);
f0104af5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af8:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f0104afe:	8b 55 08             	mov    0x8(%ebp),%edx
f0104b01:	8b 4a 74             	mov    0x74(%edx),%ecx
f0104b04:	ba 00 00 00 00       	mov    $0x0,%edx
f0104b09:	f7 f1                	div    %ecx
f0104b0b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0e:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)

		//if a new table is created during the mapping, add it to the table working set
		if (PDX(iVA) != (*lastTableNumber)) {
f0104b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b17:	c1 e8 16             	shr    $0x16,%eax
f0104b1a:	89 c2                	mov    %eax,%edx
f0104b1c:	8b 45 18             	mov    0x18(%ebp),%eax
f0104b1f:	8b 00                	mov    (%eax),%eax
f0104b21:	39 c2                	cmp    %eax,%edx
f0104b23:	74 4e                	je     f0104b73 <program_segment_alloc_map_copy_workingset+0x1c9>
			addTableToTableWorkingSet(e, ROUNDDOWN(iVA, PAGE_SIZE*1024));
f0104b25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b28:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0104b2b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0104b2e:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0104b33:	83 ec 08             	sub    $0x8,%esp
f0104b36:	50                   	push   %eax
f0104b37:	ff 75 08             	pushl  0x8(%ebp)
f0104b3a:	e8 6f f2 ff ff       	call   f0103dae <addTableToTableWorkingSet>
f0104b3f:	83 c4 10             	add    $0x10,%esp
			if (e->table_last_WS_index == 0)
f0104b42:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b45:	8b 80 d8 02 00 00    	mov    0x2d8(%eax),%eax
f0104b4b:	85 c0                	test   %eax,%eax
f0104b4d:	75 17                	jne    f0104b66 <program_segment_alloc_map_copy_workingset+0x1bc>
				panic(
f0104b4f:	83 ec 04             	sub    $0x4,%esp
f0104b52:	68 d0 14 11 f0       	push   $0xf01114d0
f0104b57:	68 a2 01 00 00       	push   $0x1a2
f0104b5c:	68 73 15 11 f0       	push   $0xf0111573
f0104b61:	e8 f6 b5 ff ff       	call   f010015c <_panic>
						"\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
			(*lastTableNumber) = PDX(iVA);
f0104b66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b69:	c1 e8 16             	shr    $0x16,%eax
f0104b6c:	89 c2                	mov    %eax,%edx
f0104b6e:	8b 45 18             	mov    0x18(%ebp),%eax
f0104b71:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages)++;
f0104b73:	8b 45 10             	mov    0x10(%ebp),%eax
f0104b76:	8b 00                	mov    (%eax),%eax
f0104b78:	8d 50 01             	lea    0x1(%eax),%edx
f0104b7b:	8b 45 10             	mov    0x10(%ebp),%eax
f0104b7e:	89 10                	mov    %edx,(%eax)

	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp") != 0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages : 6;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i < remaining_ws_pages; i++, iVA += PAGE_SIZE) {
f0104b80:	ff 45 f0             	incl   -0x10(%ebp)
f0104b83:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0104b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b8d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0104b90:	73 0c                	jae    f0104b9e <program_segment_alloc_map_copy_workingset+0x1f4>
f0104b92:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104b95:	3b 45 14             	cmp    0x14(%ebp),%eax
f0104b98:	0f 82 bb fe ff ff    	jb     f0104a59 <program_segment_alloc_map_copy_workingset+0xaf>
		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages)++;
	}

	uint8 *src_ptr = (uint8 *) (seg->ptr_start);
f0104b9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ba1:	8b 00                	mov    (%eax),%eax
f0104ba3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f0104ba6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ba9:	8b 40 0c             	mov    0xc(%eax),%eax
f0104bac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(
			cprintf("copying data to allocated area VA %x from source %x",
					dst_ptr, src_ptr));
	while ((uint32) dst_ptr
f0104baf:	eb 10                	jmp    f0104bc1 <program_segment_alloc_map_copy_workingset+0x217>
			< (ROUNDDOWN((uint32 )vaddr, PAGE_SIZE)
					+ (*allocated_pages) * PAGE_SIZE)
			&& ((uint32) dst_ptr < ((uint32) vaddr + seg->size_in_file))) {
		*dst_ptr = *src_ptr;
f0104bb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104bb4:	8a 10                	mov    (%eax),%dl
f0104bb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104bb9:	88 10                	mov    %dl,(%eax)
		dst_ptr++;
f0104bbb:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++;
f0104bbe:	ff 45 ec             	incl   -0x14(%ebp)

	LOG_STATMENT(
			cprintf("copying data to allocated area VA %x from source %x",
					dst_ptr, src_ptr));
	while ((uint32) dst_ptr
			< (ROUNDDOWN((uint32 )vaddr, PAGE_SIZE)
f0104bc1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104bc4:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0104bc7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0104bca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104bcf:	89 c2                	mov    %eax,%edx
					+ (*allocated_pages) * PAGE_SIZE)
f0104bd1:	8b 45 10             	mov    0x10(%ebp),%eax
f0104bd4:	8b 00                	mov    (%eax),%eax
f0104bd6:	c1 e0 0c             	shl    $0xc,%eax
f0104bd9:	01 c2                	add    %eax,%edx
	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(
			cprintf("copying data to allocated area VA %x from source %x",
					dst_ptr, src_ptr));
	while ((uint32) dst_ptr
f0104bdb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104bde:	39 c2                	cmp    %eax,%edx
f0104be0:	76 1d                	jbe    f0104bff <program_segment_alloc_map_copy_workingset+0x255>
			< (ROUNDDOWN((uint32 )vaddr, PAGE_SIZE)
					+ (*allocated_pages) * PAGE_SIZE)
			&& ((uint32) dst_ptr < ((uint32) vaddr + seg->size_in_file))) {
f0104be2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be5:	8b 50 04             	mov    0x4(%eax),%edx
f0104be8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104beb:	01 c2                	add    %eax,%edx
f0104bed:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104bf0:	39 c2                	cmp    %eax,%edx
f0104bf2:	77 bd                	ja     f0104bb1 <program_segment_alloc_map_copy_workingset+0x207>
		*dst_ptr = *src_ptr;
		dst_ptr++;
		src_ptr++;
	}
	LOG_STRING("zeroing remaining page space");
	while ((uint32) dst_ptr
f0104bf4:	eb 09                	jmp    f0104bff <program_segment_alloc_map_copy_workingset+0x255>
			< (ROUNDDOWN((uint32 )vaddr, PAGE_SIZE)
					+ (*allocated_pages) * PAGE_SIZE)) {
		*dst_ptr = 0;
f0104bf6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104bf9:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++;
f0104bfc:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++;
		src_ptr++;
	}
	LOG_STRING("zeroing remaining page space");
	while ((uint32) dst_ptr
			< (ROUNDDOWN((uint32 )vaddr, PAGE_SIZE)
f0104bff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104c02:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0104c05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0104c08:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104c0d:	89 c2                	mov    %eax,%edx
					+ (*allocated_pages) * PAGE_SIZE)) {
f0104c0f:	8b 45 10             	mov    0x10(%ebp),%eax
f0104c12:	8b 00                	mov    (%eax),%eax
f0104c14:	c1 e0 0c             	shl    $0xc,%eax
f0104c17:	01 c2                	add    %eax,%edx
		*dst_ptr = *src_ptr;
		dst_ptr++;
		src_ptr++;
	}
	LOG_STRING("zeroing remaining page space");
	while ((uint32) dst_ptr
f0104c19:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104c1c:	39 c2                	cmp    %eax,%edx
f0104c1e:	77 d6                	ja     f0104bf6 <program_segment_alloc_map_copy_workingset+0x24c>
	//	{
	//		uint32 *ptr_page_table;
	//		get_page_table(e->env_pgdir, (void *)iVA, 1, &ptr_page_table);
	//	}
	//	LOG_STRING("page tables created successfully");
	return 0;
f0104c20:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <env_create>:

// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size) {
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	57                   	push   %edi
f0104c2b:	56                   	push   %esi
f0104c2c:	53                   	push   %ebx
f0104c2d:	81 ec ec 00 00 00    	sub    $0xec,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f0104c33:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(
f0104c3a:	83 ec 0c             	sub    $0xc,%esp
f0104c3d:	ff 75 08             	pushl  0x8(%ebp)
f0104c40:	e8 b9 0d 00 00       	call   f01059fe <get_user_program_info>
f0104c45:	83 c4 10             	add    $0x10,%esp
f0104c48:	89 45 b8             	mov    %eax,-0x48(%ebp)
			user_program_name);
	if (ptr_user_program_info == 0)
f0104c4b:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0104c4f:	75 0a                	jne    f0104c5b <env_create+0x34>
		return NULL;
f0104c51:	b8 00 00 00 00       	mov    $0x0,%eax
f0104c56:	e9 18 06 00 00       	jmp    f0105273 <env_create+0x64c>
	ptr_program_start = ptr_user_program_info->ptr_start;
f0104c5b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0104c5e:	8b 40 08             	mov    0x8(%eax),%eax
f0104c61:	89 45 bc             	mov    %eax,-0x44(%ebp)
	//	}

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f0104c64:	c7 85 50 ff ff ff 00 	movl   $0x0,-0xb0(%ebp)
f0104c6b:	00 00 00 
	if (allocate_environment(&e) < 0) {
f0104c6e:	83 ec 0c             	sub    $0xc,%esp
f0104c71:	8d 85 50 ff ff ff    	lea    -0xb0(%ebp),%eax
f0104c77:	50                   	push   %eax
f0104c78:	e8 ae f9 ff ff       	call   f010462b <allocate_environment>
f0104c7d:	83 c4 10             	add    $0x10,%esp
f0104c80:	85 c0                	test   %eax,%eax
f0104c82:	79 0a                	jns    f0104c8e <env_create+0x67>
		return 0;
f0104c84:	b8 00 00 00 00       	mov    $0x0,%eax
f0104c89:	e9 e5 05 00 00       	jmp    f0105273 <env_create+0x64c>
	}

	//[2.5 - 2012] Set program name inside the environment
	e->prog_name = ptr_user_program_info->name;
f0104c8e:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104c94:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0104c97:	8b 12                	mov    (%edx),%edx
f0104c99:	89 90 ec 02 00 00    	mov    %edx,0x2ec(%eax)
	//[3] allocate a frame for the page directory, Don't forget to set the references of the allocated frame.
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
	if (USE_KHEAP) {
		ptr_user_page_directory = create_user_directory();
f0104c9f:	e8 4e fa ff ff       	call   f01046f2 <create_user_directory>
f0104ca4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		phys_user_page_directory = kheap_physical_address(
f0104ca7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0104caa:	83 ec 0c             	sub    $0xc,%esp
f0104cad:	50                   	push   %eax
f0104cae:	e8 0f 65 00 00       	call   f010b1c2 <kheap_physical_address>
f0104cb3:	83 c4 10             	add    $0x10,%esp
f0104cb6:	89 45 b0             	mov    %eax,-0x50(%ebp)

	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f0104cb9:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104cbf:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104cc2:	89 50 74             	mov    %edx,0x74(%eax)

	initialize_environment(e, ptr_user_page_directory,
f0104cc5:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104ccb:	83 ec 04             	sub    $0x4,%esp
f0104cce:	ff 75 b0             	pushl  -0x50(%ebp)
f0104cd1:	ff 75 b4             	pushl  -0x4c(%ebp)
f0104cd4:	50                   	push   %eax
f0104cd5:	e8 75 fa ff ff       	call   f010474f <initialize_environment>
f0104cda:	83 c4 10             	add    $0x10,%esp

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0104cdd:	0f 20 d8             	mov    %cr3,%eax
f0104ce0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	return val;
f0104ce3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[6] switch to user page directory
	// Hint: use rcr3() and lcr3()
	uint32 kern_phys_pgdir = rcr3();
f0104ce6:	89 45 a8             	mov    %eax,-0x58(%ebp)
	lcr3(e->env_cr3);
f0104ce9:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104cef:	8b 40 60             	mov    0x60(%eax),%eax
f0104cf2:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0104cf8:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0104cfe:	0f 22 d8             	mov    %eax,%cr3

	//[7] load each program segment into user virtual space
	struct ProgramSegment* seg = NULL; //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f0104d01:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int segment_counter = 0;
f0104d08:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 remaining_ws_pages = (e->page_WS_max_size) - 1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f0104d0f:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104d15:	8b 40 74             	mov    0x74(%eax),%eax
f0104d18:	48                   	dec    %eax
f0104d19:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 lastTableNumber = 0xffffffff;
f0104d1c:	c7 85 4c ff ff ff ff 	movl   $0xffffffff,-0xb4(%ebp)
f0104d23:	ff ff ff 

	PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start) {
f0104d26:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
f0104d2c:	83 ec 08             	sub    $0x8,%esp
f0104d2f:	ff 75 bc             	pushl  -0x44(%ebp)
f0104d32:	50                   	push   %eax
f0104d33:	e8 ad 0b 00 00       	call   f01058e5 <PROGRAM_SEGMENT_FIRST>
f0104d38:	83 c4 0c             	add    $0xc,%esp
f0104d3b:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0104d41:	8d 95 08 ff ff ff    	lea    -0xf8(%ebp),%edx
f0104d47:	b9 05 00 00 00       	mov    $0x5,%ecx
f0104d4c:	89 c7                	mov    %eax,%edi
f0104d4e:	89 d6                	mov    %edx,%esi
f0104d50:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0104d52:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0104d58:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0104d5b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104d5e:	8b 40 10             	mov    0x10(%eax),%eax
f0104d61:	83 f8 ff             	cmp    $0xffffffff,%eax
f0104d64:	75 07                	jne    f0104d6d <env_create+0x146>
f0104d66:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0104d6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104d70:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0104d73:	e9 0f 03 00 00       	jmp    f0105087 <env_create+0x460>
		segment_counter++;
f0104d78:	ff 45 e0             	incl   -0x20(%ebp)
						segment_counter, seg->size_in_file, seg->size_in_memory,
						seg->virtual_address));
		LOG_STRING(
				"===============================================================================");

		uint32 allocated_pages = 0;
f0104d7b:	c7 85 30 ff ff ff 00 	movl   $0x0,-0xd0(%ebp)
f0104d82:	00 00 00 
		program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages,
f0104d85:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104d8b:	83 ec 0c             	sub    $0xc,%esp
f0104d8e:	8d 95 4c ff ff ff    	lea    -0xb4(%ebp),%edx
f0104d94:	52                   	push   %edx
f0104d95:	ff 75 dc             	pushl  -0x24(%ebp)
f0104d98:	8d 95 30 ff ff ff    	lea    -0xd0(%ebp),%edx
f0104d9e:	52                   	push   %edx
f0104d9f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104da2:	50                   	push   %eax
f0104da3:	e8 02 fc ff ff       	call   f01049aa <program_segment_alloc_map_copy_workingset>
f0104da8:	83 c4 20             	add    $0x20,%esp
				remaining_ws_pages, &lastTableNumber);

		remaining_ws_pages -= allocated_pages;
f0104dab:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f0104db1:	29 45 dc             	sub    %eax,-0x24(%ebp)
		LOG_STATMENT(
				cprintf("SEGMENT: remaining WS pages after allocation = %d",
						remaining_ws_pages));

		///[1] temporary initialize 1st page in memory then writing it on page file
		uint32 dataSrc_va = (uint32) seg->ptr_start;
f0104db4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104db7:	8b 00                	mov    (%eax),%eax
f0104db9:	89 45 a0             	mov    %eax,-0x60(%ebp)
		uint32 seg_va = (uint32) seg->virtual_address;
f0104dbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104dbf:	8b 40 0c             	mov    0xc(%eax),%eax
f0104dc2:	89 45 9c             	mov    %eax,-0x64(%ebp)

		uint32 start_first_page = ROUNDDOWN(seg_va, PAGE_SIZE);
f0104dc5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0104dc8:	89 45 98             	mov    %eax,-0x68(%ebp)
f0104dcb:	8b 45 98             	mov    -0x68(%ebp),%eax
f0104dce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104dd3:	89 45 94             	mov    %eax,-0x6c(%ebp)
		uint32 end_first_page = ROUNDUP(seg_va, PAGE_SIZE);
f0104dd6:	c7 45 90 00 10 00 00 	movl   $0x1000,-0x70(%ebp)
f0104ddd:	8b 55 9c             	mov    -0x64(%ebp),%edx
f0104de0:	8b 45 90             	mov    -0x70(%ebp),%eax
f0104de3:	01 d0                	add    %edx,%eax
f0104de5:	48                   	dec    %eax
f0104de6:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0104de9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0104dec:	ba 00 00 00 00       	mov    $0x0,%edx
f0104df1:	f7 75 90             	divl   -0x70(%ebp)
f0104df4:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0104df7:	29 d0                	sub    %edx,%eax
f0104df9:	89 45 88             	mov    %eax,-0x78(%ebp)
		uint32 offset_first_page = seg_va - start_first_page;
f0104dfc:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0104dff:	2b 45 94             	sub    -0x6c(%ebp),%eax
f0104e02:	89 45 84             	mov    %eax,-0x7c(%ebp)

		memset(ptr_temp_page, 0, PAGE_SIZE);
f0104e05:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f0104e0a:	83 ec 04             	sub    $0x4,%esp
f0104e0d:	68 00 10 00 00       	push   $0x1000
f0104e12:	6a 00                	push   $0x0
f0104e14:	50                   	push   %eax
f0104e15:	e8 84 9e 00 00       	call   f010ec9e <memset>
f0104e1a:	83 c4 10             	add    $0x10,%esp
		uint8 *src_ptr = (uint8*) dataSrc_va;
f0104e1d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0104e20:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		uint8 *dst_ptr = (uint8*) (ptr_temp_page + offset_first_page);
f0104e23:	8b 15 94 52 45 f0    	mov    0xf0455294,%edx
f0104e29:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0104e2c:	01 d0                	add    %edx,%eax
f0104e2e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		int i;
		for (i = seg_va; i < end_first_page; i++, src_ptr++, dst_ptr++) {
f0104e31:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0104e34:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0104e37:	eb 13                	jmp    f0104e4c <env_create+0x225>
			*dst_ptr = *src_ptr;
f0104e39:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0104e3c:	8a 10                	mov    (%eax),%dl
f0104e3e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0104e41:	88 10                	mov    %dl,(%eax)

		memset(ptr_temp_page, 0, PAGE_SIZE);
		uint8 *src_ptr = (uint8*) dataSrc_va;
		uint8 *dst_ptr = (uint8*) (ptr_temp_page + offset_first_page);
		int i;
		for (i = seg_va; i < end_first_page; i++, src_ptr++, dst_ptr++) {
f0104e43:	ff 45 cc             	incl   -0x34(%ebp)
f0104e46:	ff 45 d4             	incl   -0x2c(%ebp)
f0104e49:	ff 45 d0             	incl   -0x30(%ebp)
f0104e4c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0104e4f:	3b 45 88             	cmp    -0x78(%ebp),%eax
f0104e52:	72 e5                	jb     f0104e39 <env_create+0x212>
			*dst_ptr = *src_ptr;
		}

		if (pf_add_env_page(e, start_first_page,
f0104e54:	8b 15 94 52 45 f0    	mov    0xf0455294,%edx
f0104e5a:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104e60:	83 ec 04             	sub    $0x4,%esp
f0104e63:	52                   	push   %edx
f0104e64:	ff 75 94             	pushl  -0x6c(%ebp)
f0104e67:	50                   	push   %eax
f0104e68:	e8 78 53 00 00       	call   f010a1e5 <pf_add_env_page>
f0104e6d:	83 c4 10             	add    $0x10,%esp
f0104e70:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104e73:	75 17                	jne    f0104e8c <env_create+0x265>
				ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
			panic(
f0104e75:	83 ec 04             	sub    $0x4,%esp
f0104e78:	68 8c 15 11 f0       	push   $0xf011158c
f0104e7d:	68 50 02 00 00       	push   $0x250
f0104e82:	68 73 15 11 f0       	push   $0xf0111573
f0104e87:	e8 d0 b2 ff ff       	call   f010015c <_panic>

		//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");

		///[2] Start writing the segment ,from 2nd page until before last page, to page file ...

		uint32 start_last_page = ROUNDDOWN(seg_va + seg->size_in_file,
f0104e8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e8f:	8b 50 04             	mov    0x4(%eax),%edx
f0104e92:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0104e95:	01 d0                	add    %edx,%eax
f0104e97:	89 45 80             	mov    %eax,-0x80(%ebp)
f0104e9a:	8b 45 80             	mov    -0x80(%ebp),%eax
f0104e9d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104ea2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				PAGE_SIZE);
		uint32 end_last_page = seg_va + seg->size_in_file;
f0104ea8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104eab:	8b 50 04             	mov    0x4(%eax),%edx
f0104eae:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0104eb1:	01 d0                	add    %edx,%eax
f0104eb3:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (i = end_first_page; i < start_last_page; i += PAGE_SIZE, src_ptr +=
f0104eb9:	8b 45 88             	mov    -0x78(%ebp),%eax
f0104ebc:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0104ebf:	eb 43                	jmp    f0104f04 <env_create+0x2dd>
				PAGE_SIZE) {
			if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f0104ec1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0104ec4:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104eca:	83 ec 04             	sub    $0x4,%esp
f0104ecd:	ff 75 d4             	pushl  -0x2c(%ebp)
f0104ed0:	52                   	push   %edx
f0104ed1:	50                   	push   %eax
f0104ed2:	e8 0e 53 00 00       	call   f010a1e5 <pf_add_env_page>
f0104ed7:	83 c4 10             	add    $0x10,%esp
f0104eda:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104edd:	75 17                	jne    f0104ef6 <env_create+0x2cf>
				panic(
f0104edf:	83 ec 04             	sub    $0x4,%esp
f0104ee2:	68 8c 15 11 f0       	push   $0xf011158c
f0104ee7:	68 5e 02 00 00       	push   $0x25e
f0104eec:	68 73 15 11 f0       	push   $0xf0111573
f0104ef1:	e8 66 b2 ff ff       	call   f010015c <_panic>

		uint32 start_last_page = ROUNDDOWN(seg_va + seg->size_in_file,
				PAGE_SIZE);
		uint32 end_last_page = seg_va + seg->size_in_file;

		for (i = end_first_page; i < start_last_page; i += PAGE_SIZE, src_ptr +=
f0104ef6:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0104efd:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f0104f04:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0104f07:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f0104f0d:	72 b2                	jb     f0104ec1 <env_create+0x29a>
		}
		//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

		///[3] temporary initialize last page in memory then writing it on page file

		dst_ptr = (uint8*) ptr_temp_page;
f0104f0f:	a1 94 52 45 f0       	mov    0xf0455294,%eax
f0104f14:	89 45 d0             	mov    %eax,-0x30(%ebp)
		memset(dst_ptr, 0, PAGE_SIZE);
f0104f17:	83 ec 04             	sub    $0x4,%esp
f0104f1a:	68 00 10 00 00       	push   $0x1000
f0104f1f:	6a 00                	push   $0x0
f0104f21:	ff 75 d0             	pushl  -0x30(%ebp)
f0104f24:	e8 75 9d 00 00       	call   f010ec9e <memset>
f0104f29:	83 c4 10             	add    $0x10,%esp

		for (i = start_last_page; i < end_last_page;
f0104f2c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0104f32:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0104f35:	eb 13                	jmp    f0104f4a <env_create+0x323>
				i++, src_ptr++, dst_ptr++) {
			*dst_ptr = *src_ptr;
f0104f37:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0104f3a:	8a 10                	mov    (%eax),%dl
f0104f3c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0104f3f:	88 10                	mov    %dl,(%eax)

		dst_ptr = (uint8*) ptr_temp_page;
		memset(dst_ptr, 0, PAGE_SIZE);

		for (i = start_last_page; i < end_last_page;
				i++, src_ptr++, dst_ptr++) {
f0104f41:	ff 45 cc             	incl   -0x34(%ebp)
f0104f44:	ff 45 d4             	incl   -0x2c(%ebp)
f0104f47:	ff 45 d0             	incl   -0x30(%ebp)
		///[3] temporary initialize last page in memory then writing it on page file

		dst_ptr = (uint8*) ptr_temp_page;
		memset(dst_ptr, 0, PAGE_SIZE);

		for (i = start_last_page; i < end_last_page;
f0104f4a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0104f4d:	3b 85 78 ff ff ff    	cmp    -0x88(%ebp),%eax
f0104f53:	72 e2                	jb     f0104f37 <env_create+0x310>
				i++, src_ptr++, dst_ptr++) {
			*dst_ptr = *src_ptr;
		}
		if (pf_add_env_page(e, start_last_page,
f0104f55:	8b 15 94 52 45 f0    	mov    0xf0455294,%edx
f0104f5b:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104f61:	83 ec 04             	sub    $0x4,%esp
f0104f64:	52                   	push   %edx
f0104f65:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f0104f6b:	50                   	push   %eax
f0104f6c:	e8 74 52 00 00       	call   f010a1e5 <pf_add_env_page>
f0104f71:	83 c4 10             	add    $0x10,%esp
f0104f74:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104f77:	75 17                	jne    f0104f90 <env_create+0x369>
				ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
			panic(
f0104f79:	83 ec 04             	sub    $0x4,%esp
f0104f7c:	68 8c 15 11 f0       	push   $0xf011158c
f0104f81:	68 6f 02 00 00       	push   $0x26f
f0104f86:	68 73 15 11 f0       	push   $0xf0111573
f0104f8b:	e8 cc b1 ff ff       	call   f010015c <_panic>

		//LOG_STRING(" -------------------- PAGE FILE: last page is written");

		///[4] writing the remaining seg->size_in_memory pages to disk

		uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,
f0104f90:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f0104f97:	10 00 00 
f0104f9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f9d:	8b 50 04             	mov    0x4(%eax),%edx
f0104fa0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0104fa3:	01 c2                	add    %eax,%edx
f0104fa5:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0104fab:	01 d0                	add    %edx,%eax
f0104fad:	48                   	dec    %eax
f0104fae:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f0104fb4:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0104fba:	ba 00 00 00 00       	mov    $0x0,%edx
f0104fbf:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f0104fc5:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0104fcb:	29 d0                	sub    %edx,%eax
f0104fcd:	89 45 c8             	mov    %eax,-0x38(%ebp)
				PAGE_SIZE);
		uint32 remainingLength = (seg_va + seg->size_in_memory)
f0104fd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104fd3:	8b 50 08             	mov    0x8(%eax),%edx
f0104fd6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0104fd9:	01 d0                	add    %edx,%eax
f0104fdb:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0104fde:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
				- start_remaining_area;

		for (i = 0; i < ROUNDUP(remainingLength, PAGE_SIZE);
f0104fe4:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0104feb:	eb 41                	jmp    f010502e <env_create+0x407>
				i += PAGE_SIZE, start_remaining_area += PAGE_SIZE) {
			if (pf_add_empty_env_page(e, start_remaining_area,
f0104fed:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0104ff3:	83 ec 04             	sub    $0x4,%esp
f0104ff6:	6a 01                	push   $0x1
f0104ff8:	ff 75 c8             	pushl  -0x38(%ebp)
f0104ffb:	50                   	push   %eax
f0104ffc:	e8 0b 51 00 00       	call   f010a10c <pf_add_empty_env_page>
f0105001:	83 c4 10             	add    $0x10,%esp
f0105004:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0105007:	75 17                	jne    f0105020 <env_create+0x3f9>
					1) == E_NO_PAGE_FILE_SPACE)
				panic(
f0105009:	83 ec 04             	sub    $0x4,%esp
f010500c:	68 8c 15 11 f0       	push   $0xf011158c
f0105011:	68 7f 02 00 00       	push   $0x27f
f0105016:	68 73 15 11 f0       	push   $0xf0111573
f010501b:	e8 3c b1 ff ff       	call   f010015c <_panic>
				PAGE_SIZE);
		uint32 remainingLength = (seg_va + seg->size_in_memory)
				- start_remaining_area;

		for (i = 0; i < ROUNDUP(remainingLength, PAGE_SIZE);
				i += PAGE_SIZE, start_remaining_area += PAGE_SIZE) {
f0105020:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0105027:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
		uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,
				PAGE_SIZE);
		uint32 remainingLength = (seg_va + seg->size_in_memory)
				- start_remaining_area;

		for (i = 0; i < ROUNDUP(remainingLength, PAGE_SIZE);
f010502e:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f0105035:	10 00 00 
f0105038:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010503e:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f0105044:	01 d0                	add    %edx,%eax
f0105046:	48                   	dec    %eax
f0105047:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f010504d:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0105053:	ba 00 00 00 00       	mov    $0x0,%edx
f0105058:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f010505e:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0105064:	29 d0                	sub    %edx,%eax
f0105066:	89 c2                	mov    %eax,%edx
f0105068:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010506b:	39 c2                	cmp    %eax,%edx
f010506d:	0f 87 7a ff ff ff    	ja     f0104fed <env_create+0x3c6>
	struct ProgramSegment* seg = NULL; //use inside PROGRAM_SEGMENT_FOREACH as current segment information
	int segment_counter = 0;
	uint32 remaining_ws_pages = (e->page_WS_max_size) - 1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
	uint32 lastTableNumber = 0xffffffff;

	PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start) {
f0105073:	83 ec 08             	sub    $0x8,%esp
f0105076:	ff 75 bc             	pushl  -0x44(%ebp)
f0105079:	ff 75 e4             	pushl  -0x1c(%ebp)
f010507c:	e8 59 07 00 00       	call   f01057da <PROGRAM_SEGMENT_NEXT>
f0105081:	83 c4 10             	add    $0x10,%esp
f0105084:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0105087:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010508b:	0f 85 e7 fc ff ff    	jne    f0104d78 <env_create+0x151>
		}
		//LOG_STRING(" -------------------- PAGE FILE: segment remaining area is written (the zeros) ");
	}

	/// set the modified bit of each page in the ptr_pageWorkingSet to 0
	int i = 0;
f0105091:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
	for (; i < (e->page_WS_max_size); i++) {
f0105098:	e9 9e 00 00 00       	jmp    f010513b <env_create+0x514>
		if (e->ptr_pageWorkingSet[i].empty == 0) {
f010509d:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01050a3:	8b 48 78             	mov    0x78(%eax),%ecx
f01050a6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01050a9:	89 d0                	mov    %edx,%eax
f01050ab:	01 c0                	add    %eax,%eax
f01050ad:	01 d0                	add    %edx,%eax
f01050af:	c1 e0 02             	shl    $0x2,%eax
f01050b2:	01 c8                	add    %ecx,%eax
f01050b4:	8a 40 04             	mov    0x4(%eax),%al
f01050b7:	84 c0                	test   %al,%al
f01050b9:	75 7d                	jne    f0105138 <env_create+0x511>
			uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f01050bb:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01050c1:	8b 48 78             	mov    0x78(%eax),%ecx
f01050c4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01050c7:	89 d0                	mov    %edx,%eax
f01050c9:	01 c0                	add    %eax,%eax
f01050cb:	01 d0                	add    %edx,%eax
f01050cd:	c1 e0 02             	shl    $0x2,%eax
f01050d0:	01 c8                	add    %ecx,%eax
f01050d2:	8b 00                	mov    (%eax),%eax
f01050d4:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, (void *) virtual_address,
f01050da:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f01050e0:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01050e6:	8b 40 5c             	mov    0x5c(%eax),%eax
f01050e9:	83 ec 04             	sub    $0x4,%esp
f01050ec:	8d 8d 2c ff ff ff    	lea    -0xd4(%ebp),%ecx
f01050f2:	51                   	push   %ecx
f01050f3:	52                   	push   %edx
f01050f4:	50                   	push   %eax
f01050f5:	e8 16 dc ff ff       	call   f0102d10 <get_page_table>
f01050fa:	83 c4 10             	add    $0x10,%esp
					&ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f01050fd:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f0105103:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f0105109:	c1 ea 0c             	shr    $0xc,%edx
f010510c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105112:	c1 e2 02             	shl    $0x2,%edx
f0105115:	01 d0                	add    %edx,%eax
f0105117:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f010511d:	8b 8d 60 ff ff ff    	mov    -0xa0(%ebp),%ecx
f0105123:	c1 e9 0c             	shr    $0xc,%ecx
f0105126:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010512c:	c1 e1 02             	shl    $0x2,%ecx
f010512f:	01 ca                	add    %ecx,%edx
f0105131:	8b 12                	mov    (%edx),%edx
f0105133:	83 e2 bf             	and    $0xffffffbf,%edx
f0105136:	89 10                	mov    %edx,(%eax)
		//LOG_STRING(" -------------------- PAGE FILE: segment remaining area is written (the zeros) ");
	}

	/// set the modified bit of each page in the ptr_pageWorkingSet to 0
	int i = 0;
	for (; i < (e->page_WS_max_size); i++) {
f0105138:	ff 45 c4             	incl   -0x3c(%ebp)
f010513b:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0105141:	8b 50 74             	mov    0x74(%eax),%edx
f0105144:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0105147:	39 c2                	cmp    %eax,%edx
f0105149:	0f 87 4e ff ff ff    	ja     f010509d <env_create+0x476>
	//unsigned int * ptr = (unsigned int * )0x801084;
	//LOG_STATMENT(cprintf("contents at address %x=%x",0x801084, *ptr));

	//[8] now set the entry point of the environment
	//Hint: use set_environment_entry_point()
	set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010514f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0105152:	8b 50 08             	mov    0x8(%eax),%edx
f0105155:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f010515b:	83 ec 08             	sub    $0x8,%esp
f010515e:	52                   	push   %edx
f010515f:	50                   	push   %eax
f0105160:	e8 95 09 00 00       	call   f0105afa <set_environment_entry_point>
f0105165:	83 c4 10             	add    $0x10,%esp
	//[9] Allocate and map one page for the program's initial stack
	// at virtual address USTACKTOP - PAGE_SIZE.
	// we assume that the stack is counted in the environment working set

	// map the allocated page
	uint32 ptr_user_stack_bottom = (USTACKTOP - 1 * PAGE_SIZE);
f0105168:	c7 85 5c ff ff ff 00 	movl   $0xeebfd000,-0xa4(%ebp)
f010516f:	d0 bf ee 

	uint32 stackVa = USTACKTOP - PAGE_SIZE;
f0105172:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
	for (; stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f0105179:	e9 d4 00 00 00       	jmp    f0105252 <env_create+0x62b>
	{
		struct Frame_Info *pp = NULL;
f010517e:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
f0105185:	00 00 00 
		allocate_frame(&pp);
f0105188:	83 ec 0c             	sub    $0xc,%esp
f010518b:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
f0105191:	50                   	push   %eax
f0105192:	e8 01 da ff ff       	call   f0102b98 <allocate_frame>
f0105197:	83 c4 10             	add    $0x10,%esp

		loadtime_map_frame(e->env_page_directory, pp, (void*) stackVa,
f010519a:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f010519d:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f01051a3:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01051a9:	8b 40 5c             	mov    0x5c(%eax),%eax
f01051ac:	6a 06                	push   $0x6
f01051ae:	51                   	push   %ecx
f01051af:	52                   	push   %edx
f01051b0:	50                   	push   %eax
f01051b1:	e8 9b df ff ff       	call   f0103151 <loadtime_map_frame>
f01051b6:	83 c4 10             	add    $0x10,%esp
				PERM_USER | PERM_WRITEABLE);

		//initialize new page by 0's
		memset((void*) stackVa, 0, PAGE_SIZE);
f01051b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01051bc:	83 ec 04             	sub    $0x4,%esp
f01051bf:	68 00 10 00 00       	push   $0x1000
f01051c4:	6a 00                	push   $0x0
f01051c6:	50                   	push   %eax
f01051c7:	e8 d2 9a 00 00       	call   f010ec9e <memset>
f01051cc:	83 c4 10             	add    $0x10,%esp

		//now add it to the working set and the page table
		{
			env_page_ws_set_entry(e, e->page_last_WS_index, (uint32) stackVa);
f01051cf:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01051d5:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f01051db:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01051e1:	83 ec 04             	sub    $0x4,%esp
f01051e4:	ff 75 c0             	pushl  -0x40(%ebp)
f01051e7:	52                   	push   %edx
f01051e8:	50                   	push   %eax
f01051e9:	e8 b9 e4 ff ff       	call   f01036a7 <env_page_ws_set_entry>
f01051ee:	83 c4 10             	add    $0x10,%esp
			e->page_last_WS_index++;
f01051f1:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01051f7:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f01051fd:	42                   	inc    %edx
f01051fe:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)
			e->page_last_WS_index %= (e->page_WS_max_size);
f0105204:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
f010520a:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0105210:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f0105216:	8b 95 50 ff ff ff    	mov    -0xb0(%ebp),%edx
f010521c:	8b 5a 74             	mov    0x74(%edx),%ebx
f010521f:	ba 00 00 00 00       	mov    $0x0,%edx
f0105224:	f7 f3                	div    %ebx
f0105226:	89 d0                	mov    %edx,%eax
f0105228:	89 81 d4 02 00 00    	mov    %eax,0x2d4(%ecx)

			//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));

			int success = pf_add_empty_env_page(e, (uint32) stackVa, 1);
f010522e:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0105234:	83 ec 04             	sub    $0x4,%esp
f0105237:	6a 01                	push   $0x1
f0105239:	ff 75 c0             	pushl  -0x40(%ebp)
f010523c:	50                   	push   %eax
f010523d:	e8 ca 4e 00 00       	call   f010a10c <pf_add_empty_env_page>
f0105242:	83 c4 10             	add    $0x10,%esp
f0105245:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)

	// map the allocated page
	uint32 ptr_user_stack_bottom = (USTACKTOP - 1 * PAGE_SIZE);

	uint32 stackVa = USTACKTOP - PAGE_SIZE;
	for (; stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010524b:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f0105252:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0105255:	3b 85 5c ff ff ff    	cmp    -0xa4(%ebp),%eax
f010525b:	0f 83 1d ff ff ff    	jae    f010517e <env_create+0x557>
f0105261:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0105264:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0105267:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010526a:	0f 22 d8             	mov    %eax,%cr3
	lcr3(kern_phys_pgdir);

	//[11] 2012, add the new env we have just created to the scheduler NEW queue
	//	   2015: moved to the scheduler! since env_create() is responsible for creating the env only

	return e;
f010526d:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
}
f0105273:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0105276:	5b                   	pop    %ebx
f0105277:	5e                   	pop    %esi
f0105278:	5f                   	pop    %edi
f0105279:	5d                   	pop    %ebp
f010527a:	c3                   	ret    

f010527b <env_run>:

// Used to run the given environment "e", simply by
// context switch from curenv to env e.
//  (This function does not return.)
//
void env_run(struct Env *e) {
f010527b:	55                   	push   %ebp
f010527c:	89 e5                	mov    %esp,%ebp
f010527e:	83 ec 18             	sub    $0x18,%esp
	if (curenv != e) {
f0105281:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0105286:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105289:	74 25                	je     f01052b0 <env_run+0x35>
		curenv = e;
f010528b:	8b 45 08             	mov    0x8(%ebp),%eax
f010528e:	a3 38 a1 42 f0       	mov    %eax,0xf042a138
		curenv->env_runs++;
f0105293:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0105298:	8b 50 58             	mov    0x58(%eax),%edx
f010529b:	42                   	inc    %edx
f010529c:	89 50 58             	mov    %edx,0x58(%eax)
		lcr3(curenv->env_cr3);
f010529f:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01052a4:	8b 40 60             	mov    0x60(%eax),%eax
f01052a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01052aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052ad:	0f 22 d8             	mov    %eax,%cr3
	}
	//uint16 cnt0 = kclock_read_cnt0_latch();
	//cprintf("env_run: Counter0 Before Restart Again = %x\n", cnt0);
	//kclock_start();

	kclock_resume();
f01052b0:	e8 60 0a 00 00       	call   f0105d15 <kclock_resume>
	env_pop_tf(&(curenv->env_tf));
f01052b5:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01052ba:	83 ec 0c             	sub    $0xc,%esp
f01052bd:	50                   	push   %eax
f01052be:	e8 5d 09 00 00       	call   f0105c20 <env_pop_tf>

f01052c3 <__remove_pws_user_pages>:
}

void __remove_pws_user_pages(struct Env *e) {
f01052c3:	55                   	push   %ebp
f01052c4:	89 e5                	mov    %esp,%ebp
f01052c6:	83 ec 28             	sub    $0x28,%esp
	if (USE_KHEAP) {
		uint32 nBytes = sizeof(struct WorkingSetElement) * e->page_WS_max_size;
f01052c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01052cc:	8b 50 74             	mov    0x74(%eax),%edx
f01052cf:	89 d0                	mov    %edx,%eax
f01052d1:	01 c0                	add    %eax,%eax
f01052d3:	01 d0                	add    %edx,%eax
f01052d5:	c1 e0 02             	shl    $0x2,%eax
f01052d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		unsigned int sva = (unsigned int) e->__uptr_pws;
f01052db:	8b 45 08             	mov    0x8(%ebp),%eax
f01052de:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
f01052e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		for (; sva < ((unsigned int) (e->__uptr_pws) + nBytes);
f01052e7:	eb 1d                	jmp    f0105306 <__remove_pws_user_pages+0x43>
				sva += PAGE_SIZE)
				{
			//unsigned int pa = kheap_physical_address(sva);
			unmap_frame(e->env_page_directory, (void*) sva);
f01052e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01052ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01052ef:	8b 40 5c             	mov    0x5c(%eax),%eax
f01052f2:	83 ec 08             	sub    $0x8,%esp
f01052f5:	52                   	push   %edx
f01052f6:	50                   	push   %eax
f01052f7:	e8 ce dd ff ff       	call   f01030ca <unmap_frame>
f01052fc:	83 c4 10             	add    $0x10,%esp
void __remove_pws_user_pages(struct Env *e) {
	if (USE_KHEAP) {
		uint32 nBytes = sizeof(struct WorkingSetElement) * e->page_WS_max_size;
		unsigned int sva = (unsigned int) e->__uptr_pws;
		for (; sva < ((unsigned int) (e->__uptr_pws) + nBytes);
				sva += PAGE_SIZE)
f01052ff:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)

void __remove_pws_user_pages(struct Env *e) {
	if (USE_KHEAP) {
		uint32 nBytes = sizeof(struct WorkingSetElement) * e->page_WS_max_size;
		unsigned int sva = (unsigned int) e->__uptr_pws;
		for (; sva < ((unsigned int) (e->__uptr_pws) + nBytes);
f0105306:	8b 45 08             	mov    0x8(%ebp),%eax
f0105309:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
f010530f:	89 c2                	mov    %eax,%edx
f0105311:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105314:	01 d0                	add    %edx,%eax
f0105316:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0105319:	77 ce                	ja     f01052e9 <__remove_pws_user_pages+0x26>
				{
			//unsigned int pa = kheap_physical_address(sva);
			unmap_frame(e->env_page_directory, (void*) sva);
		}
		//cprintf("after free pages\n");
		unsigned int tsva = (unsigned int) e->__uptr_pws;
f010531b:	8b 45 08             	mov    0x8(%ebp),%eax
f010531e:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
f0105324:	89 45 f0             	mov    %eax,-0x10(%ebp)
		for (; tsva < ((unsigned int) (e->__uptr_pws) + nBytes); tsva += PTSIZE)
f0105327:	eb 47                	jmp    f0105370 <__remove_pws_user_pages+0xad>
		{
			unsigned int * uws_table;
			get_page_table(e->env_page_directory, (void*) tsva, &uws_table);
f0105329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010532c:	8b 45 08             	mov    0x8(%ebp),%eax
f010532f:	8b 40 5c             	mov    0x5c(%eax),%eax
f0105332:	83 ec 04             	sub    $0x4,%esp
f0105335:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
f0105338:	51                   	push   %ecx
f0105339:	52                   	push   %edx
f010533a:	50                   	push   %eax
f010533b:	e8 d0 d9 ff ff       	call   f0102d10 <get_page_table>
f0105340:	83 c4 10             	add    $0x10,%esp
			kfree(uws_table);
f0105343:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105346:	83 ec 0c             	sub    $0xc,%esp
f0105349:	50                   	push   %eax
f010534a:	e8 4f 5d 00 00       	call   f010b09e <kfree>
f010534f:	83 c4 10             	add    $0x10,%esp
			e->env_page_directory[PDX(tsva)] = 0;
f0105352:	8b 45 08             	mov    0x8(%ebp),%eax
f0105355:	8b 40 5c             	mov    0x5c(%eax),%eax
f0105358:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010535b:	c1 ea 16             	shr    $0x16,%edx
f010535e:	c1 e2 02             	shl    $0x2,%edx
f0105361:	01 d0                	add    %edx,%eax
f0105363:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			//unsigned int pa = kheap_physical_address(sva);
			unmap_frame(e->env_page_directory, (void*) sva);
		}
		//cprintf("after free pages\n");
		unsigned int tsva = (unsigned int) e->__uptr_pws;
		for (; tsva < ((unsigned int) (e->__uptr_pws) + nBytes); tsva += PTSIZE)
f0105369:	81 45 f0 00 00 40 00 	addl   $0x400000,-0x10(%ebp)
f0105370:	8b 45 08             	mov    0x8(%ebp),%eax
f0105373:	8b 80 f4 02 00 00    	mov    0x2f4(%eax),%eax
f0105379:	89 c2                	mov    %eax,%edx
f010537b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010537e:	01 d0                	add    %edx,%eax
f0105380:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105383:	77 a4                	ja     f0105329 <__remove_pws_user_pages+0x66>

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0105385:	0f 20 d8             	mov    %cr3,%eax
f0105388:	89 45 e8             	mov    %eax,-0x18(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010538b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010538e:	0f 22 d8             	mov    %eax,%cr3
			kfree(uws_table);
			e->env_page_directory[PDX(tsva)] = 0;
		}
		tlbflush();
	}
}
f0105391:	90                   	nop
f0105392:	c9                   	leave  
f0105393:	c3                   	ret    

f0105394 <start_env_free>:
//
extern uint32 isBufferingEnabled();
void __env_free_with_buffering(struct Env *e);
void env_free(struct Env *e);

void start_env_free(struct Env *e) {
f0105394:	55                   	push   %ebp
f0105395:	89 e5                	mov    %esp,%ebp
f0105397:	83 ec 08             	sub    $0x8,%esp
	if (isBufferingEnabled()) {
f010539a:	e8 6c 22 00 00       	call   f010760b <isBufferingEnabled>
f010539f:	85 c0                	test   %eax,%eax
f01053a1:	74 10                	je     f01053b3 <start_env_free+0x1f>
		__env_free_with_buffering(e);
f01053a3:	83 ec 0c             	sub    $0xc,%esp
f01053a6:	ff 75 08             	pushl  0x8(%ebp)
f01053a9:	e8 24 01 00 00       	call   f01054d2 <__env_free_with_buffering>
f01053ae:	83 c4 10             	add    $0x10,%esp
	} else {
		env_free(e);
	}
}
f01053b1:	eb 0e                	jmp    f01053c1 <start_env_free+0x2d>

void start_env_free(struct Env *e) {
	if (isBufferingEnabled()) {
		__env_free_with_buffering(e);
	} else {
		env_free(e);
f01053b3:	83 ec 0c             	sub    $0xc,%esp
f01053b6:	ff 75 08             	pushl  0x8(%ebp)
f01053b9:	e8 06 00 00 00       	call   f01053c4 <env_free>
f01053be:	83 c4 10             	add    $0x10,%esp
	}
}
f01053c1:	90                   	nop
f01053c2:	c9                   	leave  
f01053c3:	c3                   	ret    

f01053c4 <env_free>:

void env_free(struct Env *e) {
f01053c4:	55                   	push   %ebp
f01053c5:	89 e5                	mov    %esp,%ebp
f01053c7:	83 ec 28             	sub    $0x28,%esp
	__remove_pws_user_pages(e);
f01053ca:	83 ec 0c             	sub    $0xc,%esp
f01053cd:	ff 75 08             	pushl  0x8(%ebp)
f01053d0:	e8 ee fe ff ff       	call   f01052c3 <__remove_pws_user_pages>
f01053d5:	83 c4 10             	add    $0x10,%esp

	//YOUR CODE STARTS HERE, remove the panic and write your code ----
	//panic("env_free() is not implemented yet...!!");

	// [1] Free the pages in the PAGE working set from the main memory
	int i = 0;
f01053d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (; i < e->page_WS_max_size; i++) {
f01053df:	eb 40                	jmp    f0105421 <env_free+0x5d>
		unmap_frame(e->env_page_directory,
				(void*) e->ptr_pageWorkingSet[i].virtual_address);
f01053e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01053e4:	8b 48 78             	mov    0x78(%eax),%ecx
f01053e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ea:	89 d0                	mov    %edx,%eax
f01053ec:	01 c0                	add    %eax,%eax
f01053ee:	01 d0                	add    %edx,%eax
f01053f0:	c1 e0 02             	shl    $0x2,%eax
f01053f3:	01 c8                	add    %ecx,%eax
f01053f5:	8b 00                	mov    (%eax),%eax
	//panic("env_free() is not implemented yet...!!");

	// [1] Free the pages in the PAGE working set from the main memory
	int i = 0;
	for (; i < e->page_WS_max_size; i++) {
		unmap_frame(e->env_page_directory,
f01053f7:	89 c2                	mov    %eax,%edx
f01053f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fc:	8b 40 5c             	mov    0x5c(%eax),%eax
f01053ff:	83 ec 08             	sub    $0x8,%esp
f0105402:	52                   	push   %edx
f0105403:	50                   	push   %eax
f0105404:	e8 c1 dc ff ff       	call   f01030ca <unmap_frame>
f0105409:	83 c4 10             	add    $0x10,%esp
				(void*) e->ptr_pageWorkingSet[i].virtual_address);

		env_page_ws_clear_entry(e, i);
f010540c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010540f:	83 ec 08             	sub    $0x8,%esp
f0105412:	50                   	push   %eax
f0105413:	ff 75 08             	pushl  0x8(%ebp)
f0105416:	e8 33 e3 ff ff       	call   f010374e <env_page_ws_clear_entry>
f010541b:	83 c4 10             	add    $0x10,%esp
	//YOUR CODE STARTS HERE, remove the panic and write your code ----
	//panic("env_free() is not implemented yet...!!");

	// [1] Free the pages in the PAGE working set from the main memory
	int i = 0;
	for (; i < e->page_WS_max_size; i++) {
f010541e:	ff 45 f4             	incl   -0xc(%ebp)
f0105421:	8b 45 08             	mov    0x8(%ebp),%eax
f0105424:	8b 50 74             	mov    0x74(%eax),%edx
f0105427:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010542a:	39 c2                	cmp    %eax,%edx
f010542c:	77 b3                	ja     f01053e1 <env_free+0x1d>
		env_page_ws_clear_entry(e, i);

	}

	// [2] Free the PAGE working set array itself from the main memory
	kfree((void*) e->ptr_pageWorkingSet);
f010542e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105431:	8b 40 78             	mov    0x78(%eax),%eax
f0105434:	83 ec 0c             	sub    $0xc,%esp
f0105437:	50                   	push   %eax
f0105438:	e8 61 5c 00 00       	call   f010b09e <kfree>
f010543d:	83 c4 10             	add    $0x10,%esp

	// [3] Free all TABLES from the main memory

	i = 0;
f0105440:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int max_user = PDX(USER_TOP);
f0105447:	c7 45 f0 bb 03 00 00 	movl   $0x3bb,-0x10(%ebp)
	for (; i < max_user; i++) {
f010544e:	eb 3d                	jmp    f010548d <env_free+0xc9>

		uint32 phys = (e->env_page_directory[i] >> 12);
f0105450:	8b 45 08             	mov    0x8(%ebp),%eax
f0105453:	8b 40 5c             	mov    0x5c(%eax),%eax
f0105456:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105459:	c1 e2 02             	shl    $0x2,%edx
f010545c:	01 d0                	add    %edx,%eax
f010545e:	8b 00                	mov    (%eax),%eax
f0105460:	c1 e8 0c             	shr    $0xc,%eax
f0105463:	89 45 ec             	mov    %eax,-0x14(%ebp)
		phys *= PAGE_SIZE;
f0105466:	c1 65 ec 0c          	shll   $0xc,-0x14(%ebp)

		uint32 vir = kheap_virtual_address(phys);
f010546a:	83 ec 0c             	sub    $0xc,%esp
f010546d:	ff 75 ec             	pushl  -0x14(%ebp)
f0105470:	e8 2e 5d 00 00       	call   f010b1a3 <kheap_virtual_address>
f0105475:	83 c4 10             	add    $0x10,%esp
f0105478:	89 45 e8             	mov    %eax,-0x18(%ebp)

		kfree((void*) vir);
f010547b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010547e:	83 ec 0c             	sub    $0xc,%esp
f0105481:	50                   	push   %eax
f0105482:	e8 17 5c 00 00       	call   f010b09e <kfree>
f0105487:	83 c4 10             	add    $0x10,%esp

	// [3] Free all TABLES from the main memory

	i = 0;
	int max_user = PDX(USER_TOP);
	for (; i < max_user; i++) {
f010548a:	ff 45 f4             	incl   -0xc(%ebp)
f010548d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105490:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105493:	7c bb                	jl     f0105450 <env_free+0x8c>

	}

	// [4] Free the page DIRECTORY from the main memory

	kfree((void*) e->env_page_directory);
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	8b 40 5c             	mov    0x5c(%eax),%eax
f010549b:	83 ec 0c             	sub    $0xc,%esp
f010549e:	50                   	push   %eax
f010549f:	e8 fa 5b 00 00       	call   f010b09e <kfree>
f01054a4:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01054a7:	0f 20 d8             	mov    %cr3,%eax
f01054aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01054ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01054b0:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();

	//YOUR CODE ENDS HERE --------------------------------------------

	//Don't change these lines:
	pf_free_env(e); /*(ALREADY DONE for you)*/ // (removes all of the program pages from the page file)
f01054b3:	83 ec 0c             	sub    $0xc,%esp
f01054b6:	ff 75 08             	pushl  0x8(%ebp)
f01054b9:	e8 06 50 00 00       	call   f010a4c4 <pf_free_env>
f01054be:	83 c4 10             	add    $0x10,%esp
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
f01054c1:	83 ec 0c             	sub    $0xc,%esp
f01054c4:	ff 75 08             	pushl  0x8(%ebp)
f01054c7:	e8 90 f1 ff ff       	call   f010465c <free_environment>
f01054cc:	83 c4 10             	add    $0x10,%esp
}
f01054cf:	90                   	nop
f01054d0:	c9                   	leave  
f01054d1:	c3                   	ret    

f01054d2 <__env_free_with_buffering>:

void __env_free_with_buffering(struct Env *e) {
f01054d2:	55                   	push   %ebp
f01054d3:	89 e5                	mov    %esp,%ebp

}
f01054d5:	90                   	nop
f01054d6:	5d                   	pop    %ebp
f01054d7:	c3                   	ret    

f01054d8 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//

void env_init(void) {
f01054d8:	55                   	push   %ebp
f01054d9:	89 e5                	mov    %esp,%ebp
f01054db:	53                   	push   %ebx
f01054dc:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV - 1;
f01054df:	c7 45 f8 62 05 00 00 	movl   $0x562,-0x8(%ebp)
	for (; iEnv >= 0; iEnv--) {
f01054e6:	e9 36 01 00 00       	jmp    f0105621 <env_init+0x149>
		envs[iEnv].env_status = ENV_FREE;
f01054eb:	8b 0d 34 a1 42 f0    	mov    0xf042a134,%ecx
f01054f1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01054f4:	89 d0                	mov    %edx,%eax
f01054f6:	c1 e0 03             	shl    $0x3,%eax
f01054f9:	01 d0                	add    %edx,%eax
f01054fb:	01 c0                	add    %eax,%eax
f01054fd:	01 d0                	add    %edx,%eax
f01054ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105506:	01 d0                	add    %edx,%eax
f0105508:	c1 e0 03             	shl    $0x3,%eax
f010550b:	01 c8                	add    %ecx,%eax
f010550d:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
		envs[iEnv].env_id = 0;
f0105514:	8b 0d 34 a1 42 f0    	mov    0xf042a134,%ecx
f010551a:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010551d:	89 d0                	mov    %edx,%eax
f010551f:	c1 e0 03             	shl    $0x3,%eax
f0105522:	01 d0                	add    %edx,%eax
f0105524:	01 c0                	add    %eax,%eax
f0105526:	01 d0                	add    %edx,%eax
f0105528:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010552f:	01 d0                	add    %edx,%eax
f0105531:	c1 e0 03             	shl    $0x3,%eax
f0105534:	01 c8                	add    %ecx,%eax
f0105536:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010553d:	8b 0d 34 a1 42 f0    	mov    0xf042a134,%ecx
f0105543:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0105546:	89 d0                	mov    %edx,%eax
f0105548:	c1 e0 03             	shl    $0x3,%eax
f010554b:	01 d0                	add    %edx,%eax
f010554d:	01 c0                	add    %eax,%eax
f010554f:	01 d0                	add    %edx,%eax
f0105551:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105558:	01 d0                	add    %edx,%eax
f010555a:	c1 e0 03             	shl    $0x3,%eax
f010555d:	01 c8                	add    %ecx,%eax
f010555f:	8b 15 3c a1 42 f0    	mov    0xf042a13c,%edx
f0105565:	89 50 44             	mov    %edx,0x44(%eax)
f0105568:	8b 40 44             	mov    0x44(%eax),%eax
f010556b:	85 c0                	test   %eax,%eax
f010556d:	74 2d                	je     f010559c <env_init+0xc4>
f010556f:	8b 0d 3c a1 42 f0    	mov    0xf042a13c,%ecx
f0105575:	8b 1d 34 a1 42 f0    	mov    0xf042a134,%ebx
f010557b:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010557e:	89 d0                	mov    %edx,%eax
f0105580:	c1 e0 03             	shl    $0x3,%eax
f0105583:	01 d0                	add    %edx,%eax
f0105585:	01 c0                	add    %eax,%eax
f0105587:	01 d0                	add    %edx,%eax
f0105589:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105590:	01 d0                	add    %edx,%eax
f0105592:	c1 e0 03             	shl    $0x3,%eax
f0105595:	01 d8                	add    %ebx,%eax
f0105597:	89 41 48             	mov    %eax,0x48(%ecx)
f010559a:	eb 27                	jmp    f01055c3 <env_init+0xeb>
f010559c:	8b 0d 34 a1 42 f0    	mov    0xf042a134,%ecx
f01055a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01055a5:	89 d0                	mov    %edx,%eax
f01055a7:	c1 e0 03             	shl    $0x3,%eax
f01055aa:	01 d0                	add    %edx,%eax
f01055ac:	01 c0                	add    %eax,%eax
f01055ae:	01 d0                	add    %edx,%eax
f01055b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01055b7:	01 d0                	add    %edx,%eax
f01055b9:	c1 e0 03             	shl    $0x3,%eax
f01055bc:	01 c8                	add    %ecx,%eax
f01055be:	a3 40 a1 42 f0       	mov    %eax,0xf042a140
f01055c3:	8b 0d 34 a1 42 f0    	mov    0xf042a134,%ecx
f01055c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01055cc:	89 d0                	mov    %edx,%eax
f01055ce:	c1 e0 03             	shl    $0x3,%eax
f01055d1:	01 d0                	add    %edx,%eax
f01055d3:	01 c0                	add    %eax,%eax
f01055d5:	01 d0                	add    %edx,%eax
f01055d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01055de:	01 d0                	add    %edx,%eax
f01055e0:	c1 e0 03             	shl    $0x3,%eax
f01055e3:	01 c8                	add    %ecx,%eax
f01055e5:	a3 3c a1 42 f0       	mov    %eax,0xf042a13c
f01055ea:	8b 0d 34 a1 42 f0    	mov    0xf042a134,%ecx
f01055f0:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01055f3:	89 d0                	mov    %edx,%eax
f01055f5:	c1 e0 03             	shl    $0x3,%eax
f01055f8:	01 d0                	add    %edx,%eax
f01055fa:	01 c0                	add    %eax,%eax
f01055fc:	01 d0                	add    %edx,%eax
f01055fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105605:	01 d0                	add    %edx,%eax
f0105607:	c1 e0 03             	shl    $0x3,%eax
f010560a:	01 c8                	add    %ecx,%eax
f010560c:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f0105613:	a1 48 a1 42 f0       	mov    0xf042a148,%eax
f0105618:	40                   	inc    %eax
f0105619:	a3 48 a1 42 f0       	mov    %eax,0xf042a148
// returns envs[0].
//

void env_init(void) {
	int iEnv = NENV - 1;
	for (; iEnv >= 0; iEnv--) {
f010561e:	ff 4d f8             	decl   -0x8(%ebp)
f0105621:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f0105625:	0f 89 c0 fe ff ff    	jns    f01054eb <env_init+0x13>
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010562b:	90                   	nop
f010562c:	83 c4 10             	add    $0x10,%esp
f010562f:	5b                   	pop    %ebx
f0105630:	5d                   	pop    %ebp
f0105631:	c3                   	ret    

f0105632 <complete_environment_initialization>:

void complete_environment_initialization(struct Env* e) {
f0105632:	55                   	push   %ebp
f0105633:	89 e5                	mov    %esp,%ebp
f0105635:	83 ec 18             	sub    $0x18,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)] =
f0105638:	8b 45 08             	mov    0x8(%ebp),%eax
f010563b:	8b 40 5c             	mov    0x5c(%eax),%eax
f010563e:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
			e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f0105644:	8b 45 08             	mov    0x8(%ebp),%eax
f0105647:	8b 40 60             	mov    0x60(%eax),%eax
f010564a:	83 c8 03             	or     $0x3,%eax
}

void complete_environment_initialization(struct Env* e) {
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)] =
f010564d:	89 02                	mov    %eax,(%edx)
			e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010564f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105652:	8b 40 5c             	mov    0x5c(%eax),%eax
f0105655:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010565b:	8b 45 08             	mov    0x8(%ebp),%eax
f010565e:	8b 40 60             	mov    0x60(%eax),%eax
f0105661:	83 c8 05             	or     $0x5,%eax
f0105664:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir = 0;
f0105666:	8b 45 08             	mov    0x8(%ebp),%eax
f0105669:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	e->disk_env_pgdir_PA = 0;
f0105670:	8b 45 08             	mov    0x8(%ebp),%eax
f0105673:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
	e->disk_env_tabledir = 0;
f010567a:	8b 45 08             	mov    0x8(%ebp),%eax
f010567d:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
	e->disk_env_tabledir_PA = 0;
f0105684:	8b 45 08             	mov    0x8(%ebp),%eax
f0105687:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)

	int32 generation;
	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
f010568e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105691:	8b 40 4c             	mov    0x4c(%eax),%eax
f0105694:	05 00 10 00 00       	add    $0x1000,%eax
f0105699:	25 9d fa ff ff       	and    $0xfffffa9d,%eax
f010569e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f01056a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01056a5:	7f 07                	jg     f01056ae <complete_environment_initialization+0x7c>
		generation = 1 << ENVGENSHIFT;
f01056a7:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 15 34 a1 42 f0    	mov    0xf042a134,%edx
f01056b7:	29 d0                	sub    %edx,%eax
f01056b9:	c1 f8 03             	sar    $0x3,%eax
f01056bc:	89 c2                	mov    %eax,%edx
f01056be:	89 d0                	mov    %edx,%eax
f01056c0:	c1 e0 03             	shl    $0x3,%eax
f01056c3:	01 d0                	add    %edx,%eax
f01056c5:	01 c0                	add    %eax,%eax
f01056c7:	01 d0                	add    %edx,%eax
f01056c9:	c1 e0 03             	shl    $0x3,%eax
f01056cc:	01 d0                	add    %edx,%eax
f01056ce:	89 c1                	mov    %eax,%ecx
f01056d0:	c1 e1 08             	shl    $0x8,%ecx
f01056d3:	01 c8                	add    %ecx,%eax
f01056d5:	01 c0                	add    %eax,%eax
f01056d7:	01 d0                	add    %edx,%eax
f01056d9:	01 c0                	add    %eax,%eax
f01056db:	01 d0                	add    %edx,%eax
f01056dd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01056e4:	01 d0                	add    %edx,%eax
f01056e6:	89 c2                	mov    %eax,%edx
f01056e8:	c1 e2 09             	shl    $0x9,%edx
f01056eb:	29 c2                	sub    %eax,%edx
f01056ed:	89 d0                	mov    %edx,%eax
f01056ef:	f7 d8                	neg    %eax
f01056f1:	0b 45 f4             	or     -0xc(%ebp),%eax
f01056f4:	89 c2                	mov    %eax,%edx
f01056f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f9:	89 50 4c             	mov    %edx,0x4c(%eax)

	// Set the basic status variables.
	e->env_parent_id = 0;	//parent_id;
f01056fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01056ff:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
	e->env_status = ENV_NEW;
f0105706:	8b 45 08             	mov    0x8(%ebp),%eax
f0105709:	c7 40 54 03 00 00 00 	movl   $0x3,0x54(%eax)
	e->env_runs = 0;
f0105710:	8b 45 08             	mov    0x8(%ebp),%eax
f0105713:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
f010571a:	8b 45 08             	mov    0x8(%ebp),%eax
f010571d:	83 ec 04             	sub    $0x4,%esp
f0105720:	6a 44                	push   $0x44
f0105722:	6a 00                	push   $0x0
f0105724:	50                   	push   %eax
f0105725:	e8 74 95 00 00       	call   f010ec9e <memset>
f010572a:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf.tf_ds = GD_UD | 3;
f010572d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105730:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf.tf_es = GD_UD | 3;
f0105736:	8b 45 08             	mov    0x8(%ebp),%eax
f0105739:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf.tf_ss = GD_UD | 3;
f010573f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105742:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf.tf_esp = (uint32*) USTACKTOP;
f0105748:	8b 45 08             	mov    0x8(%ebp),%eax
f010574b:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf.tf_cs = GD_UT | 3;
f0105752:	8b 45 08             	mov    0x8(%ebp),%eax
f0105755:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf.tf_eflags |= FL_IF;
f010575b:	8b 45 08             	mov    0x8(%ebp),%eax
f010575e:	8b 40 38             	mov    0x38(%eax),%eax
f0105761:	80 cc 02             	or     $0x2,%ah
f0105764:	89 c2                	mov    %eax,%edx
f0105766:	8b 45 08             	mov    0x8(%ebp),%eax
f0105769:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list, e);
f010576c:	8b 45 08             	mov    0x8(%ebp),%eax
f010576f:	8b 40 44             	mov    0x44(%eax),%eax
f0105772:	85 c0                	test   %eax,%eax
f0105774:	74 11                	je     f0105787 <complete_environment_initialization+0x155>
f0105776:	8b 45 08             	mov    0x8(%ebp),%eax
f0105779:	8b 40 44             	mov    0x44(%eax),%eax
f010577c:	8b 55 08             	mov    0x8(%ebp),%edx
f010577f:	8b 52 48             	mov    0x48(%edx),%edx
f0105782:	89 50 48             	mov    %edx,0x48(%eax)
f0105785:	eb 0b                	jmp    f0105792 <complete_environment_initialization+0x160>
f0105787:	8b 45 08             	mov    0x8(%ebp),%eax
f010578a:	8b 40 48             	mov    0x48(%eax),%eax
f010578d:	a3 40 a1 42 f0       	mov    %eax,0xf042a140
f0105792:	8b 45 08             	mov    0x8(%ebp),%eax
f0105795:	8b 40 48             	mov    0x48(%eax),%eax
f0105798:	85 c0                	test   %eax,%eax
f010579a:	74 11                	je     f01057ad <complete_environment_initialization+0x17b>
f010579c:	8b 45 08             	mov    0x8(%ebp),%eax
f010579f:	8b 40 48             	mov    0x48(%eax),%eax
f01057a2:	8b 55 08             	mov    0x8(%ebp),%edx
f01057a5:	8b 52 44             	mov    0x44(%edx),%edx
f01057a8:	89 50 44             	mov    %edx,0x44(%eax)
f01057ab:	eb 0b                	jmp    f01057b8 <complete_environment_initialization+0x186>
f01057ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b0:	8b 40 44             	mov    0x44(%eax),%eax
f01057b3:	a3 3c a1 42 f0       	mov    %eax,0xf042a13c
f01057b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01057bb:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f01057c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01057c5:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f01057cc:	a1 48 a1 42 f0       	mov    0xf042a148,%eax
f01057d1:	48                   	dec    %eax
f01057d2:	a3 48 a1 42 f0       	mov    %eax,0xf042a148
	return;
f01057d7:	90                   	nop
}
f01057d8:	c9                   	leave  
f01057d9:	c3                   	ret    

f01057da <PROGRAM_SEGMENT_NEXT>:

struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg,
		uint8* ptr_program_start) {
f01057da:	55                   	push   %ebp
f01057db:	89 e5                	mov    %esp,%ebp
f01057dd:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f01057e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01057e3:	8b 40 10             	mov    0x10(%eax),%eax
f01057e6:	8d 48 01             	lea    0x1(%eax),%ecx
f01057e9:	8b 55 08             	mov    0x8(%ebp),%edx
f01057ec:	89 4a 10             	mov    %ecx,0x10(%edx)
f01057ef:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *) ptr_program_start;
f01057f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01057f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f01057f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01057fb:	8b 00                	mov    (%eax),%eax
f01057fd:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f0105802:	74 17                	je     f010581b <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f0105804:	83 ec 04             	sub    $0x4,%esp
f0105807:	68 d1 15 11 f0       	push   $0xf01115d1
f010580c:	68 82 03 00 00       	push   $0x382
f0105811:	68 73 15 11 f0       	push   $0xf0111573
f0105816:	e8 41 a9 ff ff       	call   f010015c <_panic>
	ph = (struct Proghdr *) (((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010581b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010581e:	8b 50 1c             	mov    0x1c(%eax),%edx
f0105821:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105824:	01 d0                	add    %edx,%eax
f0105826:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD
f0105829:	eb 0f                	jmp    f010583a <PROGRAM_SEGMENT_NEXT+0x60>
			&& ((*seg).segment_id < pELFHDR->e_phnum))
		(*seg).segment_id++;
f010582b:	8b 45 08             	mov    0x8(%ebp),%eax
f010582e:	8b 40 10             	mov    0x10(%eax),%eax
f0105831:	8d 50 01             	lea    0x1(%eax),%edx
f0105834:	8b 45 08             	mov    0x8(%ebp),%eax
f0105837:	89 50 10             	mov    %edx,0x10(%eax)
	struct Elf * pELFHDR = (struct Elf *) ptr_program_start;
	if (pELFHDR->e_magic != ELF_MAGIC)
		panic("Matafa2nash 3ala Keda");
	ph = (struct Proghdr *) (((uint8 *) ptr_program_start) + pELFHDR->e_phoff);

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD
f010583a:	8b 45 08             	mov    0x8(%ebp),%eax
f010583d:	8b 40 10             	mov    0x10(%eax),%eax
f0105840:	c1 e0 05             	shl    $0x5,%eax
f0105843:	89 c2                	mov    %eax,%edx
f0105845:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105848:	01 d0                	add    %edx,%eax
f010584a:	8b 00                	mov    (%eax),%eax
f010584c:	83 f8 01             	cmp    $0x1,%eax
f010584f:	74 13                	je     f0105864 <PROGRAM_SEGMENT_NEXT+0x8a>
			&& ((*seg).segment_id < pELFHDR->e_phnum))
f0105851:	8b 45 08             	mov    0x8(%ebp),%eax
f0105854:	8b 50 10             	mov    0x10(%eax),%edx
f0105857:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010585a:	8b 40 2c             	mov    0x2c(%eax),%eax
f010585d:	0f b7 c0             	movzwl %ax,%eax
f0105860:	39 c2                	cmp    %eax,%edx
f0105862:	72 c7                	jb     f010582b <PROGRAM_SEGMENT_NEXT+0x51>
		(*seg).segment_id++;
	index = (*seg).segment_id;
f0105864:	8b 45 08             	mov    0x8(%ebp),%eax
f0105867:	8b 40 10             	mov    0x10(%eax),%eax
f010586a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (index < pELFHDR->e_phnum) {
f010586d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105870:	8b 40 2c             	mov    0x2c(%eax),%eax
f0105873:	0f b7 c0             	movzwl %ax,%eax
f0105876:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0105879:	7e 63                	jle    f01058de <PROGRAM_SEGMENT_NEXT+0x104>
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010587b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010587e:	c1 e0 05             	shl    $0x5,%eax
f0105881:	89 c2                	mov    %eax,%edx
f0105883:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105886:	01 d0                	add    %edx,%eax
f0105888:	8b 50 04             	mov    0x4(%eax),%edx
f010588b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010588e:	01 c2                	add    %eax,%edx
f0105890:	8b 45 08             	mov    0x8(%ebp),%eax
f0105893:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory = ph[index].p_memsz;
f0105895:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105898:	c1 e0 05             	shl    $0x5,%eax
f010589b:	89 c2                	mov    %eax,%edx
f010589d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01058a0:	01 d0                	add    %edx,%eax
f01058a2:	8b 50 14             	mov    0x14(%eax),%edx
f01058a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01058a8:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f01058ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058ae:	c1 e0 05             	shl    $0x5,%eax
f01058b1:	89 c2                	mov    %eax,%edx
f01058b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01058b6:	01 d0                	add    %edx,%eax
f01058b8:	8b 50 10             	mov    0x10(%eax),%edx
f01058bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01058be:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*) ph[index].p_va;
f01058c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058c4:	c1 e0 05             	shl    $0x5,%eax
f01058c7:	89 c2                	mov    %eax,%edx
f01058c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01058cc:	01 d0                	add    %edx,%eax
f01058ce:	8b 40 08             	mov    0x8(%eax),%eax
f01058d1:	89 c2                	mov    %eax,%edx
f01058d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01058d6:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f01058d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01058dc:	eb 05                	jmp    f01058e3 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f01058de:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01058e3:	c9                   	leave  
f01058e4:	c3                   	ret    

f01058e5 <PROGRAM_SEGMENT_FIRST>:

struct ProgramSegment PROGRAM_SEGMENT_FIRST(uint8* ptr_program_start) {
f01058e5:	55                   	push   %ebp
f01058e6:	89 e5                	mov    %esp,%ebp
f01058e8:	57                   	push   %edi
f01058e9:	56                   	push   %esi
f01058ea:	53                   	push   %ebx
f01058eb:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f01058ee:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *) ptr_program_start;
f01058f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01058f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f01058fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01058fe:	8b 00                	mov    (%eax),%eax
f0105900:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f0105905:	74 17                	je     f010591e <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f0105907:	83 ec 04             	sub    $0x4,%esp
f010590a:	68 d1 15 11 f0       	push   $0xf01115d1
f010590f:	68 9b 03 00 00       	push   $0x39b
f0105914:	68 73 15 11 f0       	push   $0xf0111573
f0105919:	e8 3e a8 ff ff       	call   f010015c <_panic>
	ph = (struct Proghdr *) (((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010591e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105921:	8b 50 1c             	mov    0x1c(%eax),%edx
f0105924:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105927:	01 d0                	add    %edx,%eax
f0105929:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD
f010592c:	eb 07                	jmp    f0105935 <PROGRAM_SEGMENT_FIRST+0x50>
			&& ((seg).segment_id < pELFHDR->e_phnum))
		(seg).segment_id++;
f010592e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0105931:	40                   	inc    %eax
f0105932:	89 45 d8             	mov    %eax,-0x28(%ebp)
	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *) ptr_program_start;
	if (pELFHDR->e_magic != ELF_MAGIC)
		panic("Matafa2nash 3ala Keda");
	ph = (struct Proghdr *) (((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD
f0105935:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0105938:	c1 e0 05             	shl    $0x5,%eax
f010593b:	89 c2                	mov    %eax,%edx
f010593d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105940:	01 d0                	add    %edx,%eax
f0105942:	8b 00                	mov    (%eax),%eax
f0105944:	83 f8 01             	cmp    $0x1,%eax
f0105947:	74 10                	je     f0105959 <PROGRAM_SEGMENT_FIRST+0x74>
			&& ((seg).segment_id < pELFHDR->e_phnum))
f0105949:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010594c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010594f:	8b 40 2c             	mov    0x2c(%eax),%eax
f0105952:	0f b7 c0             	movzwl %ax,%eax
f0105955:	39 c2                	cmp    %eax,%edx
f0105957:	72 d5                	jb     f010592e <PROGRAM_SEGMENT_FIRST+0x49>
		(seg).segment_id++;
	int index = (seg).segment_id;
f0105959:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010595c:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if (index < pELFHDR->e_phnum) {
f010595f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105962:	8b 40 2c             	mov    0x2c(%eax),%eax
f0105965:	0f b7 c0             	movzwl %ax,%eax
f0105968:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010596b:	7e 68                	jle    f01059d5 <PROGRAM_SEGMENT_FIRST+0xf0>
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010596d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105970:	c1 e0 05             	shl    $0x5,%eax
f0105973:	89 c2                	mov    %eax,%edx
f0105975:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105978:	01 d0                	add    %edx,%eax
f010597a:	8b 50 04             	mov    0x4(%eax),%edx
f010597d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105980:	01 d0                	add    %edx,%eax
f0105982:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory = ph[index].p_memsz;
f0105985:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0105988:	c1 e0 05             	shl    $0x5,%eax
f010598b:	89 c2                	mov    %eax,%edx
f010598d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105990:	01 d0                	add    %edx,%eax
f0105992:	8b 40 14             	mov    0x14(%eax),%eax
f0105995:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f0105998:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010599b:	c1 e0 05             	shl    $0x5,%eax
f010599e:	89 c2                	mov    %eax,%edx
f01059a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01059a3:	01 d0                	add    %edx,%eax
f01059a5:	8b 40 10             	mov    0x10(%eax),%eax
f01059a8:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*) ph[index].p_va;
f01059ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01059ae:	c1 e0 05             	shl    $0x5,%eax
f01059b1:	89 c2                	mov    %eax,%edx
f01059b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01059b6:	01 d0                	add    %edx,%eax
f01059b8:	8b 40 08             	mov    0x8(%eax),%eax
f01059bb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f01059be:	8b 45 08             	mov    0x8(%ebp),%eax
f01059c1:	89 c3                	mov    %eax,%ebx
f01059c3:	8d 45 c8             	lea    -0x38(%ebp),%eax
f01059c6:	ba 05 00 00 00       	mov    $0x5,%edx
f01059cb:	89 df                	mov    %ebx,%edi
f01059cd:	89 c6                	mov    %eax,%esi
f01059cf:	89 d1                	mov    %edx,%ecx
f01059d1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01059d3:	eb 1c                	jmp    f01059f1 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f01059d5:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f01059dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01059df:	89 c3                	mov    %eax,%ebx
f01059e1:	8d 45 c8             	lea    -0x38(%ebp),%eax
f01059e4:	ba 05 00 00 00       	mov    $0x5,%edx
f01059e9:	89 df                	mov    %ebx,%edi
f01059eb:	89 c6                	mov    %eax,%esi
f01059ed:	89 d1                	mov    %edx,%ecx
f01059ef:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f01059f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01059f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01059f7:	5b                   	pop    %ebx
f01059f8:	5e                   	pop    %esi
f01059f9:	5f                   	pop    %edi
f01059fa:	5d                   	pop    %ebp
f01059fb:	c2 04 00             	ret    $0x4

f01059fe <get_user_program_info>:

struct UserProgramInfo* get_user_program_info(char* user_program_name) {
f01059fe:	55                   	push   %ebp
f01059ff:	89 e5                	mov    %esp,%ebp
f0105a01:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f0105a04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105a0b:	eb 29                	jmp    f0105a36 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f0105a0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105a10:	89 d0                	mov    %edx,%eax
f0105a12:	01 c0                	add    %eax,%eax
f0105a14:	01 d0                	add    %edx,%eax
f0105a16:	c1 e0 02             	shl    $0x2,%eax
f0105a19:	05 40 a7 13 f0       	add    $0xf013a740,%eax
f0105a1e:	8b 00                	mov    (%eax),%eax
f0105a20:	83 ec 08             	sub    $0x8,%esp
f0105a23:	50                   	push   %eax
f0105a24:	ff 75 08             	pushl  0x8(%ebp)
f0105a27:	e8 90 91 00 00       	call   f010ebbc <strcmp>
f0105a2c:	83 c4 10             	add    $0x10,%esp
f0105a2f:	85 c0                	test   %eax,%eax
f0105a31:	74 0f                	je     f0105a42 <get_user_program_info+0x44>
	return seg;
}

struct UserProgramInfo* get_user_program_info(char* user_program_name) {
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f0105a33:	ff 45 f4             	incl   -0xc(%ebp)
f0105a36:	a1 60 a9 13 f0       	mov    0xf013a960,%eax
f0105a3b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0105a3e:	7c cd                	jl     f0105a0d <get_user_program_info+0xf>
f0105a40:	eb 01                	jmp    f0105a43 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f0105a42:	90                   	nop
	}
	if (i == NUM_USER_PROGS) {
f0105a43:	a1 60 a9 13 f0       	mov    0xf013a960,%eax
f0105a48:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0105a4b:	75 1a                	jne    f0105a67 <get_user_program_info+0x69>
		cprintf("Unknown user program '%s'\n", user_program_name);
f0105a4d:	83 ec 08             	sub    $0x8,%esp
f0105a50:	ff 75 08             	pushl  0x8(%ebp)
f0105a53:	68 e7 15 11 f0       	push   $0xf01115e7
f0105a58:	e8 fe 05 00 00       	call   f010605b <cprintf>
f0105a5d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0105a60:	b8 00 00 00 00       	mov    $0x0,%eax
f0105a65:	eb 11                	jmp    f0105a78 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f0105a67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105a6a:	89 d0                	mov    %edx,%eax
f0105a6c:	01 c0                	add    %eax,%eax
f0105a6e:	01 d0                	add    %edx,%eax
f0105a70:	c1 e0 02             	shl    $0x2,%eax
f0105a73:	05 40 a7 13 f0       	add    $0xf013a740,%eax
}
f0105a78:	c9                   	leave  
f0105a79:	c3                   	ret    

f0105a7a <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e) {
f0105a7a:	55                   	push   %ebp
f0105a7b:	89 e5                	mov    %esp,%ebp
f0105a7d:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f0105a80:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105a87:	eb 30                	jmp    f0105ab9 <get_user_program_info_by_env+0x3f>
		if (strcmp(e->prog_name, userPrograms[i].name) == 0)
f0105a89:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105a8c:	89 d0                	mov    %edx,%eax
f0105a8e:	01 c0                	add    %eax,%eax
f0105a90:	01 d0                	add    %edx,%eax
f0105a92:	c1 e0 02             	shl    $0x2,%eax
f0105a95:	05 40 a7 13 f0       	add    $0xf013a740,%eax
f0105a9a:	8b 10                	mov    (%eax),%edx
f0105a9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a9f:	8b 80 ec 02 00 00    	mov    0x2ec(%eax),%eax
f0105aa5:	83 ec 08             	sub    $0x8,%esp
f0105aa8:	52                   	push   %edx
f0105aa9:	50                   	push   %eax
f0105aaa:	e8 0d 91 00 00       	call   f010ebbc <strcmp>
f0105aaf:	83 c4 10             	add    $0x10,%esp
f0105ab2:	85 c0                	test   %eax,%eax
f0105ab4:	74 0f                	je     f0105ac5 <get_user_program_info_by_env+0x4b>
	return &userPrograms[i];
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e) {
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f0105ab6:	ff 45 f4             	incl   -0xc(%ebp)
f0105ab9:	a1 60 a9 13 f0       	mov    0xf013a960,%eax
f0105abe:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0105ac1:	7c c6                	jl     f0105a89 <get_user_program_info_by_env+0xf>
f0105ac3:	eb 01                	jmp    f0105ac6 <get_user_program_info_by_env+0x4c>
		if (strcmp(e->prog_name, userPrograms[i].name) == 0)
			break;
f0105ac5:	90                   	nop
	}
	if (i == NUM_USER_PROGS) {
f0105ac6:	a1 60 a9 13 f0       	mov    0xf013a960,%eax
f0105acb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0105ace:	75 17                	jne    f0105ae7 <get_user_program_info_by_env+0x6d>
		cprintf("Unknown user program \n");
f0105ad0:	83 ec 0c             	sub    $0xc,%esp
f0105ad3:	68 02 16 11 f0       	push   $0xf0111602
f0105ad8:	e8 7e 05 00 00       	call   f010605b <cprintf>
f0105add:	83 c4 10             	add    $0x10,%esp
		return 0;
f0105ae0:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ae5:	eb 11                	jmp    f0105af8 <get_user_program_info_by_env+0x7e>
	}

	return &userPrograms[i];
f0105ae7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105aea:	89 d0                	mov    %edx,%eax
f0105aec:	01 c0                	add    %eax,%eax
f0105aee:	01 d0                	add    %edx,%eax
f0105af0:	c1 e0 02             	shl    $0x2,%eax
f0105af3:	05 40 a7 13 f0       	add    $0xf013a740,%eax
}
f0105af8:	c9                   	leave  
f0105af9:	c3                   	ret    

f0105afa <set_environment_entry_point>:

void set_environment_entry_point(struct Env* e, uint8* ptr_program_start) {
f0105afa:	55                   	push   %ebp
f0105afb:	89 e5                	mov    %esp,%ebp
f0105afd:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *) ptr_program_start;
f0105b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105b03:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f0105b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b09:	8b 00                	mov    (%eax),%eax
f0105b0b:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f0105b10:	74 17                	je     f0105b29 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f0105b12:	83 ec 04             	sub    $0x4,%esp
f0105b15:	68 d1 15 11 f0       	push   $0xf01115d1
f0105b1a:	68 cc 03 00 00       	push   $0x3cc
f0105b1f:	68 73 15 11 f0       	push   $0xf0111573
f0105b24:	e8 33 a6 ff ff       	call   f010015c <_panic>
	e->env_tf.tf_eip = (uint32*) pELFHDR->e_entry;
f0105b29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b2c:	8b 40 18             	mov    0x18(%eax),%eax
f0105b2f:	89 c2                	mov    %eax,%edx
f0105b31:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b34:	89 50 30             	mov    %edx,0x30(%eax)
}
f0105b37:	90                   	nop
f0105b38:	c9                   	leave  
f0105b39:	c3                   	ret    

f0105b3a <env_exit>:

/*2015*/	//it add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit() {
f0105b3a:	55                   	push   %ebp
f0105b3b:	89 e5                	mov    %esp,%ebp
f0105b3d:	83 ec 08             	sub    $0x8,%esp
	sched_exit_env(curenv->env_id);
f0105b40:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0105b45:	8b 40 4c             	mov    0x4c(%eax),%eax
f0105b48:	83 ec 0c             	sub    $0xc,%esp
f0105b4b:	50                   	push   %eax
f0105b4c:	e8 3d 2d 00 00       	call   f010888e <sched_exit_env>
f0105b51:	83 c4 10             	add    $0x10,%esp
	fos_scheduler();
f0105b54:	e8 d6 23 00 00       	call   f0107f2f <fos_scheduler>

f0105b59 <env_destroy>:
// Frees environment e.
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
/*2015*///obsolete! we run on a scheduler!!
void env_destroy(struct Env *e) {
f0105b59:	55                   	push   %ebp
f0105b5a:	89 e5                	mov    %esp,%ebp
f0105b5c:	83 ec 08             	sub    $0x8,%esp
	panic("env_destroy() is obsoleted since 2015!");
f0105b5f:	83 ec 04             	sub    $0x4,%esp
f0105b62:	68 1c 16 11 f0       	push   $0xf011161c
f0105b67:	68 dd 03 00 00       	push   $0x3dd
f0105b6c:	68 73 15 11 f0       	push   $0xf0111573
f0105b71:	e8 e6 a5 ff ff       	call   f010015c <_panic>

f0105b76 <cleanup_buffers>:
	 while (1)
	 run_command_prompt();
	 */
}

void cleanup_buffers(struct Env* e) {
f0105b76:	55                   	push   %ebp
f0105b77:	89 e5                	mov    %esp,%ebp
f0105b79:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct Frame_Info *ptr_fi = NULL;
f0105b7c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	LIST_FOREACH(ptr_fi, &modified_frame_list)
f0105b83:	a1 60 52 45 f0       	mov    0xf0455260,%eax
f0105b88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b8b:	eb 4d                	jmp    f0105bda <cleanup_buffers+0x64>
	{
		if (ptr_fi->environment == e) {
f0105b8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b90:	8b 40 10             	mov    0x10(%eax),%eax
f0105b93:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b96:	75 3a                	jne    f0105bd2 <cleanup_buffers+0x5c>
			pt_clear_page_table_entry(ptr_fi->environment, ptr_fi->va);
f0105b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b9b:	8b 50 0c             	mov    0xc(%eax),%edx
f0105b9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba1:	8b 40 10             	mov    0x10(%eax),%eax
f0105ba4:	83 ec 08             	sub    $0x8,%esp
f0105ba7:	52                   	push   %edx
f0105ba8:	50                   	push   %eax
f0105ba9:	e8 0f e6 ff ff       	call   f01041bd <pt_clear_page_table_entry>
f0105bae:	83 c4 10             	add    $0x10,%esp

			//cprintf("==================\n");
			//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
			bufferlist_remove_page(&modified_frame_list, ptr_fi);
f0105bb1:	83 ec 08             	sub    $0x8,%esp
f0105bb4:	ff 75 f4             	pushl  -0xc(%ebp)
f0105bb7:	68 60 52 45 f0       	push   $0xf0455260
f0105bbc:	e8 ea e2 ff ff       	call   f0103eab <bufferlist_remove_page>
f0105bc1:	83 c4 10             	add    $0x10,%esp

			free_frame(ptr_fi);
f0105bc4:	83 ec 0c             	sub    $0xc,%esp
f0105bc7:	ff 75 f4             	pushl  -0xc(%ebp)
f0105bca:	e8 b4 d0 ff ff       	call   f0102c83 <free_frame>
f0105bcf:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	LIST_FOREACH(ptr_fi, &modified_frame_list)
f0105bd2:	a1 68 52 45 f0       	mov    0xf0455268,%eax
f0105bd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105bda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bde:	74 07                	je     f0105be7 <cleanup_buffers+0x71>
f0105be0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105be3:	8b 00                	mov    (%eax),%eax
f0105be5:	eb 05                	jmp    f0105bec <cleanup_buffers+0x76>
f0105be7:	b8 00 00 00 00       	mov    $0x0,%eax
f0105bec:	a3 68 52 45 f0       	mov    %eax,0xf0455268
f0105bf1:	a1 68 52 45 f0       	mov    0xf0455268,%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	75 93                	jne    f0105b8d <cleanup_buffers+0x17>
f0105bfa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bfe:	75 8d                	jne    f0105b8d <cleanup_buffers+0x17>
	}

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f0105c00:	90                   	nop
f0105c01:	c9                   	leave  
f0105c02:	c3                   	ret    

f0105c03 <env_run_cmd_prmpt>:

/*2015*///obsolete! use env_exit() instead! it add the exited env to the EXIT list, then reinvoke the scheduler
void env_run_cmd_prmpt() {
f0105c03:	55                   	push   %ebp
f0105c04:	89 e5                	mov    %esp,%ebp
f0105c06:	83 ec 08             	sub    $0x8,%esp
	panic(
f0105c09:	83 ec 04             	sub    $0x4,%esp
f0105c0c:	68 44 16 11 f0       	push   $0xf0111644
f0105c11:	68 07 04 00 00       	push   $0x407
f0105c16:	68 73 15 11 f0       	push   $0xf0111573
f0105c1b:	e8 3c a5 ff ff       	call   f010015c <_panic>

f0105c20 <env_pop_tf>:
//
// Restores the register values in the Trapframe with the 'iret' instruction.
// This exits the kernel and starts executing some environment's code.
// This function does not return.
//
void env_pop_tf(struct Trapframe *tf) {
f0105c20:	55                   	push   %ebp
f0105c21:	89 e5                	mov    %esp,%ebp
f0105c23:	83 ec 08             	sub    $0x8,%esp
	__asm __volatile("movl %0,%%esp\n"
f0105c26:	8b 65 08             	mov    0x8(%ebp),%esp
f0105c29:	61                   	popa   
f0105c2a:	07                   	pop    %es
f0105c2b:	1f                   	pop    %ds
f0105c2c:	83 c4 08             	add    $0x8,%esp
f0105c2f:	cf                   	iret   
			"\tpopl %%es\n"
			"\tpopl %%ds\n"
			"\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
			"\tiret"
			: : "g" (tf) : "memory");
	panic("iret failed"); /* mostly to placate the compiler */
f0105c30:	83 ec 04             	sub    $0x4,%esp
f0105c33:	68 88 16 11 f0       	push   $0xf0111688
f0105c38:	68 5e 04 00 00       	push   $0x45e
f0105c3d:	68 73 15 11 f0       	push   $0xf0111573
f0105c42:	e8 15 a5 ff ff       	call   f010015c <_panic>

f0105c47 <mc146818_read>:
#include <kern/kclock.h>
#include <kern/picirq.h>

unsigned
mc146818_read(unsigned reg)
{
f0105c47:	55                   	push   %ebp
f0105c48:	89 e5                	mov    %esp,%ebp
f0105c4a:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105c4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105c50:	0f b6 c0             	movzbl %al,%eax
f0105c53:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105c5a:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105c5d:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105c60:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105c63:	ee                   	out    %al,(%dx)
f0105c64:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105c6b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105c6e:	89 c2                	mov    %eax,%edx
f0105c70:	ec                   	in     (%dx),%al
f0105c71:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0105c74:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0105c77:	0f b6 c0             	movzbl %al,%eax
}
f0105c7a:	c9                   	leave  
f0105c7b:	c3                   	ret    

f0105c7c <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0105c7c:	55                   	push   %ebp
f0105c7d:	89 e5                	mov    %esp,%ebp
f0105c7f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105c82:	8b 45 08             	mov    0x8(%ebp),%eax
f0105c85:	0f b6 c0             	movzbl %al,%eax
f0105c88:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105c8f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105c92:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105c95:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105c98:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0105c99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105c9c:	0f b6 c0             	movzbl %al,%eax
f0105c9f:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0105ca6:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105ca9:	8a 45 f7             	mov    -0x9(%ebp),%al
f0105cac:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0105caf:	ee                   	out    %al,(%dx)
}
f0105cb0:	90                   	nop
f0105cb1:	c9                   	leave  
f0105cb2:	c3                   	ret    

f0105cb3 <kclock_start>:


void
kclock_start(void)
{
f0105cb3:	55                   	push   %ebp
f0105cb4:	89 e5                	mov    %esp,%ebp
f0105cb6:	83 ec 28             	sub    $0x28,%esp
	uint16 cnt0 = kclock_read_cnt0() ;
f0105cb9:	e8 fd 00 00 00       	call   f0105dbb <kclock_read_cnt0>
f0105cbe:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0105cc2:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105cc9:	c6 45 e5 34          	movb   $0x34,-0x1b(%ebp)
f0105ccd:	8a 45 e5             	mov    -0x1b(%ebp),%al
f0105cd0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105cd3:	ee                   	out    %al,(%dx)
f0105cd4:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)
f0105cdb:	c6 45 e6 38          	movb   $0x38,-0x1a(%ebp)
f0105cdf:	8a 45 e6             	mov    -0x1a(%ebp),%al
f0105ce2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ce5:	ee                   	out    %al,(%dx)
f0105ce6:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)
f0105ced:	c6 45 e7 5d          	movb   $0x5d,-0x19(%ebp)
f0105cf1:	8a 45 e7             	mov    -0x19(%ebp),%al
f0105cf4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0105cf7:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL)) % 256);
	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL)) / 256);
//	cprintf("Timer Started: Counter0 Value = %x\n", cnt0 );

	//cprintf("	Setup timer interrupts via 8259A\n");
	irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
f0105cf8:	66 a1 64 a9 13 f0    	mov    0xf013a964,%ax
f0105cfe:	0f b7 c0             	movzwl %ax,%eax
f0105d01:	25 fe ff 00 00       	and    $0xfffe,%eax
f0105d06:	83 ec 0c             	sub    $0xc,%esp
f0105d09:	50                   	push   %eax
f0105d0a:	e8 ad 02 00 00       	call   f0105fbc <irq_setmask_8259A>
f0105d0f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0105d12:	90                   	nop
f0105d13:	c9                   	leave  
f0105d14:	c3                   	ret    

f0105d15 <kclock_resume>:

void
kclock_resume(void)
{
f0105d15:	55                   	push   %ebp
f0105d16:	89 e5                	mov    %esp,%ebp
f0105d18:	83 ec 28             	sub    $0x28,%esp
	uint16 cnt0 = kclock_read_cnt0() ;
f0105d1b:	e8 9b 00 00 00       	call   f0105dbb <kclock_read_cnt0>
f0105d20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0105d24:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105d2b:	c6 45 e5 34          	movb   $0x34,-0x1b(%ebp)
f0105d2f:	8a 45 e5             	mov    -0x1b(%ebp),%al
f0105d32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105d35:	ee                   	out    %al,(%dx)
	//cprintf("Timer RESUMED: Counter0 Value = %x\n", cnt0 );

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	outb(TIMER_CNTR0, (uint8)(cnt0 & 0x00FF));
f0105d36:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105d3a:	0f b6 c0             	movzbl %al,%eax
f0105d3d:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)
f0105d44:	88 45 e6             	mov    %al,-0x1a(%ebp)
f0105d47:	8a 45 e6             	mov    -0x1a(%ebp),%al
f0105d4a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105d4d:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((cnt0>>8) & 0x00FF));
f0105d4e:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105d52:	66 c1 e8 08          	shr    $0x8,%ax
f0105d56:	0f b6 c0             	movzbl %al,%eax
f0105d59:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)
f0105d60:	88 45 e7             	mov    %al,-0x19(%ebp)
f0105d63:	8a 45 e7             	mov    -0x19(%ebp),%al
f0105d66:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0105d69:	ee                   	out    %al,(%dx)
	cnt0 = kclock_read_cnt0() ;
f0105d6a:	e8 4c 00 00 00       	call   f0105dbb <kclock_read_cnt0>
f0105d6f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("Timer RESUMED: Counter0 Value = %x\n", cnt0 );

	//cprintf("	Setup timer interrupts via 8259A\n");
	irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
f0105d73:	66 a1 64 a9 13 f0    	mov    0xf013a964,%ax
f0105d79:	0f b7 c0             	movzwl %ax,%eax
f0105d7c:	25 fe ff 00 00       	and    $0xfffe,%eax
f0105d81:	83 ec 0c             	sub    $0xc,%esp
f0105d84:	50                   	push   %eax
f0105d85:	e8 32 02 00 00       	call   f0105fbc <irq_setmask_8259A>
f0105d8a:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0105d8d:	90                   	nop
f0105d8e:	c9                   	leave  
f0105d8f:	c3                   	ret    

f0105d90 <kclock_stop>:

void
kclock_stop(void)
{
f0105d90:	55                   	push   %ebp
f0105d91:	89 e5                	mov    %esp,%ebp
f0105d93:	83 ec 18             	sub    $0x18,%esp
f0105d96:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105d9d:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105da1:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105da4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105da7:	ee                   	out    %al,(%dx)
//		}
//	uint16 cnt0_after = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Before Lag = %x, After lag = %x\n", cnt0_before, cnt0_after );


	irq_setmask_8259A(0xFFFF);
f0105da8:	83 ec 0c             	sub    $0xc,%esp
f0105dab:	68 ff ff 00 00       	push   $0xffff
f0105db0:	e8 07 02 00 00       	call   f0105fbc <irq_setmask_8259A>
f0105db5:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0105db8:	90                   	nop
f0105db9:	c9                   	leave  
f0105dba:	c3                   	ret    

f0105dbb <kclock_read_cnt0>:


uint16
kclock_read_cnt0(void)
{
f0105dbb:	55                   	push   %ebp
f0105dbc:	89 e5                	mov    %esp,%ebp
f0105dbe:	83 ec 20             	sub    $0x20,%esp
f0105dc1:	c7 45 f8 40 00 00 00 	movl   $0x40,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105dc8:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105dcb:	89 c2                	mov    %eax,%edx
f0105dcd:	ec                   	in     (%dx),%al
f0105dce:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0105dd1:	8a 45 ee             	mov    -0x12(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105dd4:	88 45 ff             	mov    %al,-0x1(%ebp)
f0105dd7:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105dde:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105de1:	89 c2                	mov    %eax,%edx
f0105de3:	ec                   	in     (%dx),%al
f0105de4:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0105de7:	8a 45 ef             	mov    -0x11(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105dea:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105ded:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0105df1:	c1 e0 08             	shl    $0x8,%eax
f0105df4:	89 c2                	mov    %eax,%edx
f0105df6:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105dfa:	09 d0                	or     %edx,%eax
f0105dfc:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
	return cnt0 ;
f0105e00:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0105e03:	c9                   	leave  
f0105e04:	c3                   	ret    

f0105e05 <kclock_read_cnt0_latch>:


uint16
kclock_read_cnt0_latch(void)
{
f0105e05:	55                   	push   %ebp
f0105e06:	89 e5                	mov    %esp,%ebp
f0105e08:	83 ec 30             	sub    $0x30,%esp
f0105e0b:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e12:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105e15:	89 c2                	mov    %eax,%edx
f0105e17:	ec                   	in     (%dx),%al
f0105e18:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0105e1b:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0105e1e:	88 45 ff             	mov    %al,-0x1(%ebp)
f0105e21:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105e28:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105e2c:	8a 45 dc             	mov    -0x24(%ebp),%al
f0105e2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e32:	ee                   	out    %al,(%dx)
f0105e33:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105e3d:	89 c2                	mov    %eax,%edx
f0105e3f:	ec                   	in     (%dx),%al
f0105e40:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0105e43:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105e46:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105e49:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105e53:	89 c2                	mov    %eax,%edx
f0105e55:	ec                   	in     (%dx),%al
f0105e56:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105e59:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105e5c:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105e5f:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0105e63:	c1 e0 08             	shl    $0x8,%eax
f0105e66:	89 c2                	mov    %eax,%edx
f0105e68:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105e6c:	09 d0                	or     %edx,%eax
f0105e6e:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0105e72:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105e76:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105e7d:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105e80:	8a 45 df             	mov    -0x21(%ebp),%al
f0105e83:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105e86:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105e87:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105e8a:	c9                   	leave  
f0105e8b:	c3                   	ret    

f0105e8c <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0105e8c:	55                   	push   %ebp
f0105e8d:	89 e5                	mov    %esp,%ebp
f0105e8f:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0105e92:	c7 05 4c a1 42 f0 01 	movl   $0x1,0xf042a14c
f0105e99:	00 00 00 
f0105e9c:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0105ea3:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
f0105ea7:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0105eaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ead:	ee                   	out    %al,(%dx)
f0105eae:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0105eb5:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0105eb9:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0105ebc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ebf:	ee                   	out    %al,(%dx)
f0105ec0:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0105ec7:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0105ecb:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0105ece:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ed1:	ee                   	out    %al,(%dx)
f0105ed2:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0105ed9:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0105edd:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0105ee0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0105ee3:	ee                   	out    %al,(%dx)
f0105ee4:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0105eeb:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0105eef:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0105ef2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0105ef5:	ee                   	out    %al,(%dx)
f0105ef6:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0105efd:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0105f01:	8a 45 b7             	mov    -0x49(%ebp),%al
f0105f04:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105f07:	ee                   	out    %al,(%dx)
f0105f08:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0105f0f:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0105f13:	8a 45 b8             	mov    -0x48(%ebp),%al
f0105f16:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0105f19:	ee                   	out    %al,(%dx)
f0105f1a:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0105f21:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0105f25:	8a 45 b9             	mov    -0x47(%ebp),%al
f0105f28:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0105f2b:	ee                   	out    %al,(%dx)
f0105f2c:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0105f33:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0105f37:	8a 45 ba             	mov    -0x46(%ebp),%al
f0105f3a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0105f3d:	ee                   	out    %al,(%dx)
f0105f3e:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0105f45:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0105f49:	8a 45 bb             	mov    -0x45(%ebp),%al
f0105f4c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0105f4f:	ee                   	out    %al,(%dx)
f0105f50:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0105f57:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0105f5b:	8a 45 bc             	mov    -0x44(%ebp),%al
f0105f5e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0105f61:	ee                   	out    %al,(%dx)
f0105f62:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0105f69:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0105f6d:	8a 45 bd             	mov    -0x43(%ebp),%al
f0105f70:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0105f73:	ee                   	out    %al,(%dx)
f0105f74:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0105f7b:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0105f7f:	8a 45 be             	mov    -0x42(%ebp),%al
f0105f82:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0105f85:	ee                   	out    %al,(%dx)
f0105f86:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0105f8d:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0105f91:	8a 45 bf             	mov    -0x41(%ebp),%al
f0105f94:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0105f97:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
f0105f98:	66 a1 64 a9 13 f0    	mov    0xf013a964,%ax
f0105f9e:	66 83 f8 ff          	cmp    $0xffff,%ax
f0105fa2:	74 15                	je     f0105fb9 <pic_init+0x12d>
		irq_setmask_8259A(irq_mask_8259A);
f0105fa4:	66 a1 64 a9 13 f0    	mov    0xf013a964,%ax
f0105faa:	0f b7 c0             	movzwl %ax,%eax
f0105fad:	83 ec 0c             	sub    $0xc,%esp
f0105fb0:	50                   	push   %eax
f0105fb1:	e8 06 00 00 00       	call   f0105fbc <irq_setmask_8259A>
f0105fb6:	83 c4 10             	add    $0x10,%esp
}
f0105fb9:	90                   	nop
f0105fba:	c9                   	leave  
f0105fbb:	c3                   	ret    

f0105fbc <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0105fbc:	55                   	push   %ebp
f0105fbd:	89 e5                	mov    %esp,%ebp
f0105fbf:	83 ec 14             	sub    $0x14,%esp
f0105fc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fc5:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	int i;
	irq_mask_8259A = mask;
f0105fc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105fcc:	66 a3 64 a9 13 f0    	mov    %ax,0xf013a964
	if (!didinit)
f0105fd2:	a1 4c a1 42 f0       	mov    0xf042a14c,%eax
f0105fd7:	85 c0                	test   %eax,%eax
f0105fd9:	74 34                	je     f010600f <irq_setmask_8259A+0x53>
		return;
	outb(IO_PIC1+1, (char)mask);
f0105fdb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105fde:	0f b6 c0             	movzbl %al,%eax
f0105fe1:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0105fe8:	88 45 f6             	mov    %al,-0xa(%ebp)
f0105feb:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105fee:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105ff1:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
f0105ff2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105ff5:	66 c1 e8 08          	shr    $0x8,%ax
f0105ff9:	0f b6 c0             	movzbl %al,%eax
f0105ffc:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106003:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106006:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106009:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010600c:	ee                   	out    %al,(%dx)
f010600d:	eb 01                	jmp    f0106010 <irq_setmask_8259A+0x54>
irq_setmask_8259A(uint16 mask)
{
	int i;
	irq_mask_8259A = mask;
	if (!didinit)
		return;
f010600f:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (i = 0; i < 16; i++)
		//if (~mask & (1<<i))
			//cprintf(" %d", i);
	//cprintf("\n");
}
f0106010:	c9                   	leave  
f0106011:	c3                   	ret    

f0106012 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
f0106012:	55                   	push   %ebp
f0106013:	89 e5                	mov    %esp,%ebp
f0106015:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0106018:	83 ec 0c             	sub    $0xc,%esp
f010601b:	ff 75 08             	pushl  0x8(%ebp)
f010601e:	e8 20 aa ff ff       	call   f0100a43 <cputchar>
f0106023:	83 c4 10             	add    $0x10,%esp
	*cnt++;
f0106026:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106029:	83 c0 04             	add    $0x4,%eax
f010602c:	89 45 0c             	mov    %eax,0xc(%ebp)
}
f010602f:	90                   	nop
f0106030:	c9                   	leave  
f0106031:	c3                   	ret    

f0106032 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0106032:	55                   	push   %ebp
f0106033:	89 e5                	mov    %esp,%ebp
f0106035:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0106038:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f010603f:	ff 75 0c             	pushl  0xc(%ebp)
f0106042:	ff 75 08             	pushl  0x8(%ebp)
f0106045:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0106048:	50                   	push   %eax
f0106049:	68 12 60 10 f0       	push   $0xf0106012
f010604e:	e8 af 83 00 00       	call   f010e402 <vprintfmt>
f0106053:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0106056:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106059:	c9                   	leave  
f010605a:	c3                   	ret    

f010605b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f010605b:	55                   	push   %ebp
f010605c:	89 e5                	mov    %esp,%ebp
f010605e:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
f0106061:	8d 45 0c             	lea    0xc(%ebp),%eax
f0106064:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cnt = vcprintf(fmt, ap);
f0106067:	8b 45 08             	mov    0x8(%ebp),%eax
f010606a:	83 ec 08             	sub    $0x8,%esp
f010606d:	ff 75 f4             	pushl  -0xc(%ebp)
f0106070:	50                   	push   %eax
f0106071:	e8 bc ff ff ff       	call   f0106032 <vcprintf>
f0106076:	83 c4 10             	add    $0x10,%esp
f0106079:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return cnt;
f010607c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010607f:	c9                   	leave  
f0106080:	c3                   	ret    

f0106081 <trapname>:
extern void (*ALL_FAULTS44)();
extern void (*ALL_FAULTS45)();
extern void (*ALL_FAULTS46)();
extern void (*ALL_FAULTS47)();

static const char *trapname(int trapno) {
f0106081:	55                   	push   %ebp
f0106082:	89 e5                	mov    %esp,%ebp
					"Segment Not Present", "Stack Fault", "General Protection",
					"Page Fault", "(unknown trap)",
					"x87 FPU Floating-Point Error", "Alignment Check",
					"Machine-Check", "SIMD Floating-Point Exception" };

	if (trapno < sizeof(excnames) / sizeof(excnames[0]))
f0106084:	8b 45 08             	mov    0x8(%ebp),%eax
f0106087:	83 f8 13             	cmp    $0x13,%eax
f010608a:	77 0c                	ja     f0106098 <trapname+0x17>
		return excnames[trapno];
f010608c:	8b 45 08             	mov    0x8(%ebp),%eax
f010608f:	8b 04 85 40 1a 11 f0 	mov    -0xfeee5c0(,%eax,4),%eax
f0106096:	eb 12                	jmp    f01060aa <trapname+0x29>
	if (trapno == T_SYSCALL)
f0106098:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010609c:	75 07                	jne    f01060a5 <trapname+0x24>
		return "System call";
f010609e:	b8 a0 16 11 f0       	mov    $0xf01116a0,%eax
f01060a3:	eb 05                	jmp    f01060aa <trapname+0x29>
	return "(unknown trap)";
f01060a5:	b8 ac 16 11 f0       	mov    $0xf01116ac,%eax
}
f01060aa:	5d                   	pop    %ebp
f01060ab:	c3                   	ret    

f01060ac <idt_init>:

void idt_init(void) {
f01060ac:	55                   	push   %ebp
f01060ad:	89 e5                	mov    %esp,%ebp
f01060af:	83 ec 10             	sub    $0x10,%esp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
	//initialize idt
	SETGATE(idt[T_PGFLT], 0, GD_KT, &PAGE_FAULT, 0);
f01060b2:	b8 22 7e 10 f0       	mov    $0xf0107e22,%eax
f01060b7:	66 a3 f0 a1 42 f0    	mov    %ax,0xf042a1f0
f01060bd:	66 c7 05 f2 a1 42 f0 	movw   $0x8,0xf042a1f2
f01060c4:	08 00 
f01060c6:	a0 f4 a1 42 f0       	mov    0xf042a1f4,%al
f01060cb:	83 e0 e0             	and    $0xffffffe0,%eax
f01060ce:	a2 f4 a1 42 f0       	mov    %al,0xf042a1f4
f01060d3:	a0 f4 a1 42 f0       	mov    0xf042a1f4,%al
f01060d8:	83 e0 1f             	and    $0x1f,%eax
f01060db:	a2 f4 a1 42 f0       	mov    %al,0xf042a1f4
f01060e0:	a0 f5 a1 42 f0       	mov    0xf042a1f5,%al
f01060e5:	83 e0 f0             	and    $0xfffffff0,%eax
f01060e8:	83 c8 0e             	or     $0xe,%eax
f01060eb:	a2 f5 a1 42 f0       	mov    %al,0xf042a1f5
f01060f0:	a0 f5 a1 42 f0       	mov    0xf042a1f5,%al
f01060f5:	83 e0 ef             	and    $0xffffffef,%eax
f01060f8:	a2 f5 a1 42 f0       	mov    %al,0xf042a1f5
f01060fd:	a0 f5 a1 42 f0       	mov    0xf042a1f5,%al
f0106102:	83 e0 9f             	and    $0xffffff9f,%eax
f0106105:	a2 f5 a1 42 f0       	mov    %al,0xf042a1f5
f010610a:	a0 f5 a1 42 f0       	mov    0xf042a1f5,%al
f010610f:	83 c8 80             	or     $0xffffff80,%eax
f0106112:	a2 f5 a1 42 f0       	mov    %al,0xf042a1f5
f0106117:	b8 22 7e 10 f0       	mov    $0xf0107e22,%eax
f010611c:	c1 e8 10             	shr    $0x10,%eax
f010611f:	66 a3 f6 a1 42 f0    	mov    %ax,0xf042a1f6
	SETGATE(idt[T_SYSCALL], 0, GD_KT, &SYSCALL_HANDLER, 3);
f0106125:	b8 2a 7e 10 f0       	mov    $0xf0107e2a,%eax
f010612a:	66 a3 00 a3 42 f0    	mov    %ax,0xf042a300
f0106130:	66 c7 05 02 a3 42 f0 	movw   $0x8,0xf042a302
f0106137:	08 00 
f0106139:	a0 04 a3 42 f0       	mov    0xf042a304,%al
f010613e:	83 e0 e0             	and    $0xffffffe0,%eax
f0106141:	a2 04 a3 42 f0       	mov    %al,0xf042a304
f0106146:	a0 04 a3 42 f0       	mov    0xf042a304,%al
f010614b:	83 e0 1f             	and    $0x1f,%eax
f010614e:	a2 04 a3 42 f0       	mov    %al,0xf042a304
f0106153:	a0 05 a3 42 f0       	mov    0xf042a305,%al
f0106158:	83 e0 f0             	and    $0xfffffff0,%eax
f010615b:	83 c8 0e             	or     $0xe,%eax
f010615e:	a2 05 a3 42 f0       	mov    %al,0xf042a305
f0106163:	a0 05 a3 42 f0       	mov    0xf042a305,%al
f0106168:	83 e0 ef             	and    $0xffffffef,%eax
f010616b:	a2 05 a3 42 f0       	mov    %al,0xf042a305
f0106170:	a0 05 a3 42 f0       	mov    0xf042a305,%al
f0106175:	83 c8 60             	or     $0x60,%eax
f0106178:	a2 05 a3 42 f0       	mov    %al,0xf042a305
f010617d:	a0 05 a3 42 f0       	mov    0xf042a305,%al
f0106182:	83 c8 80             	or     $0xffffff80,%eax
f0106185:	a2 05 a3 42 f0       	mov    %al,0xf042a305
f010618a:	b8 2a 7e 10 f0       	mov    $0xf0107e2a,%eax
f010618f:	c1 e8 10             	shr    $0x10,%eax
f0106192:	66 a3 06 a3 42 f0    	mov    %ax,0xf042a306
	SETGATE(idt[T_DBLFLT], 0, GD_KT, &DBL_FAULT, 0);
f0106198:	b8 34 7e 10 f0       	mov    $0xf0107e34,%eax
f010619d:	66 a3 c0 a1 42 f0    	mov    %ax,0xf042a1c0
f01061a3:	66 c7 05 c2 a1 42 f0 	movw   $0x8,0xf042a1c2
f01061aa:	08 00 
f01061ac:	a0 c4 a1 42 f0       	mov    0xf042a1c4,%al
f01061b1:	83 e0 e0             	and    $0xffffffe0,%eax
f01061b4:	a2 c4 a1 42 f0       	mov    %al,0xf042a1c4
f01061b9:	a0 c4 a1 42 f0       	mov    0xf042a1c4,%al
f01061be:	83 e0 1f             	and    $0x1f,%eax
f01061c1:	a2 c4 a1 42 f0       	mov    %al,0xf042a1c4
f01061c6:	a0 c5 a1 42 f0       	mov    0xf042a1c5,%al
f01061cb:	83 e0 f0             	and    $0xfffffff0,%eax
f01061ce:	83 c8 0e             	or     $0xe,%eax
f01061d1:	a2 c5 a1 42 f0       	mov    %al,0xf042a1c5
f01061d6:	a0 c5 a1 42 f0       	mov    0xf042a1c5,%al
f01061db:	83 e0 ef             	and    $0xffffffef,%eax
f01061de:	a2 c5 a1 42 f0       	mov    %al,0xf042a1c5
f01061e3:	a0 c5 a1 42 f0       	mov    0xf042a1c5,%al
f01061e8:	83 e0 9f             	and    $0xffffff9f,%eax
f01061eb:	a2 c5 a1 42 f0       	mov    %al,0xf042a1c5
f01061f0:	a0 c5 a1 42 f0       	mov    0xf042a1c5,%al
f01061f5:	83 c8 80             	or     $0xffffff80,%eax
f01061f8:	a2 c5 a1 42 f0       	mov    %al,0xf042a1c5
f01061fd:	b8 34 7e 10 f0       	mov    $0xf0107e34,%eax
f0106202:	c1 e8 10             	shr    $0x10,%eax
f0106205:	66 a3 c6 a1 42 f0    	mov    %ax,0xf042a1c6

	SETGATE(idt[T_DIVIDE ], 0, GD_KT, &ALL_FAULTS0, 3);
f010620b:	b8 3c 7e 10 f0       	mov    $0xf0107e3c,%eax
f0106210:	66 a3 80 a1 42 f0    	mov    %ax,0xf042a180
f0106216:	66 c7 05 82 a1 42 f0 	movw   $0x8,0xf042a182
f010621d:	08 00 
f010621f:	a0 84 a1 42 f0       	mov    0xf042a184,%al
f0106224:	83 e0 e0             	and    $0xffffffe0,%eax
f0106227:	a2 84 a1 42 f0       	mov    %al,0xf042a184
f010622c:	a0 84 a1 42 f0       	mov    0xf042a184,%al
f0106231:	83 e0 1f             	and    $0x1f,%eax
f0106234:	a2 84 a1 42 f0       	mov    %al,0xf042a184
f0106239:	a0 85 a1 42 f0       	mov    0xf042a185,%al
f010623e:	83 e0 f0             	and    $0xfffffff0,%eax
f0106241:	83 c8 0e             	or     $0xe,%eax
f0106244:	a2 85 a1 42 f0       	mov    %al,0xf042a185
f0106249:	a0 85 a1 42 f0       	mov    0xf042a185,%al
f010624e:	83 e0 ef             	and    $0xffffffef,%eax
f0106251:	a2 85 a1 42 f0       	mov    %al,0xf042a185
f0106256:	a0 85 a1 42 f0       	mov    0xf042a185,%al
f010625b:	83 c8 60             	or     $0x60,%eax
f010625e:	a2 85 a1 42 f0       	mov    %al,0xf042a185
f0106263:	a0 85 a1 42 f0       	mov    0xf042a185,%al
f0106268:	83 c8 80             	or     $0xffffff80,%eax
f010626b:	a2 85 a1 42 f0       	mov    %al,0xf042a185
f0106270:	b8 3c 7e 10 f0       	mov    $0xf0107e3c,%eax
f0106275:	c1 e8 10             	shr    $0x10,%eax
f0106278:	66 a3 86 a1 42 f0    	mov    %ax,0xf042a186
	SETGATE(idt[T_DEBUG ], 1, GD_KT, &ALL_FAULTS1, 3);
f010627e:	b8 46 7e 10 f0       	mov    $0xf0107e46,%eax
f0106283:	66 a3 88 a1 42 f0    	mov    %ax,0xf042a188
f0106289:	66 c7 05 8a a1 42 f0 	movw   $0x8,0xf042a18a
f0106290:	08 00 
f0106292:	a0 8c a1 42 f0       	mov    0xf042a18c,%al
f0106297:	83 e0 e0             	and    $0xffffffe0,%eax
f010629a:	a2 8c a1 42 f0       	mov    %al,0xf042a18c
f010629f:	a0 8c a1 42 f0       	mov    0xf042a18c,%al
f01062a4:	83 e0 1f             	and    $0x1f,%eax
f01062a7:	a2 8c a1 42 f0       	mov    %al,0xf042a18c
f01062ac:	a0 8d a1 42 f0       	mov    0xf042a18d,%al
f01062b1:	83 c8 0f             	or     $0xf,%eax
f01062b4:	a2 8d a1 42 f0       	mov    %al,0xf042a18d
f01062b9:	a0 8d a1 42 f0       	mov    0xf042a18d,%al
f01062be:	83 e0 ef             	and    $0xffffffef,%eax
f01062c1:	a2 8d a1 42 f0       	mov    %al,0xf042a18d
f01062c6:	a0 8d a1 42 f0       	mov    0xf042a18d,%al
f01062cb:	83 c8 60             	or     $0x60,%eax
f01062ce:	a2 8d a1 42 f0       	mov    %al,0xf042a18d
f01062d3:	a0 8d a1 42 f0       	mov    0xf042a18d,%al
f01062d8:	83 c8 80             	or     $0xffffff80,%eax
f01062db:	a2 8d a1 42 f0       	mov    %al,0xf042a18d
f01062e0:	b8 46 7e 10 f0       	mov    $0xf0107e46,%eax
f01062e5:	c1 e8 10             	shr    $0x10,%eax
f01062e8:	66 a3 8e a1 42 f0    	mov    %ax,0xf042a18e
	SETGATE(idt[T_NMI ], 0, GD_KT, &ALL_FAULTS2, 3);
f01062ee:	b8 50 7e 10 f0       	mov    $0xf0107e50,%eax
f01062f3:	66 a3 90 a1 42 f0    	mov    %ax,0xf042a190
f01062f9:	66 c7 05 92 a1 42 f0 	movw   $0x8,0xf042a192
f0106300:	08 00 
f0106302:	a0 94 a1 42 f0       	mov    0xf042a194,%al
f0106307:	83 e0 e0             	and    $0xffffffe0,%eax
f010630a:	a2 94 a1 42 f0       	mov    %al,0xf042a194
f010630f:	a0 94 a1 42 f0       	mov    0xf042a194,%al
f0106314:	83 e0 1f             	and    $0x1f,%eax
f0106317:	a2 94 a1 42 f0       	mov    %al,0xf042a194
f010631c:	a0 95 a1 42 f0       	mov    0xf042a195,%al
f0106321:	83 e0 f0             	and    $0xfffffff0,%eax
f0106324:	83 c8 0e             	or     $0xe,%eax
f0106327:	a2 95 a1 42 f0       	mov    %al,0xf042a195
f010632c:	a0 95 a1 42 f0       	mov    0xf042a195,%al
f0106331:	83 e0 ef             	and    $0xffffffef,%eax
f0106334:	a2 95 a1 42 f0       	mov    %al,0xf042a195
f0106339:	a0 95 a1 42 f0       	mov    0xf042a195,%al
f010633e:	83 c8 60             	or     $0x60,%eax
f0106341:	a2 95 a1 42 f0       	mov    %al,0xf042a195
f0106346:	a0 95 a1 42 f0       	mov    0xf042a195,%al
f010634b:	83 c8 80             	or     $0xffffff80,%eax
f010634e:	a2 95 a1 42 f0       	mov    %al,0xf042a195
f0106353:	b8 50 7e 10 f0       	mov    $0xf0107e50,%eax
f0106358:	c1 e8 10             	shr    $0x10,%eax
f010635b:	66 a3 96 a1 42 f0    	mov    %ax,0xf042a196
	SETGATE(idt[T_BRKPT ], 1, GD_KT, &ALL_FAULTS3, 3);
f0106361:	b8 5a 7e 10 f0       	mov    $0xf0107e5a,%eax
f0106366:	66 a3 98 a1 42 f0    	mov    %ax,0xf042a198
f010636c:	66 c7 05 9a a1 42 f0 	movw   $0x8,0xf042a19a
f0106373:	08 00 
f0106375:	a0 9c a1 42 f0       	mov    0xf042a19c,%al
f010637a:	83 e0 e0             	and    $0xffffffe0,%eax
f010637d:	a2 9c a1 42 f0       	mov    %al,0xf042a19c
f0106382:	a0 9c a1 42 f0       	mov    0xf042a19c,%al
f0106387:	83 e0 1f             	and    $0x1f,%eax
f010638a:	a2 9c a1 42 f0       	mov    %al,0xf042a19c
f010638f:	a0 9d a1 42 f0       	mov    0xf042a19d,%al
f0106394:	83 c8 0f             	or     $0xf,%eax
f0106397:	a2 9d a1 42 f0       	mov    %al,0xf042a19d
f010639c:	a0 9d a1 42 f0       	mov    0xf042a19d,%al
f01063a1:	83 e0 ef             	and    $0xffffffef,%eax
f01063a4:	a2 9d a1 42 f0       	mov    %al,0xf042a19d
f01063a9:	a0 9d a1 42 f0       	mov    0xf042a19d,%al
f01063ae:	83 c8 60             	or     $0x60,%eax
f01063b1:	a2 9d a1 42 f0       	mov    %al,0xf042a19d
f01063b6:	a0 9d a1 42 f0       	mov    0xf042a19d,%al
f01063bb:	83 c8 80             	or     $0xffffff80,%eax
f01063be:	a2 9d a1 42 f0       	mov    %al,0xf042a19d
f01063c3:	b8 5a 7e 10 f0       	mov    $0xf0107e5a,%eax
f01063c8:	c1 e8 10             	shr    $0x10,%eax
f01063cb:	66 a3 9e a1 42 f0    	mov    %ax,0xf042a19e
	SETGATE(idt[T_OFLOW ], 1, GD_KT, &ALL_FAULTS4, 3);
f01063d1:	b8 64 7e 10 f0       	mov    $0xf0107e64,%eax
f01063d6:	66 a3 a0 a1 42 f0    	mov    %ax,0xf042a1a0
f01063dc:	66 c7 05 a2 a1 42 f0 	movw   $0x8,0xf042a1a2
f01063e3:	08 00 
f01063e5:	a0 a4 a1 42 f0       	mov    0xf042a1a4,%al
f01063ea:	83 e0 e0             	and    $0xffffffe0,%eax
f01063ed:	a2 a4 a1 42 f0       	mov    %al,0xf042a1a4
f01063f2:	a0 a4 a1 42 f0       	mov    0xf042a1a4,%al
f01063f7:	83 e0 1f             	and    $0x1f,%eax
f01063fa:	a2 a4 a1 42 f0       	mov    %al,0xf042a1a4
f01063ff:	a0 a5 a1 42 f0       	mov    0xf042a1a5,%al
f0106404:	83 c8 0f             	or     $0xf,%eax
f0106407:	a2 a5 a1 42 f0       	mov    %al,0xf042a1a5
f010640c:	a0 a5 a1 42 f0       	mov    0xf042a1a5,%al
f0106411:	83 e0 ef             	and    $0xffffffef,%eax
f0106414:	a2 a5 a1 42 f0       	mov    %al,0xf042a1a5
f0106419:	a0 a5 a1 42 f0       	mov    0xf042a1a5,%al
f010641e:	83 c8 60             	or     $0x60,%eax
f0106421:	a2 a5 a1 42 f0       	mov    %al,0xf042a1a5
f0106426:	a0 a5 a1 42 f0       	mov    0xf042a1a5,%al
f010642b:	83 c8 80             	or     $0xffffff80,%eax
f010642e:	a2 a5 a1 42 f0       	mov    %al,0xf042a1a5
f0106433:	b8 64 7e 10 f0       	mov    $0xf0107e64,%eax
f0106438:	c1 e8 10             	shr    $0x10,%eax
f010643b:	66 a3 a6 a1 42 f0    	mov    %ax,0xf042a1a6
	SETGATE(idt[T_BOUND ], 0, GD_KT, &ALL_FAULTS5, 3);
f0106441:	b8 6e 7e 10 f0       	mov    $0xf0107e6e,%eax
f0106446:	66 a3 a8 a1 42 f0    	mov    %ax,0xf042a1a8
f010644c:	66 c7 05 aa a1 42 f0 	movw   $0x8,0xf042a1aa
f0106453:	08 00 
f0106455:	a0 ac a1 42 f0       	mov    0xf042a1ac,%al
f010645a:	83 e0 e0             	and    $0xffffffe0,%eax
f010645d:	a2 ac a1 42 f0       	mov    %al,0xf042a1ac
f0106462:	a0 ac a1 42 f0       	mov    0xf042a1ac,%al
f0106467:	83 e0 1f             	and    $0x1f,%eax
f010646a:	a2 ac a1 42 f0       	mov    %al,0xf042a1ac
f010646f:	a0 ad a1 42 f0       	mov    0xf042a1ad,%al
f0106474:	83 e0 f0             	and    $0xfffffff0,%eax
f0106477:	83 c8 0e             	or     $0xe,%eax
f010647a:	a2 ad a1 42 f0       	mov    %al,0xf042a1ad
f010647f:	a0 ad a1 42 f0       	mov    0xf042a1ad,%al
f0106484:	83 e0 ef             	and    $0xffffffef,%eax
f0106487:	a2 ad a1 42 f0       	mov    %al,0xf042a1ad
f010648c:	a0 ad a1 42 f0       	mov    0xf042a1ad,%al
f0106491:	83 c8 60             	or     $0x60,%eax
f0106494:	a2 ad a1 42 f0       	mov    %al,0xf042a1ad
f0106499:	a0 ad a1 42 f0       	mov    0xf042a1ad,%al
f010649e:	83 c8 80             	or     $0xffffff80,%eax
f01064a1:	a2 ad a1 42 f0       	mov    %al,0xf042a1ad
f01064a6:	b8 6e 7e 10 f0       	mov    $0xf0107e6e,%eax
f01064ab:	c1 e8 10             	shr    $0x10,%eax
f01064ae:	66 a3 ae a1 42 f0    	mov    %ax,0xf042a1ae
	SETGATE(idt[T_ILLOP ], 0, GD_KT, &ALL_FAULTS6, 3);
f01064b4:	b8 78 7e 10 f0       	mov    $0xf0107e78,%eax
f01064b9:	66 a3 b0 a1 42 f0    	mov    %ax,0xf042a1b0
f01064bf:	66 c7 05 b2 a1 42 f0 	movw   $0x8,0xf042a1b2
f01064c6:	08 00 
f01064c8:	a0 b4 a1 42 f0       	mov    0xf042a1b4,%al
f01064cd:	83 e0 e0             	and    $0xffffffe0,%eax
f01064d0:	a2 b4 a1 42 f0       	mov    %al,0xf042a1b4
f01064d5:	a0 b4 a1 42 f0       	mov    0xf042a1b4,%al
f01064da:	83 e0 1f             	and    $0x1f,%eax
f01064dd:	a2 b4 a1 42 f0       	mov    %al,0xf042a1b4
f01064e2:	a0 b5 a1 42 f0       	mov    0xf042a1b5,%al
f01064e7:	83 e0 f0             	and    $0xfffffff0,%eax
f01064ea:	83 c8 0e             	or     $0xe,%eax
f01064ed:	a2 b5 a1 42 f0       	mov    %al,0xf042a1b5
f01064f2:	a0 b5 a1 42 f0       	mov    0xf042a1b5,%al
f01064f7:	83 e0 ef             	and    $0xffffffef,%eax
f01064fa:	a2 b5 a1 42 f0       	mov    %al,0xf042a1b5
f01064ff:	a0 b5 a1 42 f0       	mov    0xf042a1b5,%al
f0106504:	83 c8 60             	or     $0x60,%eax
f0106507:	a2 b5 a1 42 f0       	mov    %al,0xf042a1b5
f010650c:	a0 b5 a1 42 f0       	mov    0xf042a1b5,%al
f0106511:	83 c8 80             	or     $0xffffff80,%eax
f0106514:	a2 b5 a1 42 f0       	mov    %al,0xf042a1b5
f0106519:	b8 78 7e 10 f0       	mov    $0xf0107e78,%eax
f010651e:	c1 e8 10             	shr    $0x10,%eax
f0106521:	66 a3 b6 a1 42 f0    	mov    %ax,0xf042a1b6
	SETGATE(idt[T_DEVICE ], 0, GD_KT, &ALL_FAULTS7, 3);
f0106527:	b8 82 7e 10 f0       	mov    $0xf0107e82,%eax
f010652c:	66 a3 b8 a1 42 f0    	mov    %ax,0xf042a1b8
f0106532:	66 c7 05 ba a1 42 f0 	movw   $0x8,0xf042a1ba
f0106539:	08 00 
f010653b:	a0 bc a1 42 f0       	mov    0xf042a1bc,%al
f0106540:	83 e0 e0             	and    $0xffffffe0,%eax
f0106543:	a2 bc a1 42 f0       	mov    %al,0xf042a1bc
f0106548:	a0 bc a1 42 f0       	mov    0xf042a1bc,%al
f010654d:	83 e0 1f             	and    $0x1f,%eax
f0106550:	a2 bc a1 42 f0       	mov    %al,0xf042a1bc
f0106555:	a0 bd a1 42 f0       	mov    0xf042a1bd,%al
f010655a:	83 e0 f0             	and    $0xfffffff0,%eax
f010655d:	83 c8 0e             	or     $0xe,%eax
f0106560:	a2 bd a1 42 f0       	mov    %al,0xf042a1bd
f0106565:	a0 bd a1 42 f0       	mov    0xf042a1bd,%al
f010656a:	83 e0 ef             	and    $0xffffffef,%eax
f010656d:	a2 bd a1 42 f0       	mov    %al,0xf042a1bd
f0106572:	a0 bd a1 42 f0       	mov    0xf042a1bd,%al
f0106577:	83 c8 60             	or     $0x60,%eax
f010657a:	a2 bd a1 42 f0       	mov    %al,0xf042a1bd
f010657f:	a0 bd a1 42 f0       	mov    0xf042a1bd,%al
f0106584:	83 c8 80             	or     $0xffffff80,%eax
f0106587:	a2 bd a1 42 f0       	mov    %al,0xf042a1bd
f010658c:	b8 82 7e 10 f0       	mov    $0xf0107e82,%eax
f0106591:	c1 e8 10             	shr    $0x10,%eax
f0106594:	66 a3 be a1 42 f0    	mov    %ax,0xf042a1be
	//SETGATE(idt[T_DBLFLT   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS ], 0, GD_KT, &ALL_FAULTS10, 3);
f010659a:	b8 8c 7e 10 f0       	mov    $0xf0107e8c,%eax
f010659f:	66 a3 d0 a1 42 f0    	mov    %ax,0xf042a1d0
f01065a5:	66 c7 05 d2 a1 42 f0 	movw   $0x8,0xf042a1d2
f01065ac:	08 00 
f01065ae:	a0 d4 a1 42 f0       	mov    0xf042a1d4,%al
f01065b3:	83 e0 e0             	and    $0xffffffe0,%eax
f01065b6:	a2 d4 a1 42 f0       	mov    %al,0xf042a1d4
f01065bb:	a0 d4 a1 42 f0       	mov    0xf042a1d4,%al
f01065c0:	83 e0 1f             	and    $0x1f,%eax
f01065c3:	a2 d4 a1 42 f0       	mov    %al,0xf042a1d4
f01065c8:	a0 d5 a1 42 f0       	mov    0xf042a1d5,%al
f01065cd:	83 e0 f0             	and    $0xfffffff0,%eax
f01065d0:	83 c8 0e             	or     $0xe,%eax
f01065d3:	a2 d5 a1 42 f0       	mov    %al,0xf042a1d5
f01065d8:	a0 d5 a1 42 f0       	mov    0xf042a1d5,%al
f01065dd:	83 e0 ef             	and    $0xffffffef,%eax
f01065e0:	a2 d5 a1 42 f0       	mov    %al,0xf042a1d5
f01065e5:	a0 d5 a1 42 f0       	mov    0xf042a1d5,%al
f01065ea:	83 c8 60             	or     $0x60,%eax
f01065ed:	a2 d5 a1 42 f0       	mov    %al,0xf042a1d5
f01065f2:	a0 d5 a1 42 f0       	mov    0xf042a1d5,%al
f01065f7:	83 c8 80             	or     $0xffffff80,%eax
f01065fa:	a2 d5 a1 42 f0       	mov    %al,0xf042a1d5
f01065ff:	b8 8c 7e 10 f0       	mov    $0xf0107e8c,%eax
f0106604:	c1 e8 10             	shr    $0x10,%eax
f0106607:	66 a3 d6 a1 42 f0    	mov    %ax,0xf042a1d6
	SETGATE(idt[T_SEGNP ], 0, GD_KT, &ALL_FAULTS11, 3);
f010660d:	b8 94 7e 10 f0       	mov    $0xf0107e94,%eax
f0106612:	66 a3 d8 a1 42 f0    	mov    %ax,0xf042a1d8
f0106618:	66 c7 05 da a1 42 f0 	movw   $0x8,0xf042a1da
f010661f:	08 00 
f0106621:	a0 dc a1 42 f0       	mov    0xf042a1dc,%al
f0106626:	83 e0 e0             	and    $0xffffffe0,%eax
f0106629:	a2 dc a1 42 f0       	mov    %al,0xf042a1dc
f010662e:	a0 dc a1 42 f0       	mov    0xf042a1dc,%al
f0106633:	83 e0 1f             	and    $0x1f,%eax
f0106636:	a2 dc a1 42 f0       	mov    %al,0xf042a1dc
f010663b:	a0 dd a1 42 f0       	mov    0xf042a1dd,%al
f0106640:	83 e0 f0             	and    $0xfffffff0,%eax
f0106643:	83 c8 0e             	or     $0xe,%eax
f0106646:	a2 dd a1 42 f0       	mov    %al,0xf042a1dd
f010664b:	a0 dd a1 42 f0       	mov    0xf042a1dd,%al
f0106650:	83 e0 ef             	and    $0xffffffef,%eax
f0106653:	a2 dd a1 42 f0       	mov    %al,0xf042a1dd
f0106658:	a0 dd a1 42 f0       	mov    0xf042a1dd,%al
f010665d:	83 c8 60             	or     $0x60,%eax
f0106660:	a2 dd a1 42 f0       	mov    %al,0xf042a1dd
f0106665:	a0 dd a1 42 f0       	mov    0xf042a1dd,%al
f010666a:	83 c8 80             	or     $0xffffff80,%eax
f010666d:	a2 dd a1 42 f0       	mov    %al,0xf042a1dd
f0106672:	b8 94 7e 10 f0       	mov    $0xf0107e94,%eax
f0106677:	c1 e8 10             	shr    $0x10,%eax
f010667a:	66 a3 de a1 42 f0    	mov    %ax,0xf042a1de
	SETGATE(idt[T_STACK ], 0, GD_KT, &ALL_FAULTS12, 3);
f0106680:	b8 98 7e 10 f0       	mov    $0xf0107e98,%eax
f0106685:	66 a3 e0 a1 42 f0    	mov    %ax,0xf042a1e0
f010668b:	66 c7 05 e2 a1 42 f0 	movw   $0x8,0xf042a1e2
f0106692:	08 00 
f0106694:	a0 e4 a1 42 f0       	mov    0xf042a1e4,%al
f0106699:	83 e0 e0             	and    $0xffffffe0,%eax
f010669c:	a2 e4 a1 42 f0       	mov    %al,0xf042a1e4
f01066a1:	a0 e4 a1 42 f0       	mov    0xf042a1e4,%al
f01066a6:	83 e0 1f             	and    $0x1f,%eax
f01066a9:	a2 e4 a1 42 f0       	mov    %al,0xf042a1e4
f01066ae:	a0 e5 a1 42 f0       	mov    0xf042a1e5,%al
f01066b3:	83 e0 f0             	and    $0xfffffff0,%eax
f01066b6:	83 c8 0e             	or     $0xe,%eax
f01066b9:	a2 e5 a1 42 f0       	mov    %al,0xf042a1e5
f01066be:	a0 e5 a1 42 f0       	mov    0xf042a1e5,%al
f01066c3:	83 e0 ef             	and    $0xffffffef,%eax
f01066c6:	a2 e5 a1 42 f0       	mov    %al,0xf042a1e5
f01066cb:	a0 e5 a1 42 f0       	mov    0xf042a1e5,%al
f01066d0:	83 c8 60             	or     $0x60,%eax
f01066d3:	a2 e5 a1 42 f0       	mov    %al,0xf042a1e5
f01066d8:	a0 e5 a1 42 f0       	mov    0xf042a1e5,%al
f01066dd:	83 c8 80             	or     $0xffffff80,%eax
f01066e0:	a2 e5 a1 42 f0       	mov    %al,0xf042a1e5
f01066e5:	b8 98 7e 10 f0       	mov    $0xf0107e98,%eax
f01066ea:	c1 e8 10             	shr    $0x10,%eax
f01066ed:	66 a3 e6 a1 42 f0    	mov    %ax,0xf042a1e6
	SETGATE(idt[T_GPFLT ], 0, GD_KT, &ALL_FAULTS13, 3);
f01066f3:	b8 9c 7e 10 f0       	mov    $0xf0107e9c,%eax
f01066f8:	66 a3 e8 a1 42 f0    	mov    %ax,0xf042a1e8
f01066fe:	66 c7 05 ea a1 42 f0 	movw   $0x8,0xf042a1ea
f0106705:	08 00 
f0106707:	a0 ec a1 42 f0       	mov    0xf042a1ec,%al
f010670c:	83 e0 e0             	and    $0xffffffe0,%eax
f010670f:	a2 ec a1 42 f0       	mov    %al,0xf042a1ec
f0106714:	a0 ec a1 42 f0       	mov    0xf042a1ec,%al
f0106719:	83 e0 1f             	and    $0x1f,%eax
f010671c:	a2 ec a1 42 f0       	mov    %al,0xf042a1ec
f0106721:	a0 ed a1 42 f0       	mov    0xf042a1ed,%al
f0106726:	83 e0 f0             	and    $0xfffffff0,%eax
f0106729:	83 c8 0e             	or     $0xe,%eax
f010672c:	a2 ed a1 42 f0       	mov    %al,0xf042a1ed
f0106731:	a0 ed a1 42 f0       	mov    0xf042a1ed,%al
f0106736:	83 e0 ef             	and    $0xffffffef,%eax
f0106739:	a2 ed a1 42 f0       	mov    %al,0xf042a1ed
f010673e:	a0 ed a1 42 f0       	mov    0xf042a1ed,%al
f0106743:	83 c8 60             	or     $0x60,%eax
f0106746:	a2 ed a1 42 f0       	mov    %al,0xf042a1ed
f010674b:	a0 ed a1 42 f0       	mov    0xf042a1ed,%al
f0106750:	83 c8 80             	or     $0xffffff80,%eax
f0106753:	a2 ed a1 42 f0       	mov    %al,0xf042a1ed
f0106758:	b8 9c 7e 10 f0       	mov    $0xf0107e9c,%eax
f010675d:	c1 e8 10             	shr    $0x10,%eax
f0106760:	66 a3 ee a1 42 f0    	mov    %ax,0xf042a1ee
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR ], 0, GD_KT, &ALL_FAULTS16, 3);
f0106766:	b8 a0 7e 10 f0       	mov    $0xf0107ea0,%eax
f010676b:	66 a3 00 a2 42 f0    	mov    %ax,0xf042a200
f0106771:	66 c7 05 02 a2 42 f0 	movw   $0x8,0xf042a202
f0106778:	08 00 
f010677a:	a0 04 a2 42 f0       	mov    0xf042a204,%al
f010677f:	83 e0 e0             	and    $0xffffffe0,%eax
f0106782:	a2 04 a2 42 f0       	mov    %al,0xf042a204
f0106787:	a0 04 a2 42 f0       	mov    0xf042a204,%al
f010678c:	83 e0 1f             	and    $0x1f,%eax
f010678f:	a2 04 a2 42 f0       	mov    %al,0xf042a204
f0106794:	a0 05 a2 42 f0       	mov    0xf042a205,%al
f0106799:	83 e0 f0             	and    $0xfffffff0,%eax
f010679c:	83 c8 0e             	or     $0xe,%eax
f010679f:	a2 05 a2 42 f0       	mov    %al,0xf042a205
f01067a4:	a0 05 a2 42 f0       	mov    0xf042a205,%al
f01067a9:	83 e0 ef             	and    $0xffffffef,%eax
f01067ac:	a2 05 a2 42 f0       	mov    %al,0xf042a205
f01067b1:	a0 05 a2 42 f0       	mov    0xf042a205,%al
f01067b6:	83 c8 60             	or     $0x60,%eax
f01067b9:	a2 05 a2 42 f0       	mov    %al,0xf042a205
f01067be:	a0 05 a2 42 f0       	mov    0xf042a205,%al
f01067c3:	83 c8 80             	or     $0xffffff80,%eax
f01067c6:	a2 05 a2 42 f0       	mov    %al,0xf042a205
f01067cb:	b8 a0 7e 10 f0       	mov    $0xf0107ea0,%eax
f01067d0:	c1 e8 10             	shr    $0x10,%eax
f01067d3:	66 a3 06 a2 42 f0    	mov    %ax,0xf042a206
	SETGATE(idt[T_ALIGN ], 0, GD_KT, &ALL_FAULTS17, 3);
f01067d9:	b8 a6 7e 10 f0       	mov    $0xf0107ea6,%eax
f01067de:	66 a3 08 a2 42 f0    	mov    %ax,0xf042a208
f01067e4:	66 c7 05 0a a2 42 f0 	movw   $0x8,0xf042a20a
f01067eb:	08 00 
f01067ed:	a0 0c a2 42 f0       	mov    0xf042a20c,%al
f01067f2:	83 e0 e0             	and    $0xffffffe0,%eax
f01067f5:	a2 0c a2 42 f0       	mov    %al,0xf042a20c
f01067fa:	a0 0c a2 42 f0       	mov    0xf042a20c,%al
f01067ff:	83 e0 1f             	and    $0x1f,%eax
f0106802:	a2 0c a2 42 f0       	mov    %al,0xf042a20c
f0106807:	a0 0d a2 42 f0       	mov    0xf042a20d,%al
f010680c:	83 e0 f0             	and    $0xfffffff0,%eax
f010680f:	83 c8 0e             	or     $0xe,%eax
f0106812:	a2 0d a2 42 f0       	mov    %al,0xf042a20d
f0106817:	a0 0d a2 42 f0       	mov    0xf042a20d,%al
f010681c:	83 e0 ef             	and    $0xffffffef,%eax
f010681f:	a2 0d a2 42 f0       	mov    %al,0xf042a20d
f0106824:	a0 0d a2 42 f0       	mov    0xf042a20d,%al
f0106829:	83 c8 60             	or     $0x60,%eax
f010682c:	a2 0d a2 42 f0       	mov    %al,0xf042a20d
f0106831:	a0 0d a2 42 f0       	mov    0xf042a20d,%al
f0106836:	83 c8 80             	or     $0xffffff80,%eax
f0106839:	a2 0d a2 42 f0       	mov    %al,0xf042a20d
f010683e:	b8 a6 7e 10 f0       	mov    $0xf0107ea6,%eax
f0106843:	c1 e8 10             	shr    $0x10,%eax
f0106846:	66 a3 0e a2 42 f0    	mov    %ax,0xf042a20e
	SETGATE(idt[T_MCHK ], 0, GD_KT, &ALL_FAULTS18, 3);
f010684c:	b8 aa 7e 10 f0       	mov    $0xf0107eaa,%eax
f0106851:	66 a3 10 a2 42 f0    	mov    %ax,0xf042a210
f0106857:	66 c7 05 12 a2 42 f0 	movw   $0x8,0xf042a212
f010685e:	08 00 
f0106860:	a0 14 a2 42 f0       	mov    0xf042a214,%al
f0106865:	83 e0 e0             	and    $0xffffffe0,%eax
f0106868:	a2 14 a2 42 f0       	mov    %al,0xf042a214
f010686d:	a0 14 a2 42 f0       	mov    0xf042a214,%al
f0106872:	83 e0 1f             	and    $0x1f,%eax
f0106875:	a2 14 a2 42 f0       	mov    %al,0xf042a214
f010687a:	a0 15 a2 42 f0       	mov    0xf042a215,%al
f010687f:	83 e0 f0             	and    $0xfffffff0,%eax
f0106882:	83 c8 0e             	or     $0xe,%eax
f0106885:	a2 15 a2 42 f0       	mov    %al,0xf042a215
f010688a:	a0 15 a2 42 f0       	mov    0xf042a215,%al
f010688f:	83 e0 ef             	and    $0xffffffef,%eax
f0106892:	a2 15 a2 42 f0       	mov    %al,0xf042a215
f0106897:	a0 15 a2 42 f0       	mov    0xf042a215,%al
f010689c:	83 c8 60             	or     $0x60,%eax
f010689f:	a2 15 a2 42 f0       	mov    %al,0xf042a215
f01068a4:	a0 15 a2 42 f0       	mov    0xf042a215,%al
f01068a9:	83 c8 80             	or     $0xffffff80,%eax
f01068ac:	a2 15 a2 42 f0       	mov    %al,0xf042a215
f01068b1:	b8 aa 7e 10 f0       	mov    $0xf0107eaa,%eax
f01068b6:	c1 e8 10             	shr    $0x10,%eax
f01068b9:	66 a3 16 a2 42 f0    	mov    %ax,0xf042a216
	SETGATE(idt[T_SIMDERR ], 0, GD_KT, &ALL_FAULTS19, 3);
f01068bf:	b8 b0 7e 10 f0       	mov    $0xf0107eb0,%eax
f01068c4:	66 a3 18 a2 42 f0    	mov    %ax,0xf042a218
f01068ca:	66 c7 05 1a a2 42 f0 	movw   $0x8,0xf042a21a
f01068d1:	08 00 
f01068d3:	a0 1c a2 42 f0       	mov    0xf042a21c,%al
f01068d8:	83 e0 e0             	and    $0xffffffe0,%eax
f01068db:	a2 1c a2 42 f0       	mov    %al,0xf042a21c
f01068e0:	a0 1c a2 42 f0       	mov    0xf042a21c,%al
f01068e5:	83 e0 1f             	and    $0x1f,%eax
f01068e8:	a2 1c a2 42 f0       	mov    %al,0xf042a21c
f01068ed:	a0 1d a2 42 f0       	mov    0xf042a21d,%al
f01068f2:	83 e0 f0             	and    $0xfffffff0,%eax
f01068f5:	83 c8 0e             	or     $0xe,%eax
f01068f8:	a2 1d a2 42 f0       	mov    %al,0xf042a21d
f01068fd:	a0 1d a2 42 f0       	mov    0xf042a21d,%al
f0106902:	83 e0 ef             	and    $0xffffffef,%eax
f0106905:	a2 1d a2 42 f0       	mov    %al,0xf042a21d
f010690a:	a0 1d a2 42 f0       	mov    0xf042a21d,%al
f010690f:	83 c8 60             	or     $0x60,%eax
f0106912:	a2 1d a2 42 f0       	mov    %al,0xf042a21d
f0106917:	a0 1d a2 42 f0       	mov    0xf042a21d,%al
f010691c:	83 c8 80             	or     $0xffffff80,%eax
f010691f:	a2 1d a2 42 f0       	mov    %al,0xf042a21d
f0106924:	b8 b0 7e 10 f0       	mov    $0xf0107eb0,%eax
f0106929:	c1 e8 10             	shr    $0x10,%eax
f010692c:	66 a3 1e a2 42 f0    	mov    %ax,0xf042a21e

	SETGATE(idt[IRQ0_Clock], 0, GD_KT, &ALL_FAULTS32, 3);
f0106932:	b8 b6 7e 10 f0       	mov    $0xf0107eb6,%eax
f0106937:	66 a3 80 a2 42 f0    	mov    %ax,0xf042a280
f010693d:	66 c7 05 82 a2 42 f0 	movw   $0x8,0xf042a282
f0106944:	08 00 
f0106946:	a0 84 a2 42 f0       	mov    0xf042a284,%al
f010694b:	83 e0 e0             	and    $0xffffffe0,%eax
f010694e:	a2 84 a2 42 f0       	mov    %al,0xf042a284
f0106953:	a0 84 a2 42 f0       	mov    0xf042a284,%al
f0106958:	83 e0 1f             	and    $0x1f,%eax
f010695b:	a2 84 a2 42 f0       	mov    %al,0xf042a284
f0106960:	a0 85 a2 42 f0       	mov    0xf042a285,%al
f0106965:	83 e0 f0             	and    $0xfffffff0,%eax
f0106968:	83 c8 0e             	or     $0xe,%eax
f010696b:	a2 85 a2 42 f0       	mov    %al,0xf042a285
f0106970:	a0 85 a2 42 f0       	mov    0xf042a285,%al
f0106975:	83 e0 ef             	and    $0xffffffef,%eax
f0106978:	a2 85 a2 42 f0       	mov    %al,0xf042a285
f010697d:	a0 85 a2 42 f0       	mov    0xf042a285,%al
f0106982:	83 c8 60             	or     $0x60,%eax
f0106985:	a2 85 a2 42 f0       	mov    %al,0xf042a285
f010698a:	a0 85 a2 42 f0       	mov    0xf042a285,%al
f010698f:	83 c8 80             	or     $0xffffff80,%eax
f0106992:	a2 85 a2 42 f0       	mov    %al,0xf042a285
f0106997:	b8 b6 7e 10 f0       	mov    $0xf0107eb6,%eax
f010699c:	c1 e8 10             	shr    $0x10,%eax
f010699f:	66 a3 86 a2 42 f0    	mov    %ax,0xf042a286
	SETGATE(idt[33], 0, GD_KT, &ALL_FAULTS33, 3);
f01069a5:	b8 bc 7e 10 f0       	mov    $0xf0107ebc,%eax
f01069aa:	66 a3 88 a2 42 f0    	mov    %ax,0xf042a288
f01069b0:	66 c7 05 8a a2 42 f0 	movw   $0x8,0xf042a28a
f01069b7:	08 00 
f01069b9:	a0 8c a2 42 f0       	mov    0xf042a28c,%al
f01069be:	83 e0 e0             	and    $0xffffffe0,%eax
f01069c1:	a2 8c a2 42 f0       	mov    %al,0xf042a28c
f01069c6:	a0 8c a2 42 f0       	mov    0xf042a28c,%al
f01069cb:	83 e0 1f             	and    $0x1f,%eax
f01069ce:	a2 8c a2 42 f0       	mov    %al,0xf042a28c
f01069d3:	a0 8d a2 42 f0       	mov    0xf042a28d,%al
f01069d8:	83 e0 f0             	and    $0xfffffff0,%eax
f01069db:	83 c8 0e             	or     $0xe,%eax
f01069de:	a2 8d a2 42 f0       	mov    %al,0xf042a28d
f01069e3:	a0 8d a2 42 f0       	mov    0xf042a28d,%al
f01069e8:	83 e0 ef             	and    $0xffffffef,%eax
f01069eb:	a2 8d a2 42 f0       	mov    %al,0xf042a28d
f01069f0:	a0 8d a2 42 f0       	mov    0xf042a28d,%al
f01069f5:	83 c8 60             	or     $0x60,%eax
f01069f8:	a2 8d a2 42 f0       	mov    %al,0xf042a28d
f01069fd:	a0 8d a2 42 f0       	mov    0xf042a28d,%al
f0106a02:	83 c8 80             	or     $0xffffff80,%eax
f0106a05:	a2 8d a2 42 f0       	mov    %al,0xf042a28d
f0106a0a:	b8 bc 7e 10 f0       	mov    $0xf0107ebc,%eax
f0106a0f:	c1 e8 10             	shr    $0x10,%eax
f0106a12:	66 a3 8e a2 42 f0    	mov    %ax,0xf042a28e
	SETGATE(idt[34], 0, GD_KT, &ALL_FAULTS34, 3);
f0106a18:	b8 c2 7e 10 f0       	mov    $0xf0107ec2,%eax
f0106a1d:	66 a3 90 a2 42 f0    	mov    %ax,0xf042a290
f0106a23:	66 c7 05 92 a2 42 f0 	movw   $0x8,0xf042a292
f0106a2a:	08 00 
f0106a2c:	a0 94 a2 42 f0       	mov    0xf042a294,%al
f0106a31:	83 e0 e0             	and    $0xffffffe0,%eax
f0106a34:	a2 94 a2 42 f0       	mov    %al,0xf042a294
f0106a39:	a0 94 a2 42 f0       	mov    0xf042a294,%al
f0106a3e:	83 e0 1f             	and    $0x1f,%eax
f0106a41:	a2 94 a2 42 f0       	mov    %al,0xf042a294
f0106a46:	a0 95 a2 42 f0       	mov    0xf042a295,%al
f0106a4b:	83 e0 f0             	and    $0xfffffff0,%eax
f0106a4e:	83 c8 0e             	or     $0xe,%eax
f0106a51:	a2 95 a2 42 f0       	mov    %al,0xf042a295
f0106a56:	a0 95 a2 42 f0       	mov    0xf042a295,%al
f0106a5b:	83 e0 ef             	and    $0xffffffef,%eax
f0106a5e:	a2 95 a2 42 f0       	mov    %al,0xf042a295
f0106a63:	a0 95 a2 42 f0       	mov    0xf042a295,%al
f0106a68:	83 c8 60             	or     $0x60,%eax
f0106a6b:	a2 95 a2 42 f0       	mov    %al,0xf042a295
f0106a70:	a0 95 a2 42 f0       	mov    0xf042a295,%al
f0106a75:	83 c8 80             	or     $0xffffff80,%eax
f0106a78:	a2 95 a2 42 f0       	mov    %al,0xf042a295
f0106a7d:	b8 c2 7e 10 f0       	mov    $0xf0107ec2,%eax
f0106a82:	c1 e8 10             	shr    $0x10,%eax
f0106a85:	66 a3 96 a2 42 f0    	mov    %ax,0xf042a296
	SETGATE(idt[35], 0, GD_KT, &ALL_FAULTS35, 3);
f0106a8b:	b8 c8 7e 10 f0       	mov    $0xf0107ec8,%eax
f0106a90:	66 a3 98 a2 42 f0    	mov    %ax,0xf042a298
f0106a96:	66 c7 05 9a a2 42 f0 	movw   $0x8,0xf042a29a
f0106a9d:	08 00 
f0106a9f:	a0 9c a2 42 f0       	mov    0xf042a29c,%al
f0106aa4:	83 e0 e0             	and    $0xffffffe0,%eax
f0106aa7:	a2 9c a2 42 f0       	mov    %al,0xf042a29c
f0106aac:	a0 9c a2 42 f0       	mov    0xf042a29c,%al
f0106ab1:	83 e0 1f             	and    $0x1f,%eax
f0106ab4:	a2 9c a2 42 f0       	mov    %al,0xf042a29c
f0106ab9:	a0 9d a2 42 f0       	mov    0xf042a29d,%al
f0106abe:	83 e0 f0             	and    $0xfffffff0,%eax
f0106ac1:	83 c8 0e             	or     $0xe,%eax
f0106ac4:	a2 9d a2 42 f0       	mov    %al,0xf042a29d
f0106ac9:	a0 9d a2 42 f0       	mov    0xf042a29d,%al
f0106ace:	83 e0 ef             	and    $0xffffffef,%eax
f0106ad1:	a2 9d a2 42 f0       	mov    %al,0xf042a29d
f0106ad6:	a0 9d a2 42 f0       	mov    0xf042a29d,%al
f0106adb:	83 c8 60             	or     $0x60,%eax
f0106ade:	a2 9d a2 42 f0       	mov    %al,0xf042a29d
f0106ae3:	a0 9d a2 42 f0       	mov    0xf042a29d,%al
f0106ae8:	83 c8 80             	or     $0xffffff80,%eax
f0106aeb:	a2 9d a2 42 f0       	mov    %al,0xf042a29d
f0106af0:	b8 c8 7e 10 f0       	mov    $0xf0107ec8,%eax
f0106af5:	c1 e8 10             	shr    $0x10,%eax
f0106af8:	66 a3 9e a2 42 f0    	mov    %ax,0xf042a29e
	SETGATE(idt[36], 0, GD_KT, &ALL_FAULTS36, 3);
f0106afe:	b8 ce 7e 10 f0       	mov    $0xf0107ece,%eax
f0106b03:	66 a3 a0 a2 42 f0    	mov    %ax,0xf042a2a0
f0106b09:	66 c7 05 a2 a2 42 f0 	movw   $0x8,0xf042a2a2
f0106b10:	08 00 
f0106b12:	a0 a4 a2 42 f0       	mov    0xf042a2a4,%al
f0106b17:	83 e0 e0             	and    $0xffffffe0,%eax
f0106b1a:	a2 a4 a2 42 f0       	mov    %al,0xf042a2a4
f0106b1f:	a0 a4 a2 42 f0       	mov    0xf042a2a4,%al
f0106b24:	83 e0 1f             	and    $0x1f,%eax
f0106b27:	a2 a4 a2 42 f0       	mov    %al,0xf042a2a4
f0106b2c:	a0 a5 a2 42 f0       	mov    0xf042a2a5,%al
f0106b31:	83 e0 f0             	and    $0xfffffff0,%eax
f0106b34:	83 c8 0e             	or     $0xe,%eax
f0106b37:	a2 a5 a2 42 f0       	mov    %al,0xf042a2a5
f0106b3c:	a0 a5 a2 42 f0       	mov    0xf042a2a5,%al
f0106b41:	83 e0 ef             	and    $0xffffffef,%eax
f0106b44:	a2 a5 a2 42 f0       	mov    %al,0xf042a2a5
f0106b49:	a0 a5 a2 42 f0       	mov    0xf042a2a5,%al
f0106b4e:	83 c8 60             	or     $0x60,%eax
f0106b51:	a2 a5 a2 42 f0       	mov    %al,0xf042a2a5
f0106b56:	a0 a5 a2 42 f0       	mov    0xf042a2a5,%al
f0106b5b:	83 c8 80             	or     $0xffffff80,%eax
f0106b5e:	a2 a5 a2 42 f0       	mov    %al,0xf042a2a5
f0106b63:	b8 ce 7e 10 f0       	mov    $0xf0107ece,%eax
f0106b68:	c1 e8 10             	shr    $0x10,%eax
f0106b6b:	66 a3 a6 a2 42 f0    	mov    %ax,0xf042a2a6
	SETGATE(idt[37], 0, GD_KT, &ALL_FAULTS37, 3);
f0106b71:	b8 d4 7e 10 f0       	mov    $0xf0107ed4,%eax
f0106b76:	66 a3 a8 a2 42 f0    	mov    %ax,0xf042a2a8
f0106b7c:	66 c7 05 aa a2 42 f0 	movw   $0x8,0xf042a2aa
f0106b83:	08 00 
f0106b85:	a0 ac a2 42 f0       	mov    0xf042a2ac,%al
f0106b8a:	83 e0 e0             	and    $0xffffffe0,%eax
f0106b8d:	a2 ac a2 42 f0       	mov    %al,0xf042a2ac
f0106b92:	a0 ac a2 42 f0       	mov    0xf042a2ac,%al
f0106b97:	83 e0 1f             	and    $0x1f,%eax
f0106b9a:	a2 ac a2 42 f0       	mov    %al,0xf042a2ac
f0106b9f:	a0 ad a2 42 f0       	mov    0xf042a2ad,%al
f0106ba4:	83 e0 f0             	and    $0xfffffff0,%eax
f0106ba7:	83 c8 0e             	or     $0xe,%eax
f0106baa:	a2 ad a2 42 f0       	mov    %al,0xf042a2ad
f0106baf:	a0 ad a2 42 f0       	mov    0xf042a2ad,%al
f0106bb4:	83 e0 ef             	and    $0xffffffef,%eax
f0106bb7:	a2 ad a2 42 f0       	mov    %al,0xf042a2ad
f0106bbc:	a0 ad a2 42 f0       	mov    0xf042a2ad,%al
f0106bc1:	83 c8 60             	or     $0x60,%eax
f0106bc4:	a2 ad a2 42 f0       	mov    %al,0xf042a2ad
f0106bc9:	a0 ad a2 42 f0       	mov    0xf042a2ad,%al
f0106bce:	83 c8 80             	or     $0xffffff80,%eax
f0106bd1:	a2 ad a2 42 f0       	mov    %al,0xf042a2ad
f0106bd6:	b8 d4 7e 10 f0       	mov    $0xf0107ed4,%eax
f0106bdb:	c1 e8 10             	shr    $0x10,%eax
f0106bde:	66 a3 ae a2 42 f0    	mov    %ax,0xf042a2ae
	SETGATE(idt[38], 0, GD_KT, &ALL_FAULTS38, 3);
f0106be4:	b8 da 7e 10 f0       	mov    $0xf0107eda,%eax
f0106be9:	66 a3 b0 a2 42 f0    	mov    %ax,0xf042a2b0
f0106bef:	66 c7 05 b2 a2 42 f0 	movw   $0x8,0xf042a2b2
f0106bf6:	08 00 
f0106bf8:	a0 b4 a2 42 f0       	mov    0xf042a2b4,%al
f0106bfd:	83 e0 e0             	and    $0xffffffe0,%eax
f0106c00:	a2 b4 a2 42 f0       	mov    %al,0xf042a2b4
f0106c05:	a0 b4 a2 42 f0       	mov    0xf042a2b4,%al
f0106c0a:	83 e0 1f             	and    $0x1f,%eax
f0106c0d:	a2 b4 a2 42 f0       	mov    %al,0xf042a2b4
f0106c12:	a0 b5 a2 42 f0       	mov    0xf042a2b5,%al
f0106c17:	83 e0 f0             	and    $0xfffffff0,%eax
f0106c1a:	83 c8 0e             	or     $0xe,%eax
f0106c1d:	a2 b5 a2 42 f0       	mov    %al,0xf042a2b5
f0106c22:	a0 b5 a2 42 f0       	mov    0xf042a2b5,%al
f0106c27:	83 e0 ef             	and    $0xffffffef,%eax
f0106c2a:	a2 b5 a2 42 f0       	mov    %al,0xf042a2b5
f0106c2f:	a0 b5 a2 42 f0       	mov    0xf042a2b5,%al
f0106c34:	83 c8 60             	or     $0x60,%eax
f0106c37:	a2 b5 a2 42 f0       	mov    %al,0xf042a2b5
f0106c3c:	a0 b5 a2 42 f0       	mov    0xf042a2b5,%al
f0106c41:	83 c8 80             	or     $0xffffff80,%eax
f0106c44:	a2 b5 a2 42 f0       	mov    %al,0xf042a2b5
f0106c49:	b8 da 7e 10 f0       	mov    $0xf0107eda,%eax
f0106c4e:	c1 e8 10             	shr    $0x10,%eax
f0106c51:	66 a3 b6 a2 42 f0    	mov    %ax,0xf042a2b6
	SETGATE(idt[39], 0, GD_KT, &ALL_FAULTS39, 3);
f0106c57:	b8 e0 7e 10 f0       	mov    $0xf0107ee0,%eax
f0106c5c:	66 a3 b8 a2 42 f0    	mov    %ax,0xf042a2b8
f0106c62:	66 c7 05 ba a2 42 f0 	movw   $0x8,0xf042a2ba
f0106c69:	08 00 
f0106c6b:	a0 bc a2 42 f0       	mov    0xf042a2bc,%al
f0106c70:	83 e0 e0             	and    $0xffffffe0,%eax
f0106c73:	a2 bc a2 42 f0       	mov    %al,0xf042a2bc
f0106c78:	a0 bc a2 42 f0       	mov    0xf042a2bc,%al
f0106c7d:	83 e0 1f             	and    $0x1f,%eax
f0106c80:	a2 bc a2 42 f0       	mov    %al,0xf042a2bc
f0106c85:	a0 bd a2 42 f0       	mov    0xf042a2bd,%al
f0106c8a:	83 e0 f0             	and    $0xfffffff0,%eax
f0106c8d:	83 c8 0e             	or     $0xe,%eax
f0106c90:	a2 bd a2 42 f0       	mov    %al,0xf042a2bd
f0106c95:	a0 bd a2 42 f0       	mov    0xf042a2bd,%al
f0106c9a:	83 e0 ef             	and    $0xffffffef,%eax
f0106c9d:	a2 bd a2 42 f0       	mov    %al,0xf042a2bd
f0106ca2:	a0 bd a2 42 f0       	mov    0xf042a2bd,%al
f0106ca7:	83 c8 60             	or     $0x60,%eax
f0106caa:	a2 bd a2 42 f0       	mov    %al,0xf042a2bd
f0106caf:	a0 bd a2 42 f0       	mov    0xf042a2bd,%al
f0106cb4:	83 c8 80             	or     $0xffffff80,%eax
f0106cb7:	a2 bd a2 42 f0       	mov    %al,0xf042a2bd
f0106cbc:	b8 e0 7e 10 f0       	mov    $0xf0107ee0,%eax
f0106cc1:	c1 e8 10             	shr    $0x10,%eax
f0106cc4:	66 a3 be a2 42 f0    	mov    %ax,0xf042a2be
	SETGATE(idt[40], 0, GD_KT, &ALL_FAULTS40, 3);
f0106cca:	b8 e6 7e 10 f0       	mov    $0xf0107ee6,%eax
f0106ccf:	66 a3 c0 a2 42 f0    	mov    %ax,0xf042a2c0
f0106cd5:	66 c7 05 c2 a2 42 f0 	movw   $0x8,0xf042a2c2
f0106cdc:	08 00 
f0106cde:	a0 c4 a2 42 f0       	mov    0xf042a2c4,%al
f0106ce3:	83 e0 e0             	and    $0xffffffe0,%eax
f0106ce6:	a2 c4 a2 42 f0       	mov    %al,0xf042a2c4
f0106ceb:	a0 c4 a2 42 f0       	mov    0xf042a2c4,%al
f0106cf0:	83 e0 1f             	and    $0x1f,%eax
f0106cf3:	a2 c4 a2 42 f0       	mov    %al,0xf042a2c4
f0106cf8:	a0 c5 a2 42 f0       	mov    0xf042a2c5,%al
f0106cfd:	83 e0 f0             	and    $0xfffffff0,%eax
f0106d00:	83 c8 0e             	or     $0xe,%eax
f0106d03:	a2 c5 a2 42 f0       	mov    %al,0xf042a2c5
f0106d08:	a0 c5 a2 42 f0       	mov    0xf042a2c5,%al
f0106d0d:	83 e0 ef             	and    $0xffffffef,%eax
f0106d10:	a2 c5 a2 42 f0       	mov    %al,0xf042a2c5
f0106d15:	a0 c5 a2 42 f0       	mov    0xf042a2c5,%al
f0106d1a:	83 c8 60             	or     $0x60,%eax
f0106d1d:	a2 c5 a2 42 f0       	mov    %al,0xf042a2c5
f0106d22:	a0 c5 a2 42 f0       	mov    0xf042a2c5,%al
f0106d27:	83 c8 80             	or     $0xffffff80,%eax
f0106d2a:	a2 c5 a2 42 f0       	mov    %al,0xf042a2c5
f0106d2f:	b8 e6 7e 10 f0       	mov    $0xf0107ee6,%eax
f0106d34:	c1 e8 10             	shr    $0x10,%eax
f0106d37:	66 a3 c6 a2 42 f0    	mov    %ax,0xf042a2c6
	SETGATE(idt[41], 0, GD_KT, &ALL_FAULTS41, 3);
f0106d3d:	b8 ec 7e 10 f0       	mov    $0xf0107eec,%eax
f0106d42:	66 a3 c8 a2 42 f0    	mov    %ax,0xf042a2c8
f0106d48:	66 c7 05 ca a2 42 f0 	movw   $0x8,0xf042a2ca
f0106d4f:	08 00 
f0106d51:	a0 cc a2 42 f0       	mov    0xf042a2cc,%al
f0106d56:	83 e0 e0             	and    $0xffffffe0,%eax
f0106d59:	a2 cc a2 42 f0       	mov    %al,0xf042a2cc
f0106d5e:	a0 cc a2 42 f0       	mov    0xf042a2cc,%al
f0106d63:	83 e0 1f             	and    $0x1f,%eax
f0106d66:	a2 cc a2 42 f0       	mov    %al,0xf042a2cc
f0106d6b:	a0 cd a2 42 f0       	mov    0xf042a2cd,%al
f0106d70:	83 e0 f0             	and    $0xfffffff0,%eax
f0106d73:	83 c8 0e             	or     $0xe,%eax
f0106d76:	a2 cd a2 42 f0       	mov    %al,0xf042a2cd
f0106d7b:	a0 cd a2 42 f0       	mov    0xf042a2cd,%al
f0106d80:	83 e0 ef             	and    $0xffffffef,%eax
f0106d83:	a2 cd a2 42 f0       	mov    %al,0xf042a2cd
f0106d88:	a0 cd a2 42 f0       	mov    0xf042a2cd,%al
f0106d8d:	83 c8 60             	or     $0x60,%eax
f0106d90:	a2 cd a2 42 f0       	mov    %al,0xf042a2cd
f0106d95:	a0 cd a2 42 f0       	mov    0xf042a2cd,%al
f0106d9a:	83 c8 80             	or     $0xffffff80,%eax
f0106d9d:	a2 cd a2 42 f0       	mov    %al,0xf042a2cd
f0106da2:	b8 ec 7e 10 f0       	mov    $0xf0107eec,%eax
f0106da7:	c1 e8 10             	shr    $0x10,%eax
f0106daa:	66 a3 ce a2 42 f0    	mov    %ax,0xf042a2ce
	SETGATE(idt[42], 0, GD_KT, &ALL_FAULTS42, 3);
f0106db0:	b8 f2 7e 10 f0       	mov    $0xf0107ef2,%eax
f0106db5:	66 a3 d0 a2 42 f0    	mov    %ax,0xf042a2d0
f0106dbb:	66 c7 05 d2 a2 42 f0 	movw   $0x8,0xf042a2d2
f0106dc2:	08 00 
f0106dc4:	a0 d4 a2 42 f0       	mov    0xf042a2d4,%al
f0106dc9:	83 e0 e0             	and    $0xffffffe0,%eax
f0106dcc:	a2 d4 a2 42 f0       	mov    %al,0xf042a2d4
f0106dd1:	a0 d4 a2 42 f0       	mov    0xf042a2d4,%al
f0106dd6:	83 e0 1f             	and    $0x1f,%eax
f0106dd9:	a2 d4 a2 42 f0       	mov    %al,0xf042a2d4
f0106dde:	a0 d5 a2 42 f0       	mov    0xf042a2d5,%al
f0106de3:	83 e0 f0             	and    $0xfffffff0,%eax
f0106de6:	83 c8 0e             	or     $0xe,%eax
f0106de9:	a2 d5 a2 42 f0       	mov    %al,0xf042a2d5
f0106dee:	a0 d5 a2 42 f0       	mov    0xf042a2d5,%al
f0106df3:	83 e0 ef             	and    $0xffffffef,%eax
f0106df6:	a2 d5 a2 42 f0       	mov    %al,0xf042a2d5
f0106dfb:	a0 d5 a2 42 f0       	mov    0xf042a2d5,%al
f0106e00:	83 c8 60             	or     $0x60,%eax
f0106e03:	a2 d5 a2 42 f0       	mov    %al,0xf042a2d5
f0106e08:	a0 d5 a2 42 f0       	mov    0xf042a2d5,%al
f0106e0d:	83 c8 80             	or     $0xffffff80,%eax
f0106e10:	a2 d5 a2 42 f0       	mov    %al,0xf042a2d5
f0106e15:	b8 f2 7e 10 f0       	mov    $0xf0107ef2,%eax
f0106e1a:	c1 e8 10             	shr    $0x10,%eax
f0106e1d:	66 a3 d6 a2 42 f0    	mov    %ax,0xf042a2d6
	SETGATE(idt[43], 0, GD_KT, &ALL_FAULTS43, 3);
f0106e23:	b8 f8 7e 10 f0       	mov    $0xf0107ef8,%eax
f0106e28:	66 a3 d8 a2 42 f0    	mov    %ax,0xf042a2d8
f0106e2e:	66 c7 05 da a2 42 f0 	movw   $0x8,0xf042a2da
f0106e35:	08 00 
f0106e37:	a0 dc a2 42 f0       	mov    0xf042a2dc,%al
f0106e3c:	83 e0 e0             	and    $0xffffffe0,%eax
f0106e3f:	a2 dc a2 42 f0       	mov    %al,0xf042a2dc
f0106e44:	a0 dc a2 42 f0       	mov    0xf042a2dc,%al
f0106e49:	83 e0 1f             	and    $0x1f,%eax
f0106e4c:	a2 dc a2 42 f0       	mov    %al,0xf042a2dc
f0106e51:	a0 dd a2 42 f0       	mov    0xf042a2dd,%al
f0106e56:	83 e0 f0             	and    $0xfffffff0,%eax
f0106e59:	83 c8 0e             	or     $0xe,%eax
f0106e5c:	a2 dd a2 42 f0       	mov    %al,0xf042a2dd
f0106e61:	a0 dd a2 42 f0       	mov    0xf042a2dd,%al
f0106e66:	83 e0 ef             	and    $0xffffffef,%eax
f0106e69:	a2 dd a2 42 f0       	mov    %al,0xf042a2dd
f0106e6e:	a0 dd a2 42 f0       	mov    0xf042a2dd,%al
f0106e73:	83 c8 60             	or     $0x60,%eax
f0106e76:	a2 dd a2 42 f0       	mov    %al,0xf042a2dd
f0106e7b:	a0 dd a2 42 f0       	mov    0xf042a2dd,%al
f0106e80:	83 c8 80             	or     $0xffffff80,%eax
f0106e83:	a2 dd a2 42 f0       	mov    %al,0xf042a2dd
f0106e88:	b8 f8 7e 10 f0       	mov    $0xf0107ef8,%eax
f0106e8d:	c1 e8 10             	shr    $0x10,%eax
f0106e90:	66 a3 de a2 42 f0    	mov    %ax,0xf042a2de
	SETGATE(idt[44], 0, GD_KT, &ALL_FAULTS44, 3);
f0106e96:	b8 fe 7e 10 f0       	mov    $0xf0107efe,%eax
f0106e9b:	66 a3 e0 a2 42 f0    	mov    %ax,0xf042a2e0
f0106ea1:	66 c7 05 e2 a2 42 f0 	movw   $0x8,0xf042a2e2
f0106ea8:	08 00 
f0106eaa:	a0 e4 a2 42 f0       	mov    0xf042a2e4,%al
f0106eaf:	83 e0 e0             	and    $0xffffffe0,%eax
f0106eb2:	a2 e4 a2 42 f0       	mov    %al,0xf042a2e4
f0106eb7:	a0 e4 a2 42 f0       	mov    0xf042a2e4,%al
f0106ebc:	83 e0 1f             	and    $0x1f,%eax
f0106ebf:	a2 e4 a2 42 f0       	mov    %al,0xf042a2e4
f0106ec4:	a0 e5 a2 42 f0       	mov    0xf042a2e5,%al
f0106ec9:	83 e0 f0             	and    $0xfffffff0,%eax
f0106ecc:	83 c8 0e             	or     $0xe,%eax
f0106ecf:	a2 e5 a2 42 f0       	mov    %al,0xf042a2e5
f0106ed4:	a0 e5 a2 42 f0       	mov    0xf042a2e5,%al
f0106ed9:	83 e0 ef             	and    $0xffffffef,%eax
f0106edc:	a2 e5 a2 42 f0       	mov    %al,0xf042a2e5
f0106ee1:	a0 e5 a2 42 f0       	mov    0xf042a2e5,%al
f0106ee6:	83 c8 60             	or     $0x60,%eax
f0106ee9:	a2 e5 a2 42 f0       	mov    %al,0xf042a2e5
f0106eee:	a0 e5 a2 42 f0       	mov    0xf042a2e5,%al
f0106ef3:	83 c8 80             	or     $0xffffff80,%eax
f0106ef6:	a2 e5 a2 42 f0       	mov    %al,0xf042a2e5
f0106efb:	b8 fe 7e 10 f0       	mov    $0xf0107efe,%eax
f0106f00:	c1 e8 10             	shr    $0x10,%eax
f0106f03:	66 a3 e6 a2 42 f0    	mov    %ax,0xf042a2e6
	SETGATE(idt[45], 0, GD_KT, &ALL_FAULTS45, 3);
f0106f09:	b8 04 7f 10 f0       	mov    $0xf0107f04,%eax
f0106f0e:	66 a3 e8 a2 42 f0    	mov    %ax,0xf042a2e8
f0106f14:	66 c7 05 ea a2 42 f0 	movw   $0x8,0xf042a2ea
f0106f1b:	08 00 
f0106f1d:	a0 ec a2 42 f0       	mov    0xf042a2ec,%al
f0106f22:	83 e0 e0             	and    $0xffffffe0,%eax
f0106f25:	a2 ec a2 42 f0       	mov    %al,0xf042a2ec
f0106f2a:	a0 ec a2 42 f0       	mov    0xf042a2ec,%al
f0106f2f:	83 e0 1f             	and    $0x1f,%eax
f0106f32:	a2 ec a2 42 f0       	mov    %al,0xf042a2ec
f0106f37:	a0 ed a2 42 f0       	mov    0xf042a2ed,%al
f0106f3c:	83 e0 f0             	and    $0xfffffff0,%eax
f0106f3f:	83 c8 0e             	or     $0xe,%eax
f0106f42:	a2 ed a2 42 f0       	mov    %al,0xf042a2ed
f0106f47:	a0 ed a2 42 f0       	mov    0xf042a2ed,%al
f0106f4c:	83 e0 ef             	and    $0xffffffef,%eax
f0106f4f:	a2 ed a2 42 f0       	mov    %al,0xf042a2ed
f0106f54:	a0 ed a2 42 f0       	mov    0xf042a2ed,%al
f0106f59:	83 c8 60             	or     $0x60,%eax
f0106f5c:	a2 ed a2 42 f0       	mov    %al,0xf042a2ed
f0106f61:	a0 ed a2 42 f0       	mov    0xf042a2ed,%al
f0106f66:	83 c8 80             	or     $0xffffff80,%eax
f0106f69:	a2 ed a2 42 f0       	mov    %al,0xf042a2ed
f0106f6e:	b8 04 7f 10 f0       	mov    $0xf0107f04,%eax
f0106f73:	c1 e8 10             	shr    $0x10,%eax
f0106f76:	66 a3 ee a2 42 f0    	mov    %ax,0xf042a2ee
	SETGATE(idt[46], 0, GD_KT, &ALL_FAULTS46, 3);
f0106f7c:	b8 0a 7f 10 f0       	mov    $0xf0107f0a,%eax
f0106f81:	66 a3 f0 a2 42 f0    	mov    %ax,0xf042a2f0
f0106f87:	66 c7 05 f2 a2 42 f0 	movw   $0x8,0xf042a2f2
f0106f8e:	08 00 
f0106f90:	a0 f4 a2 42 f0       	mov    0xf042a2f4,%al
f0106f95:	83 e0 e0             	and    $0xffffffe0,%eax
f0106f98:	a2 f4 a2 42 f0       	mov    %al,0xf042a2f4
f0106f9d:	a0 f4 a2 42 f0       	mov    0xf042a2f4,%al
f0106fa2:	83 e0 1f             	and    $0x1f,%eax
f0106fa5:	a2 f4 a2 42 f0       	mov    %al,0xf042a2f4
f0106faa:	a0 f5 a2 42 f0       	mov    0xf042a2f5,%al
f0106faf:	83 e0 f0             	and    $0xfffffff0,%eax
f0106fb2:	83 c8 0e             	or     $0xe,%eax
f0106fb5:	a2 f5 a2 42 f0       	mov    %al,0xf042a2f5
f0106fba:	a0 f5 a2 42 f0       	mov    0xf042a2f5,%al
f0106fbf:	83 e0 ef             	and    $0xffffffef,%eax
f0106fc2:	a2 f5 a2 42 f0       	mov    %al,0xf042a2f5
f0106fc7:	a0 f5 a2 42 f0       	mov    0xf042a2f5,%al
f0106fcc:	83 c8 60             	or     $0x60,%eax
f0106fcf:	a2 f5 a2 42 f0       	mov    %al,0xf042a2f5
f0106fd4:	a0 f5 a2 42 f0       	mov    0xf042a2f5,%al
f0106fd9:	83 c8 80             	or     $0xffffff80,%eax
f0106fdc:	a2 f5 a2 42 f0       	mov    %al,0xf042a2f5
f0106fe1:	b8 0a 7f 10 f0       	mov    $0xf0107f0a,%eax
f0106fe6:	c1 e8 10             	shr    $0x10,%eax
f0106fe9:	66 a3 f6 a2 42 f0    	mov    %ax,0xf042a2f6
	SETGATE(idt[47], 0, GD_KT, &ALL_FAULTS47, 3);
f0106fef:	b8 10 7f 10 f0       	mov    $0xf0107f10,%eax
f0106ff4:	66 a3 f8 a2 42 f0    	mov    %ax,0xf042a2f8
f0106ffa:	66 c7 05 fa a2 42 f0 	movw   $0x8,0xf042a2fa
f0107001:	08 00 
f0107003:	a0 fc a2 42 f0       	mov    0xf042a2fc,%al
f0107008:	83 e0 e0             	and    $0xffffffe0,%eax
f010700b:	a2 fc a2 42 f0       	mov    %al,0xf042a2fc
f0107010:	a0 fc a2 42 f0       	mov    0xf042a2fc,%al
f0107015:	83 e0 1f             	and    $0x1f,%eax
f0107018:	a2 fc a2 42 f0       	mov    %al,0xf042a2fc
f010701d:	a0 fd a2 42 f0       	mov    0xf042a2fd,%al
f0107022:	83 e0 f0             	and    $0xfffffff0,%eax
f0107025:	83 c8 0e             	or     $0xe,%eax
f0107028:	a2 fd a2 42 f0       	mov    %al,0xf042a2fd
f010702d:	a0 fd a2 42 f0       	mov    0xf042a2fd,%al
f0107032:	83 e0 ef             	and    $0xffffffef,%eax
f0107035:	a2 fd a2 42 f0       	mov    %al,0xf042a2fd
f010703a:	a0 fd a2 42 f0       	mov    0xf042a2fd,%al
f010703f:	83 c8 60             	or     $0x60,%eax
f0107042:	a2 fd a2 42 f0       	mov    %al,0xf042a2fd
f0107047:	a0 fd a2 42 f0       	mov    0xf042a2fd,%al
f010704c:	83 c8 80             	or     $0xffffff80,%eax
f010704f:	a2 fd a2 42 f0       	mov    %al,0xf042a2fd
f0107054:	b8 10 7f 10 f0       	mov    $0xf0107f10,%eax
f0107059:	c1 e8 10             	shr    $0x10,%eax
f010705c:	66 a3 fe a2 42 f0    	mov    %ax,0xf042a2fe

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	ts.ts_esp0 = KERNEL_STACK_TOP;
f0107062:	c7 05 84 a9 42 f0 00 	movl   $0xefc00000,0xf042a984
f0107069:	00 c0 ef 
	ts.ts_ss0 = GD_KD;
f010706c:	66 c7 05 88 a9 42 f0 	movw   $0x10,0xf042a988
f0107073:	10 00 

	// Initialize the TSS field of the gdt.
	gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32 ) (&ts),
f0107075:	66 c7 05 28 a7 13 f0 	movw   $0x68,0xf013a728
f010707c:	68 00 
f010707e:	b8 80 a9 42 f0       	mov    $0xf042a980,%eax
f0107083:	66 a3 2a a7 13 f0    	mov    %ax,0xf013a72a
f0107089:	b8 80 a9 42 f0       	mov    $0xf042a980,%eax
f010708e:	c1 e8 10             	shr    $0x10,%eax
f0107091:	a2 2c a7 13 f0       	mov    %al,0xf013a72c
f0107096:	a0 2d a7 13 f0       	mov    0xf013a72d,%al
f010709b:	83 e0 f0             	and    $0xfffffff0,%eax
f010709e:	83 c8 09             	or     $0x9,%eax
f01070a1:	a2 2d a7 13 f0       	mov    %al,0xf013a72d
f01070a6:	a0 2d a7 13 f0       	mov    0xf013a72d,%al
f01070ab:	83 c8 10             	or     $0x10,%eax
f01070ae:	a2 2d a7 13 f0       	mov    %al,0xf013a72d
f01070b3:	a0 2d a7 13 f0       	mov    0xf013a72d,%al
f01070b8:	83 e0 9f             	and    $0xffffff9f,%eax
f01070bb:	a2 2d a7 13 f0       	mov    %al,0xf013a72d
f01070c0:	a0 2d a7 13 f0       	mov    0xf013a72d,%al
f01070c5:	83 c8 80             	or     $0xffffff80,%eax
f01070c8:	a2 2d a7 13 f0       	mov    %al,0xf013a72d
f01070cd:	a0 2e a7 13 f0       	mov    0xf013a72e,%al
f01070d2:	83 e0 f0             	and    $0xfffffff0,%eax
f01070d5:	a2 2e a7 13 f0       	mov    %al,0xf013a72e
f01070da:	a0 2e a7 13 f0       	mov    0xf013a72e,%al
f01070df:	83 e0 ef             	and    $0xffffffef,%eax
f01070e2:	a2 2e a7 13 f0       	mov    %al,0xf013a72e
f01070e7:	a0 2e a7 13 f0       	mov    0xf013a72e,%al
f01070ec:	83 e0 df             	and    $0xffffffdf,%eax
f01070ef:	a2 2e a7 13 f0       	mov    %al,0xf013a72e
f01070f4:	a0 2e a7 13 f0       	mov    0xf013a72e,%al
f01070f9:	83 c8 40             	or     $0x40,%eax
f01070fc:	a2 2e a7 13 f0       	mov    %al,0xf013a72e
f0107101:	a0 2e a7 13 f0       	mov    0xf013a72e,%al
f0107106:	83 e0 7f             	and    $0x7f,%eax
f0107109:	a2 2e a7 13 f0       	mov    %al,0xf013a72e
f010710e:	b8 80 a9 42 f0       	mov    $0xf042a980,%eax
f0107113:	c1 e8 18             	shr    $0x18,%eax
f0107116:	a2 2f a7 13 f0       	mov    %al,0xf013a72f
			sizeof(struct Taskstate), 0);
	gdt[GD_TSS >> 3].sd_s = 0;
f010711b:	a0 2d a7 13 f0       	mov    0xf013a72d,%al
f0107120:	83 e0 ef             	and    $0xffffffef,%eax
f0107123:	a2 2d a7 13 f0       	mov    %al,0xf013a72d
f0107128:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010712e:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
f0107132:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	// Load the IDT
	asm volatile("lidt idt_pd");
f0107135:	0f 01 1d 68 a9 13 f0 	lidtl  0xf013a968
}
f010713c:	90                   	nop
f010713d:	c9                   	leave  
f010713e:	c3                   	ret    

f010713f <print_trapframe>:

void print_trapframe(struct Trapframe *tf) {
f010713f:	55                   	push   %ebp
f0107140:	89 e5                	mov    %esp,%ebp
f0107142:	53                   	push   %ebx
f0107143:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f0107146:	83 ec 08             	sub    $0x8,%esp
f0107149:	ff 75 08             	pushl  0x8(%ebp)
f010714c:	68 bb 16 11 f0       	push   $0xf01116bb
f0107151:	e8 05 ef ff ff       	call   f010605b <cprintf>
f0107156:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f0107159:	8b 45 08             	mov    0x8(%ebp),%eax
f010715c:	83 ec 0c             	sub    $0xc,%esp
f010715f:	50                   	push   %eax
f0107160:	e8 fd 00 00 00       	call   f0107262 <print_regs>
f0107165:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f0107168:	8b 45 08             	mov    0x8(%ebp),%eax
f010716b:	8b 40 20             	mov    0x20(%eax),%eax
f010716e:	0f b7 c0             	movzwl %ax,%eax
f0107171:	83 ec 08             	sub    $0x8,%esp
f0107174:	50                   	push   %eax
f0107175:	68 cd 16 11 f0       	push   $0xf01116cd
f010717a:	e8 dc ee ff ff       	call   f010605b <cprintf>
f010717f:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f0107182:	8b 45 08             	mov    0x8(%ebp),%eax
f0107185:	8b 40 24             	mov    0x24(%eax),%eax
f0107188:	0f b7 c0             	movzwl %ax,%eax
f010718b:	83 ec 08             	sub    $0x8,%esp
f010718e:	50                   	push   %eax
f010718f:	68 e0 16 11 f0       	push   $0xf01116e0
f0107194:	e8 c2 ee ff ff       	call   f010605b <cprintf>
f0107199:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno),
f010719c:	8b 45 08             	mov    0x8(%ebp),%eax
f010719f:	8b 58 28             	mov    0x28(%eax),%ebx
f01071a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01071a5:	8b 40 28             	mov    0x28(%eax),%eax
f01071a8:	83 ec 0c             	sub    $0xc,%esp
f01071ab:	50                   	push   %eax
f01071ac:	e8 d0 ee ff ff       	call   f0106081 <trapname>
f01071b1:	83 c4 10             	add    $0x10,%esp
f01071b4:	89 c2                	mov    %eax,%edx
f01071b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01071b9:	8b 40 28             	mov    0x28(%eax),%eax
f01071bc:	53                   	push   %ebx
f01071bd:	52                   	push   %edx
f01071be:	50                   	push   %eax
f01071bf:	68 f3 16 11 f0       	push   $0xf01116f3
f01071c4:	e8 92 ee ff ff       	call   f010605b <cprintf>
f01071c9:	83 c4 10             	add    $0x10,%esp
			tf->tf_trapno);
	cprintf("  err  0x%08x\n", tf->tf_err);
f01071cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01071cf:	8b 40 2c             	mov    0x2c(%eax),%eax
f01071d2:	83 ec 08             	sub    $0x8,%esp
f01071d5:	50                   	push   %eax
f01071d6:	68 0a 17 11 f0       	push   $0xf011170a
f01071db:	e8 7b ee ff ff       	call   f010605b <cprintf>
f01071e0:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f01071e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01071e6:	8b 40 30             	mov    0x30(%eax),%eax
f01071e9:	83 ec 08             	sub    $0x8,%esp
f01071ec:	50                   	push   %eax
f01071ed:	68 19 17 11 f0       	push   $0xf0111719
f01071f2:	e8 64 ee ff ff       	call   f010605b <cprintf>
f01071f7:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f01071fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01071fd:	8b 40 34             	mov    0x34(%eax),%eax
f0107200:	0f b7 c0             	movzwl %ax,%eax
f0107203:	83 ec 08             	sub    $0x8,%esp
f0107206:	50                   	push   %eax
f0107207:	68 28 17 11 f0       	push   $0xf0111728
f010720c:	e8 4a ee ff ff       	call   f010605b <cprintf>
f0107211:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f0107214:	8b 45 08             	mov    0x8(%ebp),%eax
f0107217:	8b 40 38             	mov    0x38(%eax),%eax
f010721a:	83 ec 08             	sub    $0x8,%esp
f010721d:	50                   	push   %eax
f010721e:	68 3b 17 11 f0       	push   $0xf011173b
f0107223:	e8 33 ee ff ff       	call   f010605b <cprintf>
f0107228:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010722b:	8b 45 08             	mov    0x8(%ebp),%eax
f010722e:	8b 40 3c             	mov    0x3c(%eax),%eax
f0107231:	83 ec 08             	sub    $0x8,%esp
f0107234:	50                   	push   %eax
f0107235:	68 4a 17 11 f0       	push   $0xf011174a
f010723a:	e8 1c ee ff ff       	call   f010605b <cprintf>
f010723f:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f0107242:	8b 45 08             	mov    0x8(%ebp),%eax
f0107245:	8b 40 40             	mov    0x40(%eax),%eax
f0107248:	0f b7 c0             	movzwl %ax,%eax
f010724b:	83 ec 08             	sub    $0x8,%esp
f010724e:	50                   	push   %eax
f010724f:	68 59 17 11 f0       	push   $0xf0111759
f0107254:	e8 02 ee ff ff       	call   f010605b <cprintf>
f0107259:	83 c4 10             	add    $0x10,%esp
}
f010725c:	90                   	nop
f010725d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107260:	c9                   	leave  
f0107261:	c3                   	ret    

f0107262 <print_regs>:

void print_regs(struct PushRegs *regs) {
f0107262:	55                   	push   %ebp
f0107263:	89 e5                	mov    %esp,%ebp
f0107265:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f0107268:	8b 45 08             	mov    0x8(%ebp),%eax
f010726b:	8b 00                	mov    (%eax),%eax
f010726d:	83 ec 08             	sub    $0x8,%esp
f0107270:	50                   	push   %eax
f0107271:	68 6c 17 11 f0       	push   $0xf011176c
f0107276:	e8 e0 ed ff ff       	call   f010605b <cprintf>
f010727b:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010727e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107281:	8b 40 04             	mov    0x4(%eax),%eax
f0107284:	83 ec 08             	sub    $0x8,%esp
f0107287:	50                   	push   %eax
f0107288:	68 7b 17 11 f0       	push   $0xf011177b
f010728d:	e8 c9 ed ff ff       	call   f010605b <cprintf>
f0107292:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f0107295:	8b 45 08             	mov    0x8(%ebp),%eax
f0107298:	8b 40 08             	mov    0x8(%eax),%eax
f010729b:	83 ec 08             	sub    $0x8,%esp
f010729e:	50                   	push   %eax
f010729f:	68 8a 17 11 f0       	push   $0xf011178a
f01072a4:	e8 b2 ed ff ff       	call   f010605b <cprintf>
f01072a9:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f01072ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01072af:	8b 40 0c             	mov    0xc(%eax),%eax
f01072b2:	83 ec 08             	sub    $0x8,%esp
f01072b5:	50                   	push   %eax
f01072b6:	68 99 17 11 f0       	push   $0xf0111799
f01072bb:	e8 9b ed ff ff       	call   f010605b <cprintf>
f01072c0:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f01072c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01072c6:	8b 40 10             	mov    0x10(%eax),%eax
f01072c9:	83 ec 08             	sub    $0x8,%esp
f01072cc:	50                   	push   %eax
f01072cd:	68 a8 17 11 f0       	push   $0xf01117a8
f01072d2:	e8 84 ed ff ff       	call   f010605b <cprintf>
f01072d7:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f01072da:	8b 45 08             	mov    0x8(%ebp),%eax
f01072dd:	8b 40 14             	mov    0x14(%eax),%eax
f01072e0:	83 ec 08             	sub    $0x8,%esp
f01072e3:	50                   	push   %eax
f01072e4:	68 b7 17 11 f0       	push   $0xf01117b7
f01072e9:	e8 6d ed ff ff       	call   f010605b <cprintf>
f01072ee:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f01072f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01072f4:	8b 40 18             	mov    0x18(%eax),%eax
f01072f7:	83 ec 08             	sub    $0x8,%esp
f01072fa:	50                   	push   %eax
f01072fb:	68 c6 17 11 f0       	push   $0xf01117c6
f0107300:	e8 56 ed ff ff       	call   f010605b <cprintf>
f0107305:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f0107308:	8b 45 08             	mov    0x8(%ebp),%eax
f010730b:	8b 40 1c             	mov    0x1c(%eax),%eax
f010730e:	83 ec 08             	sub    $0x8,%esp
f0107311:	50                   	push   %eax
f0107312:	68 d5 17 11 f0       	push   $0xf01117d5
f0107317:	e8 3f ed ff ff       	call   f010605b <cprintf>
f010731c:	83 c4 10             	add    $0x10,%esp
}
f010731f:	90                   	nop
f0107320:	c9                   	leave  
f0107321:	c3                   	ret    

f0107322 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf) {
f0107322:	55                   	push   %ebp
f0107323:	89 e5                	mov    %esp,%ebp
f0107325:	57                   	push   %edi
f0107326:	56                   	push   %esi
f0107327:	53                   	push   %ebx
f0107328:	83 ec 1c             	sub    $0x1c,%esp
	// Handle processor exceptions.
	// LAB 3: Your code here.

	if (tf->tf_trapno == T_PGFLT) {
f010732b:	8b 45 08             	mov    0x8(%ebp),%eax
f010732e:	8b 40 28             	mov    0x28(%eax),%eax
f0107331:	83 f8 0e             	cmp    $0xe,%eax
f0107334:	75 21                	jne    f0107357 <trap_dispatch+0x35>
		//print_trapframe(tf);
		if (isPageReplacmentAlgorithmLRU()) {
f0107336:	e8 3e 02 00 00       	call   f0107579 <isPageReplacmentAlgorithmLRU>
f010733b:	85 c0                	test   %eax,%eax
f010733d:	74 05                	je     f0107344 <trap_dispatch+0x22>
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010733f:	e8 a5 18 00 00       	call   f0108be9 <update_WS_time_stamps>
		}
		fault_handler(tf);
f0107344:	83 ec 0c             	sub    $0xc,%esp
f0107347:	ff 75 08             	pushl  0x8(%ebp)
f010734a:	e8 6a 03 00 00       	call   f01076b9 <fault_handler>
f010734f:	83 c4 10             	add    $0x10,%esp
		} else {
			//env_destroy(curenv);
			return;
		}
	}
	return;
f0107352:	e9 a5 00 00 00       	jmp    f01073fc <trap_dispatch+0xda>
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
		}
		fault_handler(tf);
	} else if (tf->tf_trapno == T_SYSCALL) {
f0107357:	8b 45 08             	mov    0x8(%ebp),%eax
f010735a:	8b 40 28             	mov    0x28(%eax),%eax
f010735d:	83 f8 30             	cmp    $0x30,%eax
f0107360:	75 42                	jne    f01073a4 <trap_dispatch+0x82>
		uint32 ret = syscall(tf->tf_regs.reg_eax, tf->tf_regs.reg_edx,
f0107362:	8b 45 08             	mov    0x8(%ebp),%eax
f0107365:	8b 78 04             	mov    0x4(%eax),%edi
f0107368:	8b 45 08             	mov    0x8(%ebp),%eax
f010736b:	8b 30                	mov    (%eax),%esi
f010736d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107370:	8b 58 10             	mov    0x10(%eax),%ebx
f0107373:	8b 45 08             	mov    0x8(%ebp),%eax
f0107376:	8b 48 18             	mov    0x18(%eax),%ecx
f0107379:	8b 45 08             	mov    0x8(%ebp),%eax
f010737c:	8b 50 14             	mov    0x14(%eax),%edx
f010737f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107382:	8b 40 1c             	mov    0x1c(%eax),%eax
f0107385:	83 ec 08             	sub    $0x8,%esp
f0107388:	57                   	push   %edi
f0107389:	56                   	push   %esi
f010738a:	53                   	push   %ebx
f010738b:	51                   	push   %ecx
f010738c:	52                   	push   %edx
f010738d:	50                   	push   %eax
f010738e:	e8 c2 21 00 00       	call   f0109555 <syscall>
f0107393:	83 c4 20             	add    $0x20,%esp
f0107396:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi,
				tf->tf_regs.reg_esi);
		tf->tf_regs.reg_eax = ret;
f0107399:	8b 45 08             	mov    0x8(%ebp),%eax
f010739c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010739f:	89 50 1c             	mov    %edx,0x1c(%eax)
		} else {
			//env_destroy(curenv);
			return;
		}
	}
	return;
f01073a2:	eb 58                	jmp    f01073fc <trap_dispatch+0xda>
	} else if (tf->tf_trapno == T_SYSCALL) {
		uint32 ret = syscall(tf->tf_regs.reg_eax, tf->tf_regs.reg_edx,
				tf->tf_regs.reg_ecx, tf->tf_regs.reg_ebx, tf->tf_regs.reg_edi,
				tf->tf_regs.reg_esi);
		tf->tf_regs.reg_eax = ret;
	} else if (tf->tf_trapno == T_DBLFLT) {
f01073a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01073a7:	8b 40 28             	mov    0x28(%eax),%eax
f01073aa:	83 f8 08             	cmp    $0x8,%eax
f01073ad:	75 17                	jne    f01073c6 <trap_dispatch+0xa4>
		panic("double fault!!");
f01073af:	83 ec 04             	sub    $0x4,%esp
f01073b2:	68 e4 17 11 f0       	push   $0xf01117e4
f01073b7:	68 cb 00 00 00       	push   $0xcb
f01073bc:	68 f3 17 11 f0       	push   $0xf01117f3
f01073c1:	e8 96 8d ff ff       	call   f010015c <_panic>
	} else if (tf->tf_trapno == IRQ0_Clock) {
f01073c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01073c9:	8b 40 28             	mov    0x28(%eax),%eax
f01073cc:	83 f8 20             	cmp    $0x20,%eax
f01073cf:	75 07                	jne    f01073d8 <trap_dispatch+0xb6>
		clock_interrupt_handler();
f01073d1:	e8 fa 17 00 00       	call   f0108bd0 <clock_interrupt_handler>
		} else {
			//env_destroy(curenv);
			return;
		}
	}
	return;
f01073d6:	eb 24                	jmp    f01073fc <trap_dispatch+0xda>
	}

	else {
		// Unexpected trap: The user process or the kernel has a bug.
		//print_trapframe(tf);
		if (tf->tf_cs == GD_KT) {
f01073d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01073db:	8b 40 34             	mov    0x34(%eax),%eax
f01073de:	66 83 f8 08          	cmp    $0x8,%ax
f01073e2:	75 17                	jne    f01073fb <trap_dispatch+0xd9>
			panic("unhandled trap in kernel");
f01073e4:	83 ec 04             	sub    $0x4,%esp
f01073e7:	68 ff 17 11 f0       	push   $0xf01117ff
f01073ec:	68 d4 00 00 00       	push   $0xd4
f01073f1:	68 f3 17 11 f0       	push   $0xf01117f3
f01073f6:	e8 61 8d ff ff       	call   f010015c <_panic>
		} else {
			//env_destroy(curenv);
			return;
f01073fb:	90                   	nop
		}
	}
	return;
}
f01073fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01073ff:	5b                   	pop    %ebx
f0107400:	5e                   	pop    %esi
f0107401:	5f                   	pop    %edi
f0107402:	5d                   	pop    %ebp
f0107403:	c3                   	ret    

f0107404 <trap>:

void trap(struct Trapframe *tf) {
f0107404:	55                   	push   %ebp
f0107405:	89 e5                	mov    %esp,%ebp
f0107407:	57                   	push   %edi
f0107408:	56                   	push   %esi
f0107409:	53                   	push   %ebx
f010740a:	83 ec 1c             	sub    $0x1c,%esp
	kclock_stop();
f010740d:	e8 7e e9 ff ff       	call   f0105d90 <kclock_stop>
	int userTrap = 0;
f0107412:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f0107419:	8b 45 08             	mov    0x8(%ebp),%eax
f010741c:	8b 40 34             	mov    0x34(%eax),%eax
f010741f:	0f b7 c0             	movzwl %ax,%eax
f0107422:	83 e0 03             	and    $0x3,%eax
f0107425:	83 f8 03             	cmp    $0x3,%eax
f0107428:	75 49                	jne    f0107473 <trap+0x6f>
		assert(curenv);
f010742a:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010742f:	85 c0                	test   %eax,%eax
f0107431:	75 19                	jne    f010744c <trap+0x48>
f0107433:	68 18 18 11 f0       	push   $0xf0111818
f0107438:	68 1f 18 11 f0       	push   $0xf011181f
f010743d:	68 e1 00 00 00       	push   $0xe1
f0107442:	68 f3 17 11 f0       	push   $0xf01117f3
f0107447:	e8 10 8d ff ff       	call   f010015c <_panic>
		curenv->env_tf = *tf;
f010744c:	8b 15 38 a1 42 f0    	mov    0xf042a138,%edx
f0107452:	8b 45 08             	mov    0x8(%ebp),%eax
f0107455:	89 c3                	mov    %eax,%ebx
f0107457:	b8 11 00 00 00       	mov    $0x11,%eax
f010745c:	89 d7                	mov    %edx,%edi
f010745e:	89 de                	mov    %ebx,%esi
f0107460:	89 c1                	mov    %eax,%ecx
f0107462:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		tf = &(curenv->env_tf);
f0107464:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0107469:	89 45 08             	mov    %eax,0x8(%ebp)
		userTrap = 1;
f010746c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
	}
	if (tf->tf_trapno == IRQ0_Clock) {
f0107473:	8b 45 08             	mov    0x8(%ebp),%eax
f0107476:	8b 40 28             	mov    0x28(%eax),%eax
f0107479:	83 f8 20             	cmp    $0x20,%eax
f010747c:	74 70                	je     f01074ee <trap+0xea>
	} else if (tf->tf_trapno == T_PGFLT) {
f010747e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107481:	8b 40 28             	mov    0x28(%eax),%eax
f0107484:	83 f8 0e             	cmp    $0xe,%eax
f0107487:	75 65                	jne    f01074ee <trap+0xea>
		//2016: Bypass the faulted instruction
		if (bypassInstrLength != 0) {
f0107489:	a0 60 a1 42 f0       	mov    0xf042a160,%al
f010748e:	84 c0                	test   %al,%al
f0107490:	74 5c                	je     f01074ee <trap+0xea>
			if (userTrap) {
f0107492:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0107496:	74 2c                	je     f01074c4 <trap+0xc0>
				curenv->env_tf.tf_eip =
f0107498:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
						(uint32*) ((uint32) (curenv->env_tf.tf_eip)
f010749d:	8b 15 38 a1 42 f0    	mov    0xf042a138,%edx
f01074a3:	8b 52 30             	mov    0x30(%edx),%edx
f01074a6:	89 d1                	mov    %edx,%ecx
								+ bypassInstrLength);
f01074a8:	8a 15 60 a1 42 f0    	mov    0xf042a160,%dl
f01074ae:	0f b6 d2             	movzbl %dl,%edx
f01074b1:	01 ca                	add    %ecx,%edx
	if (tf->tf_trapno == IRQ0_Clock) {
	} else if (tf->tf_trapno == T_PGFLT) {
		//2016: Bypass the faulted instruction
		if (bypassInstrLength != 0) {
			if (userTrap) {
				curenv->env_tf.tf_eip =
f01074b3:	89 50 30             	mov    %edx,0x30(%eax)
						(uint32*) ((uint32) (curenv->env_tf.tf_eip)
								+ bypassInstrLength);
				env_run(curenv);
f01074b6:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01074bb:	83 ec 0c             	sub    $0xc,%esp
f01074be:	50                   	push   %eax
f01074bf:	e8 b7 dd ff ff       	call   f010527b <env_run>
			} else {
				tf->tf_eip = (uint32*) ((uint32) (tf->tf_eip)
f01074c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01074c7:	8b 40 30             	mov    0x30(%eax),%eax
f01074ca:	89 c2                	mov    %eax,%edx
						+ bypassInstrLength);
f01074cc:	a0 60 a1 42 f0       	mov    0xf042a160,%al
f01074d1:	0f b6 c0             	movzbl %al,%eax
f01074d4:	01 d0                	add    %edx,%eax
				curenv->env_tf.tf_eip =
						(uint32*) ((uint32) (curenv->env_tf.tf_eip)
								+ bypassInstrLength);
				env_run(curenv);
			} else {
				tf->tf_eip = (uint32*) ((uint32) (tf->tf_eip)
f01074d6:	89 c2                	mov    %eax,%edx
f01074d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01074db:	89 50 30             	mov    %edx,0x30(%eax)
						+ bypassInstrLength);
				kclock_resume();
f01074de:	e8 32 e8 ff ff       	call   f0105d15 <kclock_resume>
				env_pop_tf(tf);
f01074e3:	83 ec 0c             	sub    $0xc,%esp
f01074e6:	ff 75 08             	pushl  0x8(%ebp)
f01074e9:	e8 32 e7 ff ff       	call   f0105c20 <env_pop_tf>
			}
		}
	}
	trap_dispatch(tf);
f01074ee:	83 ec 0c             	sub    $0xc,%esp
f01074f1:	ff 75 08             	pushl  0x8(%ebp)
f01074f4:	e8 29 fe ff ff       	call   f0107322 <trap_dispatch>
f01074f9:	83 c4 10             	add    $0x10,%esp
	assert(curenv && curenv->env_status == ENV_READY);
f01074fc:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0107501:	85 c0                	test   %eax,%eax
f0107503:	74 0d                	je     f0107512 <trap+0x10e>
f0107505:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010750a:	8b 40 54             	mov    0x54(%eax),%eax
f010750d:	83 f8 01             	cmp    $0x1,%eax
f0107510:	74 19                	je     f010752b <trap+0x127>
f0107512:	68 34 18 11 f0       	push   $0xf0111834
f0107517:	68 1f 18 11 f0       	push   $0xf011181f
f010751c:	68 f8 00 00 00       	push   $0xf8
f0107521:	68 f3 17 11 f0       	push   $0xf01117f3
f0107526:	e8 31 8c ff ff       	call   f010015c <_panic>
	env_run(curenv);
f010752b:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0107530:	83 ec 0c             	sub    $0xc,%esp
f0107533:	50                   	push   %eax
f0107534:	e8 42 dd ff ff       	call   f010527b <env_run>

f0107539 <setPageReplacmentAlgorithmLRU>:
}

void setPageReplacmentAlgorithmLRU() {
f0107539:	55                   	push   %ebp
f010753a:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_LRU;
f010753c:	c7 05 38 2a 45 f0 01 	movl   $0x1,0xf0452a38
f0107543:	00 00 00 
}
f0107546:	90                   	nop
f0107547:	5d                   	pop    %ebp
f0107548:	c3                   	ret    

f0107549 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK() {
f0107549:	55                   	push   %ebp
f010754a:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_CLOCK;
f010754c:	c7 05 38 2a 45 f0 02 	movl   $0x2,0xf0452a38
f0107553:	00 00 00 
}
f0107556:	90                   	nop
f0107557:	5d                   	pop    %ebp
f0107558:	c3                   	ret    

f0107559 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO() {
f0107559:	55                   	push   %ebp
f010755a:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_FIFO;
f010755c:	c7 05 38 2a 45 f0 03 	movl   $0x3,0xf0452a38
f0107563:	00 00 00 
}
f0107566:	90                   	nop
f0107567:	5d                   	pop    %ebp
f0107568:	c3                   	ret    

f0107569 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK() {
f0107569:	55                   	push   %ebp
f010756a:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;
f010756c:	c7 05 38 2a 45 f0 04 	movl   $0x4,0xf0452a38
f0107573:	00 00 00 
}
f0107576:	90                   	nop
f0107577:	5d                   	pop    %ebp
f0107578:	c3                   	ret    

f0107579 <isPageReplacmentAlgorithmLRU>:

uint32 isPageReplacmentAlgorithmLRU() {
f0107579:	55                   	push   %ebp
f010757a:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_LRU)
f010757c:	a1 38 2a 45 f0       	mov    0xf0452a38,%eax
f0107581:	83 f8 01             	cmp    $0x1,%eax
f0107584:	75 07                	jne    f010758d <isPageReplacmentAlgorithmLRU+0x14>
		return 1;
f0107586:	b8 01 00 00 00       	mov    $0x1,%eax
f010758b:	eb 05                	jmp    f0107592 <isPageReplacmentAlgorithmLRU+0x19>
	return 0;
f010758d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0107592:	5d                   	pop    %ebp
f0107593:	c3                   	ret    

f0107594 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK() {
f0107594:	55                   	push   %ebp
f0107595:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_CLOCK)
f0107597:	a1 38 2a 45 f0       	mov    0xf0452a38,%eax
f010759c:	83 f8 02             	cmp    $0x2,%eax
f010759f:	75 07                	jne    f01075a8 <isPageReplacmentAlgorithmCLOCK+0x14>
		return 1;
f01075a1:	b8 01 00 00 00       	mov    $0x1,%eax
f01075a6:	eb 05                	jmp    f01075ad <isPageReplacmentAlgorithmCLOCK+0x19>
	return 0;
f01075a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01075ad:	5d                   	pop    %ebp
f01075ae:	c3                   	ret    

f01075af <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO() {
f01075af:	55                   	push   %ebp
f01075b0:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_FIFO)
f01075b2:	a1 38 2a 45 f0       	mov    0xf0452a38,%eax
f01075b7:	83 f8 03             	cmp    $0x3,%eax
f01075ba:	75 07                	jne    f01075c3 <isPageReplacmentAlgorithmFIFO+0x14>
		return 1;
f01075bc:	b8 01 00 00 00       	mov    $0x1,%eax
f01075c1:	eb 05                	jmp    f01075c8 <isPageReplacmentAlgorithmFIFO+0x19>
	return 0;
f01075c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01075c8:	5d                   	pop    %ebp
f01075c9:	c3                   	ret    

f01075ca <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK() {
f01075ca:	55                   	push   %ebp
f01075cb:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_MODIFIEDCLOCK)
f01075cd:	a1 38 2a 45 f0       	mov    0xf0452a38,%eax
f01075d2:	83 f8 04             	cmp    $0x4,%eax
f01075d5:	75 07                	jne    f01075de <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
		return 1;
f01075d7:	b8 01 00 00 00       	mov    $0x1,%eax
f01075dc:	eb 05                	jmp    f01075e3 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
	return 0;
f01075de:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01075e3:	5d                   	pop    %ebp
f01075e4:	c3                   	ret    

f01075e5 <enableModifiedBuffer>:

void enableModifiedBuffer(uint32 enableIt) {
f01075e5:	55                   	push   %ebp
f01075e6:	89 e5                	mov    %esp,%ebp
	_EnableModifiedBuffer = enableIt;
f01075e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01075eb:	a3 30 2a 45 f0       	mov    %eax,0xf0452a30
}
f01075f0:	90                   	nop
f01075f1:	5d                   	pop    %ebp
f01075f2:	c3                   	ret    

f01075f3 <isModifiedBufferEnabled>:
uint32 isModifiedBufferEnabled() {
f01075f3:	55                   	push   %ebp
f01075f4:	89 e5                	mov    %esp,%ebp
	return _EnableModifiedBuffer;
f01075f6:	a1 30 2a 45 f0       	mov    0xf0452a30,%eax
}
f01075fb:	5d                   	pop    %ebp
f01075fc:	c3                   	ret    

f01075fd <enableBuffering>:

void enableBuffering(uint32 enableIt) {
f01075fd:	55                   	push   %ebp
f01075fe:	89 e5                	mov    %esp,%ebp
	_EnableBuffering = enableIt;
f0107600:	8b 45 08             	mov    0x8(%ebp),%eax
f0107603:	a3 3c 2a 45 f0       	mov    %eax,0xf0452a3c
}
f0107608:	90                   	nop
f0107609:	5d                   	pop    %ebp
f010760a:	c3                   	ret    

f010760b <isBufferingEnabled>:
uint32 isBufferingEnabled() {
f010760b:	55                   	push   %ebp
f010760c:	89 e5                	mov    %esp,%ebp
	return _EnableBuffering;
f010760e:	a1 3c 2a 45 f0       	mov    0xf0452a3c,%eax
}
f0107613:	5d                   	pop    %ebp
f0107614:	c3                   	ret    

f0107615 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) {
f0107615:	55                   	push   %ebp
f0107616:	89 e5                	mov    %esp,%ebp
	_ModifiedBufferLength = length;
f0107618:	8b 45 08             	mov    0x8(%ebp),%eax
f010761b:	a3 40 2a 45 f0       	mov    %eax,0xf0452a40
}
f0107620:	90                   	nop
f0107621:	5d                   	pop    %ebp
f0107622:	c3                   	ret    

f0107623 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() {
f0107623:	55                   	push   %ebp
f0107624:	89 e5                	mov    %esp,%ebp
	return _ModifiedBufferLength;
f0107626:	a1 40 2a 45 f0       	mov    0xf0452a40,%eax
}
f010762b:	5d                   	pop    %ebp
f010762c:	c3                   	ret    

f010762d <detect_modified_loop>:

void detect_modified_loop() {
f010762d:	55                   	push   %ebp
f010762e:	89 e5                	mov    %esp,%ebp
f0107630:	83 ec 18             	sub    $0x18,%esp
	struct Frame_Info * slowPtr = LIST_FIRST(&modified_frame_list);
f0107633:	a1 60 52 45 f0       	mov    0xf0455260,%eax
f0107638:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Frame_Info * fastPtr = LIST_FIRST(&modified_frame_list);
f010763b:	a1 60 52 45 f0       	mov    0xf0455260,%eax
f0107640:	89 45 f0             	mov    %eax,-0x10(%ebp)

	while (slowPtr && fastPtr) {
f0107643:	eb 52                	jmp    f0107697 <detect_modified_loop+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f0107645:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107648:	8b 00                	mov    (%eax),%eax
f010764a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f010764d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107650:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107653:	75 12                	jne    f0107667 <detect_modified_loop+0x3a>
				{
			cprintf("loop detected in modiflist\n");
f0107655:	83 ec 0c             	sub    $0xc,%esp
f0107658:	68 5e 18 11 f0       	push   $0xf011185e
f010765d:	e8 f9 e9 ff ff       	call   f010605b <cprintf>
f0107662:	83 c4 10             	add    $0x10,%esp
			break;
f0107665:	eb 3f                	jmp    f01076a6 <detect_modified_loop+0x79>
		}

		if (fastPtr == NULL) {
f0107667:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010766b:	74 38                	je     f01076a5 <detect_modified_loop+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f010766d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107670:	8b 00                	mov    (%eax),%eax
f0107672:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f0107675:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107678:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010767b:	75 12                	jne    f010768f <detect_modified_loop+0x62>
			cprintf("loop detected in modiflist\n");
f010767d:	83 ec 0c             	sub    $0xc,%esp
f0107680:	68 5e 18 11 f0       	push   $0xf011185e
f0107685:	e8 d1 e9 ff ff       	call   f010605b <cprintf>
f010768a:	83 c4 10             	add    $0x10,%esp
			break;
f010768d:	eb 17                	jmp    f01076a6 <detect_modified_loop+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f010768f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107692:	8b 00                	mov    (%eax),%eax
f0107694:	89 45 f4             	mov    %eax,-0xc(%ebp)

void detect_modified_loop() {
	struct Frame_Info * slowPtr = LIST_FIRST(&modified_frame_list);
	struct Frame_Info * fastPtr = LIST_FIRST(&modified_frame_list);

	while (slowPtr && fastPtr) {
f0107697:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010769b:	74 09                	je     f01076a6 <detect_modified_loop+0x79>
f010769d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01076a1:	75 a2                	jne    f0107645 <detect_modified_loop+0x18>
f01076a3:	eb 01                	jmp    f01076a6 <detect_modified_loop+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f01076a5:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished modi loop detection\n");
f01076a6:	83 ec 0c             	sub    $0xc,%esp
f01076a9:	68 7a 18 11 f0       	push   $0xf011187a
f01076ae:	e8 a8 e9 ff ff       	call   f010605b <cprintf>
f01076b3:	83 c4 10             	add    $0x10,%esp
}
f01076b6:	90                   	nop
f01076b7:	c9                   	leave  
f01076b8:	c3                   	ret    

f01076b9 <fault_handler>:

void fault_handler(struct Trapframe *tf) {
f01076b9:	55                   	push   %ebp
f01076ba:	89 e5                	mov    %esp,%ebp
f01076bc:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f01076bf:	0f 20 d0             	mov    %cr2,%eax
f01076c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01076c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
	//print_trapframe(tf);
	uint32 fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
f01076c8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//get a pointer to the environment that caused the fault at runtime
	struct Env* faulted_env = curenv;
f01076cb:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01076d0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ((curenv->env_page_directory[PDX(fault_va)] & PERM_PRESENT)
f01076d3:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01076d8:	8b 40 5c             	mov    0x5c(%eax),%eax
f01076db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01076de:	c1 ea 16             	shr    $0x16,%edx
f01076e1:	c1 e2 02             	shl    $0x2,%edx
f01076e4:	01 d0                	add    %edx,%eax
f01076e6:	8b 00                	mov    (%eax),%eax
f01076e8:	83 e0 01             	and    $0x1,%eax
f01076eb:	85 c0                	test   %eax,%eax
f01076ed:	75 28                	jne    f0107717 <fault_handler+0x5e>
			!= PERM_PRESENT) {
		// we have a table fault =============================================================
		//cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		faulted_env->tableFaultsCounter++;
f01076ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01076f2:	8b 80 e0 02 00 00    	mov    0x2e0(%eax),%eax
f01076f8:	8d 50 01             	lea    0x1(%eax),%edx
f01076fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01076fe:	89 90 e0 02 00 00    	mov    %edx,0x2e0(%eax)

		table_fault_handler(faulted_env, fault_va);
f0107704:	83 ec 08             	sub    $0x8,%esp
f0107707:	ff 75 f0             	pushl  -0x10(%ebp)
f010770a:	ff 75 ec             	pushl  -0x14(%ebp)
f010770d:	e8 56 00 00 00       	call   f0107768 <table_fault_handler>
f0107712:	83 c4 10             	add    $0x10,%esp
f0107715:	eb 42                	jmp    f0107759 <fault_handler+0xa0>
	} else {
		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter++;
f0107717:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010771a:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
f0107720:	8d 50 01             	lea    0x1(%eax),%edx
f0107723:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107726:	89 90 dc 02 00 00    	mov    %edx,0x2dc(%eax)

//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
//
//		cprintf("\nPage working set BEFORE fault handler...\n");
//		env_page_ws_print(curenv);
		if (isBufferingEnabled()) {
f010772c:	e8 da fe ff ff       	call   f010760b <isBufferingEnabled>
f0107731:	85 c0                	test   %eax,%eax
f0107733:	74 13                	je     f0107748 <fault_handler+0x8f>
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f0107735:	83 ec 08             	sub    $0x8,%esp
f0107738:	ff 75 f0             	pushl  -0x10(%ebp)
f010773b:	ff 75 ec             	pushl  -0x14(%ebp)
f010773e:	e8 46 00 00 00       	call   f0107789 <__page_fault_handler_with_buffering>
f0107743:	83 c4 10             	add    $0x10,%esp
f0107746:	eb 11                	jmp    f0107759 <fault_handler+0xa0>
		} else {
			page_fault_handler(faulted_env, fault_va);
f0107748:	83 ec 08             	sub    $0x8,%esp
f010774b:	ff 75 f0             	pushl  -0x10(%ebp)
f010774e:	ff 75 ec             	pushl  -0x14(%ebp)
f0107751:	e8 39 00 00 00       	call   f010778f <page_fault_handler>
f0107756:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0107759:	0f 20 d8             	mov    %cr3,%eax
f010775c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010775f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107762:	0f 22 d8             	mov    %eax,%cr3
	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/

}
f0107765:	90                   	nop
f0107766:	c9                   	leave  
f0107767:	c3                   	ret    

f0107768 <table_fault_handler>:

//Handle the table fault
void table_fault_handler(struct Env * curenv, uint32 fault_va) {
f0107768:	55                   	push   %ebp
f0107769:	89 e5                	mov    %esp,%ebp
f010776b:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
	if (USE_KHEAP) {
		ptr_table = create_page_table(curenv->env_page_directory,
f010776e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107771:	8b 40 5c             	mov    0x5c(%eax),%eax
f0107774:	83 ec 08             	sub    $0x8,%esp
f0107777:	ff 75 0c             	pushl  0xc(%ebp)
f010777a:	50                   	push   %eax
f010777b:	e8 e8 b6 ff ff       	call   f0102e68 <create_page_table>
f0107780:	83 c4 10             	add    $0x10,%esp
f0107783:	89 45 f4             	mov    %eax,-0xc(%ebp)
				(uint32) fault_va);
	} else {
		__static_cpt(curenv->env_page_directory, (uint32) fault_va, &ptr_table);
	}

}
f0107786:	90                   	nop
f0107787:	c9                   	leave  
f0107788:	c3                   	ret    

f0107789 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va) {
f0107789:	55                   	push   %ebp
f010778a:	89 e5                	mov    %esp,%ebp

}
f010778c:	90                   	nop
f010778d:	5d                   	pop    %ebp
f010778e:	c3                   	ret    

f010778f <page_fault_handler>:

//Handle the page fault
void page_fault_handler(struct Env * curenv, uint32 fault_va) { //TODO: [PROJECT 2016] PAGE FAULT HANDLER
f010778f:	55                   	push   %ebp
f0107790:	89 e5                	mov    %esp,%ebp
f0107792:	83 ec 58             	sub    $0x58,%esp
//panic("page_fault_handler() is not imple0mented yet...!!");

	//refer to the project documentation for the detailed steps


	if (env_page_ws_get_size(curenv) < curenv->page_WS_max_size) {
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	ff 75 08             	pushl  0x8(%ebp)
f010779b:	e8 53 be ff ff       	call   f01035f3 <env_page_ws_get_size>
f01077a0:	83 c4 10             	add    $0x10,%esp
f01077a3:	89 c2                	mov    %eax,%edx
f01077a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01077a8:	8b 40 74             	mov    0x74(%eax),%eax
f01077ab:	39 c2                	cmp    %eax,%edx
f01077ad:	0f 83 95 00 00 00    	jae    f0107848 <page_fault_handler+0xb9>

		check_fault_va(curenv, fault_va);
f01077b3:	83 ec 08             	sub    $0x8,%esp
f01077b6:	ff 75 0c             	pushl  0xc(%ebp)
f01077b9:	ff 75 08             	pushl  0x8(%ebp)
f01077bc:	e8 95 05 00 00       	call   f0107d56 <check_fault_va>
f01077c1:	83 c4 10             	add    $0x10,%esp

		int i = 0;
f01077c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (; i < curenv->page_WS_max_size; i++) {
f01077cb:	eb 1e                	jmp    f01077eb <page_fault_handler+0x5c>
			if (curenv->ptr_pageWorkingSet[i].empty) {
f01077cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01077d0:	8b 48 78             	mov    0x78(%eax),%ecx
f01077d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01077d6:	89 d0                	mov    %edx,%eax
f01077d8:	01 c0                	add    %eax,%eax
f01077da:	01 d0                	add    %edx,%eax
f01077dc:	c1 e0 02             	shl    $0x2,%eax
f01077df:	01 c8                	add    %ecx,%eax
f01077e1:	8a 40 04             	mov    0x4(%eax),%al
f01077e4:	84 c0                	test   %al,%al
f01077e6:	75 12                	jne    f01077fa <page_fault_handler+0x6b>
	if (env_page_ws_get_size(curenv) < curenv->page_WS_max_size) {

		check_fault_va(curenv, fault_va);

		int i = 0;
		for (; i < curenv->page_WS_max_size; i++) {
f01077e8:	ff 45 f4             	incl   -0xc(%ebp)
f01077eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01077ee:	8b 50 74             	mov    0x74(%eax),%edx
f01077f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077f4:	39 c2                	cmp    %eax,%edx
f01077f6:	77 d5                	ja     f01077cd <page_fault_handler+0x3e>
f01077f8:	eb 01                	jmp    f01077fb <page_fault_handler+0x6c>
			if (curenv->ptr_pageWorkingSet[i].empty) {
				break;
f01077fa:	90                   	nop
			}

		}

		env_page_ws_set_entry(curenv, i, fault_va);
f01077fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077fe:	83 ec 04             	sub    $0x4,%esp
f0107801:	ff 75 0c             	pushl  0xc(%ebp)
f0107804:	50                   	push   %eax
f0107805:	ff 75 08             	pushl  0x8(%ebp)
f0107808:	e8 9a be ff ff       	call   f01036a7 <env_page_ws_set_entry>
f010780d:	83 c4 10             	add    $0x10,%esp
		curenv->page_last_WS_index = i + 1;
f0107810:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107813:	40                   	inc    %eax
f0107814:	89 c2                	mov    %eax,%edx
f0107816:	8b 45 08             	mov    0x8(%ebp),%eax
f0107819:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)
		if (curenv->page_last_WS_index == curenv->page_WS_max_size)
f010781f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107822:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f0107828:	8b 45 08             	mov    0x8(%ebp),%eax
f010782b:	8b 40 74             	mov    0x74(%eax),%eax
f010782e:	39 c2                	cmp    %eax,%edx
f0107830:	0f 85 1d 05 00 00    	jne    f0107d53 <page_fault_handler+0x5c4>
			curenv->page_last_WS_index = 0;
f0107836:	8b 45 08             	mov    0x8(%ebp),%eax
f0107839:	c7 80 d4 02 00 00 00 	movl   $0x0,0x2d4(%eax)
f0107840:	00 00 00 
		}

	}

	//TODO: [PROJECT 2016 - BONUS3] Apply FIFO and modifiedCLOCK algorithms
}
f0107843:	e9 0b 05 00 00       	jmp    f0107d53 <page_fault_handler+0x5c4>
		curenv->page_last_WS_index = i + 1;
		if (curenv->page_last_WS_index == curenv->page_WS_max_size)
			curenv->page_last_WS_index = 0;

	} else {
		if (isPageReplacmentAlgorithmLRU()) {
f0107848:	e8 2c fd ff ff       	call   f0107579 <isPageReplacmentAlgorithmLRU>
f010784d:	85 c0                	test   %eax,%eax
f010784f:	0f 84 95 01 00 00    	je     f01079ea <page_fault_handler+0x25b>


			check_fault_va(curenv, fault_va);
f0107855:	83 ec 08             	sub    $0x8,%esp
f0107858:	ff 75 0c             	pushl  0xc(%ebp)
f010785b:	ff 75 08             	pushl  0x8(%ebp)
f010785e:	e8 f3 04 00 00       	call   f0107d56 <check_fault_va>
f0107863:	83 c4 10             	add    $0x10,%esp
			struct Frame_Info* ptr_frame_info;
			int i = 0;
f0107866:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			int inx = -1, max_time = -1;
f010786d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
f0107874:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)

			// loop to get min time_stamp
			for (; i < curenv->page_WS_max_size; i++) {
f010787b:	eb 64                	jmp    f01078e1 <page_fault_handler+0x152>
				if (i == 0) {
f010787d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107881:	75 20                	jne    f01078a3 <page_fault_handler+0x114>
					max_time = curenv->ptr_pageWorkingSet[i].time_stamp;
f0107883:	8b 45 08             	mov    0x8(%ebp),%eax
f0107886:	8b 48 78             	mov    0x78(%eax),%ecx
f0107889:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010788c:	89 d0                	mov    %edx,%eax
f010788e:	01 c0                	add    %eax,%eax
f0107890:	01 d0                	add    %edx,%eax
f0107892:	c1 e0 02             	shl    $0x2,%eax
f0107895:	01 c8                	add    %ecx,%eax
f0107897:	8b 40 08             	mov    0x8(%eax),%eax
f010789a:	89 45 e8             	mov    %eax,-0x18(%ebp)
					inx = i;
f010789d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
				}

				if (env_page_ws_get_time_stamp(curenv, i) < max_time) {
f01078a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078a6:	83 ec 08             	sub    $0x8,%esp
f01078a9:	50                   	push   %eax
f01078aa:	ff 75 08             	pushl  0x8(%ebp)
f01078ad:	e8 63 bf ff ff       	call   f0103815 <env_page_ws_get_time_stamp>
f01078b2:	83 c4 10             	add    $0x10,%esp
f01078b5:	89 c2                	mov    %eax,%edx
f01078b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01078ba:	39 c2                	cmp    %eax,%edx
f01078bc:	73 20                	jae    f01078de <page_fault_handler+0x14f>
					inx = i;
f01078be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
					max_time = curenv->ptr_pageWorkingSet[i].time_stamp;
f01078c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01078c7:	8b 48 78             	mov    0x78(%eax),%ecx
f01078ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01078cd:	89 d0                	mov    %edx,%eax
f01078cf:	01 c0                	add    %eax,%eax
f01078d1:	01 d0                	add    %edx,%eax
f01078d3:	c1 e0 02             	shl    $0x2,%eax
f01078d6:	01 c8                	add    %ecx,%eax
f01078d8:	8b 40 08             	mov    0x8(%eax),%eax
f01078db:	89 45 e8             	mov    %eax,-0x18(%ebp)
			struct Frame_Info* ptr_frame_info;
			int i = 0;
			int inx = -1, max_time = -1;

			// loop to get min time_stamp
			for (; i < curenv->page_WS_max_size; i++) {
f01078de:	ff 45 f0             	incl   -0x10(%ebp)
f01078e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01078e4:	8b 50 74             	mov    0x74(%eax),%edx
f01078e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078ea:	39 c2                	cmp    %eax,%edx
f01078ec:	77 8f                	ja     f010787d <page_fault_handler+0xee>

				}

			}

			curenv->page_last_WS_index = inx + 1;
f01078ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01078f1:	40                   	inc    %eax
f01078f2:	89 c2                	mov    %eax,%edx
f01078f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01078f7:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)

			uint32 *ptr_page_table = NULL;
f01078fd:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)

			//Check if modified or not to update it in pf
			uint32 page_permissions = pt_get_page_permissions(curenv,
					curenv->ptr_pageWorkingSet[inx].virtual_address);
f0107904:	8b 45 08             	mov    0x8(%ebp),%eax
f0107907:	8b 48 78             	mov    0x78(%eax),%ecx
f010790a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010790d:	89 d0                	mov    %edx,%eax
f010790f:	01 c0                	add    %eax,%eax
f0107911:	01 d0                	add    %edx,%eax
f0107913:	c1 e0 02             	shl    $0x2,%eax
f0107916:	01 c8                	add    %ecx,%eax
			curenv->page_last_WS_index = inx + 1;

			uint32 *ptr_page_table = NULL;

			//Check if modified or not to update it in pf
			uint32 page_permissions = pt_get_page_permissions(curenv,
f0107918:	8b 00                	mov    (%eax),%eax
f010791a:	83 ec 08             	sub    $0x8,%esp
f010791d:	50                   	push   %eax
f010791e:	ff 75 08             	pushl  0x8(%ebp)
f0107921:	e8 f5 c9 ff ff       	call   f010431b <pt_get_page_permissions>
f0107926:	83 c4 10             	add    $0x10,%esp
f0107929:	89 45 d8             	mov    %eax,-0x28(%ebp)
					curenv->ptr_pageWorkingSet[inx].virtual_address);
			if (page_permissions & PERM_MODIFIED) {
f010792c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010792f:	83 e0 40             	and    $0x40,%eax
f0107932:	85 c0                	test   %eax,%eax
f0107934:	74 5d                	je     f0107993 <page_fault_handler+0x204>

				ptr_frame_info = get_frame_info(
						curenv->env_page_directory,
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
f0107936:	8b 45 08             	mov    0x8(%ebp),%eax
f0107939:	8b 48 78             	mov    0x78(%eax),%ecx
f010793c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010793f:	89 d0                	mov    %edx,%eax
f0107941:	01 c0                	add    %eax,%eax
f0107943:	01 d0                	add    %edx,%eax
f0107945:	c1 e0 02             	shl    $0x2,%eax
f0107948:	01 c8                	add    %ecx,%eax
f010794a:	8b 00                	mov    (%eax),%eax
			//Check if modified or not to update it in pf
			uint32 page_permissions = pt_get_page_permissions(curenv,
					curenv->ptr_pageWorkingSet[inx].virtual_address);
			if (page_permissions & PERM_MODIFIED) {

				ptr_frame_info = get_frame_info(
f010794c:	89 c1                	mov    %eax,%ecx
f010794e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107951:	8b 40 5c             	mov    0x5c(%eax),%eax
f0107954:	83 ec 04             	sub    $0x4,%esp
f0107957:	8d 55 b0             	lea    -0x50(%ebp),%edx
f010795a:	52                   	push   %edx
f010795b:	51                   	push   %ecx
f010795c:	50                   	push   %eax
f010795d:	e8 f8 b6 ff ff       	call   f010305a <get_frame_info>
f0107962:	83 c4 10             	add    $0x10,%esp
f0107965:	89 45 d4             	mov    %eax,-0x2c(%ebp)
						curenv->env_page_directory,
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
						&ptr_page_table);

				int r = pf_update_env_page(curenv,
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
f0107968:	8b 45 08             	mov    0x8(%ebp),%eax
f010796b:	8b 48 78             	mov    0x78(%eax),%ecx
f010796e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107971:	89 d0                	mov    %edx,%eax
f0107973:	01 c0                	add    %eax,%eax
f0107975:	01 d0                	add    %edx,%eax
f0107977:	c1 e0 02             	shl    $0x2,%eax
f010797a:	01 c8                	add    %ecx,%eax
f010797c:	8b 00                	mov    (%eax),%eax
				ptr_frame_info = get_frame_info(
						curenv->env_page_directory,
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
						&ptr_page_table);

				int r = pf_update_env_page(curenv,
f010797e:	83 ec 04             	sub    $0x4,%esp
f0107981:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107984:	50                   	push   %eax
f0107985:	ff 75 08             	pushl  0x8(%ebp)
f0107988:	e8 1c 29 00 00       	call   f010a2a9 <pf_update_env_page>
f010798d:	83 c4 10             	add    $0x10,%esp
f0107990:	89 45 d0             	mov    %eax,-0x30(%ebp)
				}

			}

			unmap_frame(curenv->env_page_directory,
					(void*) curenv->ptr_pageWorkingSet[inx].virtual_address);
f0107993:	8b 45 08             	mov    0x8(%ebp),%eax
f0107996:	8b 48 78             	mov    0x78(%eax),%ecx
f0107999:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010799c:	89 d0                	mov    %edx,%eax
f010799e:	01 c0                	add    %eax,%eax
f01079a0:	01 d0                	add    %edx,%eax
f01079a2:	c1 e0 02             	shl    $0x2,%eax
f01079a5:	01 c8                	add    %ecx,%eax
f01079a7:	8b 00                	mov    (%eax),%eax
				//			"\n the page that you are need to update isn't exist in pf \n");
				}

			}

			unmap_frame(curenv->env_page_directory,
f01079a9:	89 c2                	mov    %eax,%edx
f01079ab:	8b 45 08             	mov    0x8(%ebp),%eax
f01079ae:	8b 40 5c             	mov    0x5c(%eax),%eax
f01079b1:	83 ec 08             	sub    $0x8,%esp
f01079b4:	52                   	push   %edx
f01079b5:	50                   	push   %eax
f01079b6:	e8 0f b7 ff ff       	call   f01030ca <unmap_frame>
f01079bb:	83 c4 10             	add    $0x10,%esp
					(void*) curenv->ptr_pageWorkingSet[inx].virtual_address);
			env_page_ws_clear_entry(curenv, inx);
f01079be:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01079c1:	83 ec 08             	sub    $0x8,%esp
f01079c4:	50                   	push   %eax
f01079c5:	ff 75 08             	pushl  0x8(%ebp)
f01079c8:	e8 81 bd ff ff       	call   f010374e <env_page_ws_clear_entry>
f01079cd:	83 c4 10             	add    $0x10,%esp
			env_page_ws_set_entry(curenv, inx, fault_va);
f01079d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01079d3:	83 ec 04             	sub    $0x4,%esp
f01079d6:	ff 75 0c             	pushl  0xc(%ebp)
f01079d9:	50                   	push   %eax
f01079da:	ff 75 08             	pushl  0x8(%ebp)
f01079dd:	e8 c5 bc ff ff       	call   f01036a7 <env_page_ws_set_entry>
f01079e2:	83 c4 10             	add    $0x10,%esp
		}

	}

	//TODO: [PROJECT 2016 - BONUS3] Apply FIFO and modifiedCLOCK algorithms
}
f01079e5:	e9 69 03 00 00       	jmp    f0107d53 <page_fault_handler+0x5c4>
			unmap_frame(curenv->env_page_directory,
					(void*) curenv->ptr_pageWorkingSet[inx].virtual_address);
			env_page_ws_clear_entry(curenv, inx);
			env_page_ws_set_entry(curenv, inx, fault_va);

		} else if (isPageReplacmentAlgorithmCLOCK()) {
f01079ea:	e8 a5 fb ff ff       	call   f0107594 <isPageReplacmentAlgorithmCLOCK>
f01079ef:	85 c0                	test   %eax,%eax
f01079f1:	0f 84 5c 03 00 00    	je     f0107d53 <page_fault_handler+0x5c4>


			check_fault_va(curenv, fault_va);
f01079f7:	83 ec 08             	sub    $0x8,%esp
f01079fa:	ff 75 0c             	pushl  0xc(%ebp)
f01079fd:	ff 75 08             	pushl  0x8(%ebp)
f0107a00:	e8 51 03 00 00       	call   f0107d56 <check_fault_va>
f0107a05:	83 c4 10             	add    $0x10,%esp

			struct Frame_Info* ptr_frame_info ;
			//check for given page in WS
			int i = 0;
f0107a08:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			int inx = -1, found_pf = 0;
f0107a0f:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
f0107a16:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

			for (; i < curenv->page_WS_max_size; i++) {
f0107a1d:	eb 2b                	jmp    f0107a4a <page_fault_handler+0x2bb>
				if (curenv->ptr_pageWorkingSet[i].virtual_address
f0107a1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a22:	8b 48 78             	mov    0x78(%eax),%ecx
f0107a25:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107a28:	89 d0                	mov    %edx,%eax
f0107a2a:	01 c0                	add    %eax,%eax
f0107a2c:	01 d0                	add    %edx,%eax
f0107a2e:	c1 e0 02             	shl    $0x2,%eax
f0107a31:	01 c8                	add    %ecx,%eax
f0107a33:	8b 00                	mov    (%eax),%eax
f0107a35:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0107a38:	75 0d                	jne    f0107a47 <page_fault_handler+0x2b8>
						== (unsigned int) fault_va) {

					inx = i;
f0107a3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107a3d:	89 45 e0             	mov    %eax,-0x20(%ebp)
					found_pf = 1;
f0107a40:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			struct Frame_Info* ptr_frame_info ;
			//check for given page in WS
			int i = 0;
			int inx = -1, found_pf = 0;

			for (; i < curenv->page_WS_max_size; i++) {
f0107a47:	ff 45 e4             	incl   -0x1c(%ebp)
f0107a4a:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a4d:	8b 50 74             	mov    0x74(%eax),%edx
f0107a50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107a53:	39 c2                	cmp    %eax,%edx
f0107a55:	77 c8                	ja     f0107a1f <page_fault_handler+0x290>

				}

			}
			//if found el page set uesdbit=1 and indx
			if (found_pf) {
f0107a57:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107a5b:	0f 84 0b 01 00 00    	je     f0107b6c <page_fault_handler+0x3dd>

				uint32 *ptr_page_table = NULL;
f0107a61:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
				//Check if modified or not to update it in pf
				uint32 page_permissions = pt_get_page_permissions(curenv,
						curenv->ptr_pageWorkingSet[inx].virtual_address);
f0107a68:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6b:	8b 48 78             	mov    0x78(%eax),%ecx
f0107a6e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107a71:	89 d0                	mov    %edx,%eax
f0107a73:	01 c0                	add    %eax,%eax
f0107a75:	01 d0                	add    %edx,%eax
f0107a77:	c1 e0 02             	shl    $0x2,%eax
f0107a7a:	01 c8                	add    %ecx,%eax
			//if found el page set uesdbit=1 and indx
			if (found_pf) {

				uint32 *ptr_page_table = NULL;
				//Check if modified or not to update it in pf
				uint32 page_permissions = pt_get_page_permissions(curenv,
f0107a7c:	8b 00                	mov    (%eax),%eax
f0107a7e:	83 ec 08             	sub    $0x8,%esp
f0107a81:	50                   	push   %eax
f0107a82:	ff 75 08             	pushl  0x8(%ebp)
f0107a85:	e8 91 c8 ff ff       	call   f010431b <pt_get_page_permissions>
f0107a8a:	83 c4 10             	add    $0x10,%esp
f0107a8d:	89 45 cc             	mov    %eax,-0x34(%ebp)
						curenv->ptr_pageWorkingSet[inx].virtual_address);
				if (page_permissions & PERM_MODIFIED) {
f0107a90:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107a93:	83 e0 40             	and    $0x40,%eax
f0107a96:	85 c0                	test   %eax,%eax
f0107a98:	74 5d                	je     f0107af7 <page_fault_handler+0x368>

					ptr_frame_info =
							get_frame_info(curenv->env_page_directory,
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
f0107a9a:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a9d:	8b 48 78             	mov    0x78(%eax),%ecx
f0107aa0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107aa3:	89 d0                	mov    %edx,%eax
f0107aa5:	01 c0                	add    %eax,%eax
f0107aa7:	01 d0                	add    %edx,%eax
f0107aa9:	c1 e0 02             	shl    $0x2,%eax
f0107aac:	01 c8                	add    %ecx,%eax
f0107aae:	8b 00                	mov    (%eax),%eax
				uint32 page_permissions = pt_get_page_permissions(curenv,
						curenv->ptr_pageWorkingSet[inx].virtual_address);
				if (page_permissions & PERM_MODIFIED) {

					ptr_frame_info =
							get_frame_info(curenv->env_page_directory,
f0107ab0:	89 c1                	mov    %eax,%ecx
f0107ab2:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ab5:	8b 40 5c             	mov    0x5c(%eax),%eax
				//Check if modified or not to update it in pf
				uint32 page_permissions = pt_get_page_permissions(curenv,
						curenv->ptr_pageWorkingSet[inx].virtual_address);
				if (page_permissions & PERM_MODIFIED) {

					ptr_frame_info =
f0107ab8:	83 ec 04             	sub    $0x4,%esp
f0107abb:	8d 55 ac             	lea    -0x54(%ebp),%edx
f0107abe:	52                   	push   %edx
f0107abf:	51                   	push   %ecx
f0107ac0:	50                   	push   %eax
f0107ac1:	e8 94 b5 ff ff       	call   f010305a <get_frame_info>
f0107ac6:	83 c4 10             	add    $0x10,%esp
f0107ac9:	89 45 c8             	mov    %eax,-0x38(%ebp)
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
									&ptr_page_table);

					int r =
							pf_update_env_page(curenv,
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
f0107acc:	8b 45 08             	mov    0x8(%ebp),%eax
f0107acf:	8b 48 78             	mov    0x78(%eax),%ecx
f0107ad2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107ad5:	89 d0                	mov    %edx,%eax
f0107ad7:	01 c0                	add    %eax,%eax
f0107ad9:	01 d0                	add    %edx,%eax
f0107adb:	c1 e0 02             	shl    $0x2,%eax
f0107ade:	01 c8                	add    %ecx,%eax
f0107ae0:	8b 00                	mov    (%eax),%eax
					ptr_frame_info =
							get_frame_info(curenv->env_page_directory,
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
									&ptr_page_table);

					int r =
f0107ae2:	83 ec 04             	sub    $0x4,%esp
f0107ae5:	ff 75 c8             	pushl  -0x38(%ebp)
f0107ae8:	50                   	push   %eax
f0107ae9:	ff 75 08             	pushl  0x8(%ebp)
f0107aec:	e8 b8 27 00 00       	call   f010a2a9 <pf_update_env_page>
f0107af1:	83 c4 10             	add    $0x10,%esp
f0107af4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					}

				}

				unmap_frame(curenv->env_page_directory,
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address);
f0107af7:	8b 45 08             	mov    0x8(%ebp),%eax
f0107afa:	8b 48 78             	mov    0x78(%eax),%ecx
f0107afd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107b00:	89 d0                	mov    %edx,%eax
f0107b02:	01 c0                	add    %eax,%eax
f0107b04:	01 d0                	add    %edx,%eax
f0107b06:	c1 e0 02             	shl    $0x2,%eax
f0107b09:	01 c8                	add    %ecx,%eax
f0107b0b:	8b 00                	mov    (%eax),%eax
							//	"\n the page that you are need to update isn't exist in pf \n");
					}

				}

				unmap_frame(curenv->env_page_directory,
f0107b0d:	89 c2                	mov    %eax,%edx
f0107b0f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b12:	8b 40 5c             	mov    0x5c(%eax),%eax
f0107b15:	83 ec 08             	sub    $0x8,%esp
f0107b18:	52                   	push   %edx
f0107b19:	50                   	push   %eax
f0107b1a:	e8 ab b5 ff ff       	call   f01030ca <unmap_frame>
f0107b1f:	83 c4 10             	add    $0x10,%esp
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address);
				env_page_ws_clear_entry(curenv, inx);
f0107b22:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107b25:	83 ec 08             	sub    $0x8,%esp
f0107b28:	50                   	push   %eax
f0107b29:	ff 75 08             	pushl  0x8(%ebp)
f0107b2c:	e8 1d bc ff ff       	call   f010374e <env_page_ws_clear_entry>
f0107b31:	83 c4 10             	add    $0x10,%esp
				env_page_ws_set_entry(curenv, inx, fault_va);
f0107b34:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107b37:	83 ec 04             	sub    $0x4,%esp
f0107b3a:	ff 75 0c             	pushl  0xc(%ebp)
f0107b3d:	50                   	push   %eax
f0107b3e:	ff 75 08             	pushl  0x8(%ebp)
f0107b41:	e8 61 bb ff ff       	call   f01036a7 <env_page_ws_set_entry>
f0107b46:	83 c4 10             	add    $0x10,%esp
				//pointer indicate to it and set usebit =1
				curenv->page_last_WS_index = inx;
f0107b49:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107b4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b4f:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)
				pt_set_page_permissions(curenv, fault_va, PERM_USED, 0);
f0107b55:	6a 00                	push   $0x0
f0107b57:	6a 20                	push   $0x20
f0107b59:	ff 75 0c             	pushl  0xc(%ebp)
f0107b5c:	ff 75 08             	pushl  0x8(%ebp)
f0107b5f:	e8 53 c4 ff ff       	call   f0103fb7 <pt_set_page_permissions>
f0107b64:	83 c4 10             	add    $0x10,%esp
		}

	}

	//TODO: [PROJECT 2016 - BONUS3] Apply FIFO and modifiedCLOCK algorithms
}
f0107b67:	e9 e7 01 00 00       	jmp    f0107d53 <page_fault_handler+0x5c4>

			} else {

				while (1 == 1) {

					if (curenv->page_last_WS_index
f0107b6c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b6f:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
							>= curenv->page_WS_max_size) {
f0107b75:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b78:	8b 40 74             	mov    0x74(%eax),%eax

			} else {

				while (1 == 1) {

					if (curenv->page_last_WS_index
f0107b7b:	39 c2                	cmp    %eax,%edx
f0107b7d:	72 0d                	jb     f0107b8c <page_fault_handler+0x3fd>
							>= curenv->page_WS_max_size) {
						curenv->page_last_WS_index = 0;
f0107b7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b82:	c7 80 d4 02 00 00 00 	movl   $0x0,0x2d4(%eax)
f0107b89:	00 00 00 
					}

					// CHECK if the usebit if 0 set it by 1 and inc inx else set it 0 and loop again
					uint32 page_permissions =
							pt_get_page_permissions(curenv,
									curenv->ptr_pageWorkingSet[curenv->page_last_WS_index].virtual_address);
f0107b8c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b8f:	8b 48 78             	mov    0x78(%eax),%ecx
f0107b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0107b95:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f0107b9b:	89 d0                	mov    %edx,%eax
f0107b9d:	01 c0                	add    %eax,%eax
f0107b9f:	01 d0                	add    %edx,%eax
f0107ba1:	c1 e0 02             	shl    $0x2,%eax
f0107ba4:	01 c8                	add    %ecx,%eax
						curenv->page_last_WS_index = 0;
					}

					// CHECK if the usebit if 0 set it by 1 and inc inx else set it 0 and loop again
					uint32 page_permissions =
							pt_get_page_permissions(curenv,
f0107ba6:	8b 00                	mov    (%eax),%eax
							>= curenv->page_WS_max_size) {
						curenv->page_last_WS_index = 0;
					}

					// CHECK if the usebit if 0 set it by 1 and inc inx else set it 0 and loop again
					uint32 page_permissions =
f0107ba8:	83 ec 08             	sub    $0x8,%esp
f0107bab:	50                   	push   %eax
f0107bac:	ff 75 08             	pushl  0x8(%ebp)
f0107baf:	e8 67 c7 ff ff       	call   f010431b <pt_get_page_permissions>
f0107bb4:	83 c4 10             	add    $0x10,%esp
f0107bb7:	89 45 c0             	mov    %eax,-0x40(%ebp)
							pt_get_page_permissions(curenv,
									curenv->ptr_pageWorkingSet[curenv->page_last_WS_index].virtual_address);

					if (page_permissions & PERM_USED) {
f0107bba:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0107bbd:	83 e0 20             	and    $0x20,%eax
f0107bc0:	85 c0                	test   %eax,%eax
f0107bc2:	74 46                	je     f0107c0a <page_fault_handler+0x47b>

						pt_set_page_permissions(curenv,
								curenv->ptr_pageWorkingSet[curenv->page_last_WS_index].virtual_address,
f0107bc4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107bc7:	8b 48 78             	mov    0x78(%eax),%ecx
f0107bca:	8b 45 08             	mov    0x8(%ebp),%eax
f0107bcd:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f0107bd3:	89 d0                	mov    %edx,%eax
f0107bd5:	01 c0                	add    %eax,%eax
f0107bd7:	01 d0                	add    %edx,%eax
f0107bd9:	c1 e0 02             	shl    $0x2,%eax
f0107bdc:	01 c8                	add    %ecx,%eax
							pt_get_page_permissions(curenv,
									curenv->ptr_pageWorkingSet[curenv->page_last_WS_index].virtual_address);

					if (page_permissions & PERM_USED) {

						pt_set_page_permissions(curenv,
f0107bde:	8b 00                	mov    (%eax),%eax
f0107be0:	6a 20                	push   $0x20
f0107be2:	6a 00                	push   $0x0
f0107be4:	50                   	push   %eax
f0107be5:	ff 75 08             	pushl  0x8(%ebp)
f0107be8:	e8 ca c3 ff ff       	call   f0103fb7 <pt_set_page_permissions>
f0107bed:	83 c4 10             	add    $0x10,%esp
								curenv->ptr_pageWorkingSet[curenv->page_last_WS_index].virtual_address,
								0, PERM_USED);
						curenv->page_last_WS_index++;
f0107bf0:	8b 45 08             	mov    0x8(%ebp),%eax
f0107bf3:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f0107bf9:	8d 50 01             	lea    0x1(%eax),%edx
f0107bfc:	8b 45 08             	mov    0x8(%ebp),%eax
f0107bff:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)
f0107c05:	e9 62 ff ff ff       	jmp    f0107b6c <page_fault_handler+0x3dd>

					} else {
						// pt_set_page_permissions(curenv, (void*)curenv->ptr_pageWorkingSet[inx].virtual_address, PERM_USED, 0);
						curenv->page_last_WS_index++;
f0107c0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c0d:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f0107c13:	8d 50 01             	lea    0x1(%eax),%edx
f0107c16:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c19:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)

						break;
f0107c1f:	90                   	nop
					}

				}

				inx = curenv->page_last_WS_index - 1;
f0107c20:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c23:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
f0107c29:	48                   	dec    %eax
f0107c2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
				if (curenv->page_last_WS_index >= curenv->page_WS_max_size) {
f0107c2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c30:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
f0107c36:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c39:	8b 40 74             	mov    0x74(%eax),%eax
f0107c3c:	39 c2                	cmp    %eax,%edx
f0107c3e:	72 0d                	jb     f0107c4d <page_fault_handler+0x4be>
					curenv->page_last_WS_index = 0;
f0107c40:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c43:	c7 80 d4 02 00 00 00 	movl   $0x0,0x2d4(%eax)
f0107c4a:	00 00 00 
				}
				uint32 *ptr_page_table = NULL;
f0107c4d:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)

				//Check if modified or not to update it in pf
				uint32 page_permissions = pt_get_page_permissions(curenv,
						curenv->ptr_pageWorkingSet[inx].virtual_address);
f0107c54:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c57:	8b 48 78             	mov    0x78(%eax),%ecx
f0107c5a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107c5d:	89 d0                	mov    %edx,%eax
f0107c5f:	01 c0                	add    %eax,%eax
f0107c61:	01 d0                	add    %edx,%eax
f0107c63:	c1 e0 02             	shl    $0x2,%eax
f0107c66:	01 c8                	add    %ecx,%eax
					curenv->page_last_WS_index = 0;
				}
				uint32 *ptr_page_table = NULL;

				//Check if modified or not to update it in pf
				uint32 page_permissions = pt_get_page_permissions(curenv,
f0107c68:	8b 00                	mov    (%eax),%eax
f0107c6a:	83 ec 08             	sub    $0x8,%esp
f0107c6d:	50                   	push   %eax
f0107c6e:	ff 75 08             	pushl  0x8(%ebp)
f0107c71:	e8 a5 c6 ff ff       	call   f010431b <pt_get_page_permissions>
f0107c76:	83 c4 10             	add    $0x10,%esp
f0107c79:	89 45 bc             	mov    %eax,-0x44(%ebp)
						curenv->ptr_pageWorkingSet[inx].virtual_address);
				if (page_permissions & PERM_MODIFIED) {
f0107c7c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0107c7f:	83 e0 40             	and    $0x40,%eax
f0107c82:	85 c0                	test   %eax,%eax
f0107c84:	74 5d                	je     f0107ce3 <page_fault_handler+0x554>

					ptr_frame_info =
							get_frame_info(curenv->env_page_directory,
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
f0107c86:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c89:	8b 48 78             	mov    0x78(%eax),%ecx
f0107c8c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107c8f:	89 d0                	mov    %edx,%eax
f0107c91:	01 c0                	add    %eax,%eax
f0107c93:	01 d0                	add    %edx,%eax
f0107c95:	c1 e0 02             	shl    $0x2,%eax
f0107c98:	01 c8                	add    %ecx,%eax
f0107c9a:	8b 00                	mov    (%eax),%eax
				uint32 page_permissions = pt_get_page_permissions(curenv,
						curenv->ptr_pageWorkingSet[inx].virtual_address);
				if (page_permissions & PERM_MODIFIED) {

					ptr_frame_info =
							get_frame_info(curenv->env_page_directory,
f0107c9c:	89 c1                	mov    %eax,%ecx
f0107c9e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ca1:	8b 40 5c             	mov    0x5c(%eax),%eax
				//Check if modified or not to update it in pf
				uint32 page_permissions = pt_get_page_permissions(curenv,
						curenv->ptr_pageWorkingSet[inx].virtual_address);
				if (page_permissions & PERM_MODIFIED) {

					ptr_frame_info =
f0107ca4:	83 ec 04             	sub    $0x4,%esp
f0107ca7:	8d 55 a8             	lea    -0x58(%ebp),%edx
f0107caa:	52                   	push   %edx
f0107cab:	51                   	push   %ecx
f0107cac:	50                   	push   %eax
f0107cad:	e8 a8 b3 ff ff       	call   f010305a <get_frame_info>
f0107cb2:	83 c4 10             	add    $0x10,%esp
f0107cb5:	89 45 c8             	mov    %eax,-0x38(%ebp)
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
									&ptr_page_table);

					int r =
							pf_update_env_page(curenv,
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
f0107cb8:	8b 45 08             	mov    0x8(%ebp),%eax
f0107cbb:	8b 48 78             	mov    0x78(%eax),%ecx
f0107cbe:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107cc1:	89 d0                	mov    %edx,%eax
f0107cc3:	01 c0                	add    %eax,%eax
f0107cc5:	01 d0                	add    %edx,%eax
f0107cc7:	c1 e0 02             	shl    $0x2,%eax
f0107cca:	01 c8                	add    %ecx,%eax
f0107ccc:	8b 00                	mov    (%eax),%eax
					ptr_frame_info =
							get_frame_info(curenv->env_page_directory,
									(void*) curenv->ptr_pageWorkingSet[inx].virtual_address,
									&ptr_page_table);

					int r =
f0107cce:	83 ec 04             	sub    $0x4,%esp
f0107cd1:	ff 75 c8             	pushl  -0x38(%ebp)
f0107cd4:	50                   	push   %eax
f0107cd5:	ff 75 08             	pushl  0x8(%ebp)
f0107cd8:	e8 cc 25 00 00       	call   f010a2a9 <pf_update_env_page>
f0107cdd:	83 c4 10             	add    $0x10,%esp
f0107ce0:	89 45 b8             	mov    %eax,-0x48(%ebp)
					}

				}

				unmap_frame(curenv->env_page_directory,
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address);
f0107ce3:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ce6:	8b 48 78             	mov    0x78(%eax),%ecx
f0107ce9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107cec:	89 d0                	mov    %edx,%eax
f0107cee:	01 c0                	add    %eax,%eax
f0107cf0:	01 d0                	add    %edx,%eax
f0107cf2:	c1 e0 02             	shl    $0x2,%eax
f0107cf5:	01 c8                	add    %ecx,%eax
f0107cf7:	8b 00                	mov    (%eax),%eax
							//	"\n the page that you are need to update isn't exist in pf \n");
					}

				}

				unmap_frame(curenv->env_page_directory,
f0107cf9:	89 c2                	mov    %eax,%edx
f0107cfb:	8b 45 08             	mov    0x8(%ebp),%eax
f0107cfe:	8b 40 5c             	mov    0x5c(%eax),%eax
f0107d01:	83 ec 08             	sub    $0x8,%esp
f0107d04:	52                   	push   %edx
f0107d05:	50                   	push   %eax
f0107d06:	e8 bf b3 ff ff       	call   f01030ca <unmap_frame>
f0107d0b:	83 c4 10             	add    $0x10,%esp
						(void*) curenv->ptr_pageWorkingSet[inx].virtual_address);
				env_page_ws_clear_entry(curenv, inx);
f0107d0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d11:	83 ec 08             	sub    $0x8,%esp
f0107d14:	50                   	push   %eax
f0107d15:	ff 75 08             	pushl  0x8(%ebp)
f0107d18:	e8 31 ba ff ff       	call   f010374e <env_page_ws_clear_entry>
f0107d1d:	83 c4 10             	add    $0x10,%esp
				env_page_ws_set_entry(curenv, inx, fault_va);
f0107d20:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d23:	83 ec 04             	sub    $0x4,%esp
f0107d26:	ff 75 0c             	pushl  0xc(%ebp)
f0107d29:	50                   	push   %eax
f0107d2a:	ff 75 08             	pushl  0x8(%ebp)
f0107d2d:	e8 75 b9 ff ff       	call   f01036a7 <env_page_ws_set_entry>
f0107d32:	83 c4 10             	add    $0x10,%esp
				//pointer indicate to it and set usebit =1
				pt_set_page_permissions(curenv, fault_va,
f0107d35:	6a 00                	push   $0x0
f0107d37:	6a 20                	push   $0x20
f0107d39:	ff 75 0c             	pushl  0xc(%ebp)
f0107d3c:	ff 75 08             	pushl  0x8(%ebp)
f0107d3f:	e8 73 c2 ff ff       	call   f0103fb7 <pt_set_page_permissions>
f0107d44:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0107d47:	0f 20 d8             	mov    %cr3,%eax
f0107d4a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0107d4d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0107d50:	0f 22 d8             	mov    %eax,%cr3
		}

	}

	//TODO: [PROJECT 2016 - BONUS3] Apply FIFO and modifiedCLOCK algorithms
}
f0107d53:	90                   	nop
f0107d54:	c9                   	leave  
f0107d55:	c3                   	ret    

f0107d56 <check_fault_va>:
void check_fault_va(struct Env * curenv, uint32 fault_va) {
f0107d56:	55                   	push   %ebp
f0107d57:	89 e5                	mov    %esp,%ebp
f0107d59:	83 ec 18             	sub    $0x18,%esp

	struct Frame_Info*ptr_frame_info;
	int ret = allocate_frame(&ptr_frame_info);
f0107d5c:	83 ec 0c             	sub    $0xc,%esp
f0107d5f:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0107d62:	50                   	push   %eax
f0107d63:	e8 30 ae ff ff       	call   f0102b98 <allocate_frame>
f0107d68:	83 c4 10             	add    $0x10,%esp
f0107d6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ret == E_NO_MEM)
f0107d6e:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f0107d72:	0f 84 a6 00 00 00    	je     f0107e1e <check_fault_va+0xc8>
		return;
	map_frame(curenv->env_page_directory, ptr_frame_info, (void*) fault_va,
f0107d78:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0107d7b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107d7e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d81:	8b 40 5c             	mov    0x5c(%eax),%eax
f0107d84:	6a 06                	push   $0x6
f0107d86:	51                   	push   %ecx
f0107d87:	52                   	push   %edx
f0107d88:	50                   	push   %eax
f0107d89:	e8 0d b2 ff ff       	call   f0102f9b <map_frame>
f0107d8e:	83 c4 10             	add    $0x10,%esp
	PERM_USER | PERM_WRITEABLE);


	 ret = pf_read_env_page(curenv, (void*) fault_va);
f0107d91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107d94:	83 ec 08             	sub    $0x8,%esp
f0107d97:	50                   	push   %eax
f0107d98:	ff 75 08             	pushl  0x8(%ebp)
f0107d9b:	e8 08 26 00 00       	call   f010a3a8 <pf_read_env_page>
f0107da0:	83 c4 10             	add    $0x10,%esp
f0107da3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ret == E_PAGE_NOT_EXIST_IN_PF) {
f0107da6:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%ebp)
f0107daa:	75 73                	jne    f0107e1f <check_fault_va+0xc9>
		if (fault_va < USTACKTOP && fault_va >= USTACKBOTTOM) {
f0107dac:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f0107db3:	77 3c                	ja     f0107df1 <check_fault_va+0x9b>
f0107db5:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107dbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107dbf:	2d 01 f0 fc 5f       	sub    $0x5ffcf001,%eax
f0107dc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107dc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107dca:	ba 00 00 00 00       	mov    $0x0,%edx
f0107dcf:	f7 75 f0             	divl   -0x10(%ebp)
f0107dd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107dd5:	29 d0                	sub    %edx,%eax
f0107dd7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0107dda:	77 15                	ja     f0107df1 <check_fault_va+0x9b>
			pf_add_empty_env_page(curenv, fault_va, 0);
f0107ddc:	83 ec 04             	sub    $0x4,%esp
f0107ddf:	6a 00                	push   $0x0
f0107de1:	ff 75 0c             	pushl  0xc(%ebp)
f0107de4:	ff 75 08             	pushl  0x8(%ebp)
f0107de7:	e8 20 23 00 00       	call   f010a10c <pf_add_empty_env_page>
f0107dec:	83 c4 10             	add    $0x10,%esp
f0107def:	eb 2e                	jmp    f0107e1f <check_fault_va+0xc9>

		} else {


			unmap_frame(curenv->env_page_directory,(void*) fault_va);
f0107df1:	8b 55 0c             	mov    0xc(%ebp),%edx
f0107df4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107df7:	8b 40 5c             	mov    0x5c(%eax),%eax
f0107dfa:	83 ec 08             	sub    $0x8,%esp
f0107dfd:	52                   	push   %edx
f0107dfe:	50                   	push   %eax
f0107dff:	e8 c6 b2 ff ff       	call   f01030ca <unmap_frame>
f0107e04:	83 c4 10             	add    $0x10,%esp
			panic(
f0107e07:	83 ec 04             	sub    $0x4,%esp
f0107e0a:	68 98 18 11 f0       	push   $0xf0111898
f0107e0f:	68 6c 02 00 00       	push   $0x26c
f0107e14:	68 f3 17 11 f0       	push   $0xf01117f3
f0107e19:	e8 3e 83 ff ff       	call   f010015c <_panic>
void check_fault_va(struct Env * curenv, uint32 fault_va) {

	struct Frame_Info*ptr_frame_info;
	int ret = allocate_frame(&ptr_frame_info);
	if (ret == E_NO_MEM)
		return;
f0107e1e:	90                   	nop
			return;
		}

	}

}
f0107e1f:	c9                   	leave  
f0107e20:	c3                   	ret    
f0107e21:	90                   	nop

f0107e22 <PAGE_FAULT>:

/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */

TRAPHANDLER(PAGE_FAULT, T_PGFLT)
f0107e22:	6a 0e                	push   $0xe
f0107e24:	e9 ed 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e29:	90                   	nop

f0107e2a <SYSCALL_HANDLER>:

TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)
f0107e2a:	6a 00                	push   $0x0
f0107e2c:	6a 30                	push   $0x30
f0107e2e:	e9 e3 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e33:	90                   	nop

f0107e34 <DBL_FAULT>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)
TRAPHANDLER(DBL_FAULT, T_DBLFLT)
f0107e34:	6a 08                	push   $0x8
f0107e36:	e9 db 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e3b:	90                   	nop

f0107e3c <ALL_FAULTS0>:

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)//     0		// divide error
f0107e3c:	6a 00                	push   $0x0
f0107e3e:	6a 00                	push   $0x0
f0107e40:	e9 d1 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e45:	90                   	nop

f0107e46 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )//   1		// debug exception
f0107e46:	6a 00                	push   $0x0
f0107e48:	6a 01                	push   $0x1
f0107e4a:	e9 c7 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e4f:	90                   	nop

f0107e50 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )// 2		// non-maskable interrupt
f0107e50:	6a 00                	push   $0x0
f0107e52:	6a 02                	push   $0x2
f0107e54:	e9 bd 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e59:	90                   	nop

f0107e5a <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT      )//3		// breakpoint
f0107e5a:	6a 00                	push   $0x0
f0107e5c:	6a 03                	push   $0x3
f0107e5e:	e9 b3 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e63:	90                   	nop

f0107e64 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW      )//4		// overflow
f0107e64:	6a 00                	push   $0x0
f0107e66:	6a 04                	push   $0x4
f0107e68:	e9 a9 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e6d:	90                   	nop

f0107e6e <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND      )//5		// bounds check
f0107e6e:	6a 00                	push   $0x0
f0107e70:	6a 05                	push   $0x5
f0107e72:	e9 9f 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e77:	90                   	nop

f0107e78 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP      )//6		// illegal opcode
f0107e78:	6a 00                	push   $0x0
f0107e7a:	6a 06                	push   $0x6
f0107e7c:	e9 95 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e81:	90                   	nop

f0107e82 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE     )//7		// device not available
f0107e82:	6a 00                	push   $0x0
f0107e84:	6a 07                	push   $0x7
f0107e86:	e9 8b 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e8b:	90                   	nop

f0107e8c <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS,  T_DBLFLT     8		// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS,  9   )//9	// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )//10		// invalid task switch segment
f0107e8c:	6a 0a                	push   $0xa
f0107e8e:	e9 83 00 00 00       	jmp    f0107f16 <_alltraps>
f0107e93:	90                   	nop

f0107e94 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )//11		// segment not present
f0107e94:	6a 0b                	push   $0xb
f0107e96:	eb 7e                	jmp    f0107f16 <_alltraps>

f0107e98 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )//12		// stack exception
f0107e98:	6a 0c                	push   $0xc
f0107e9a:	eb 7a                	jmp    f0107f16 <_alltraps>

f0107e9c <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )//13		// General protection fault
f0107e9c:	6a 0d                	push   $0xd
f0107e9e:	eb 76                	jmp    f0107f16 <_alltraps>

f0107ea0 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS,  T_PGFLT     14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )	//15 	// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR     )//16		// floating point error
f0107ea0:	6a 00                	push   $0x0
f0107ea2:	6a 10                	push   $0x10
f0107ea4:	eb 70                	jmp    f0107f16 <_alltraps>

f0107ea6 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )//17		// Alignment check
f0107ea6:	6a 11                	push   $0x11
f0107ea8:	eb 6c                	jmp    f0107f16 <_alltraps>

f0107eaa <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK      )//18		// machine check
f0107eaa:	6a 00                	push   $0x0
f0107eac:	6a 12                	push   $0x12
f0107eae:	eb 66                	jmp    f0107f16 <_alltraps>

f0107eb0 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )//19		// the last one
f0107eb0:	6a 00                	push   $0x0
f0107eb2:	6a 13                	push   $0x13
f0107eb4:	eb 60                	jmp    f0107f16 <_alltraps>

f0107eb6 <ALL_FAULTS32>:

TRAPHANDLER_NOEC(ALL_FAULTS32,		IRQ0_Clock      )//32 the first IRQ
f0107eb6:	6a 00                	push   $0x0
f0107eb8:	6a 20                	push   $0x20
f0107eba:	eb 5a                	jmp    f0107f16 <_alltraps>

f0107ebc <ALL_FAULTS33>:
TRAPHANDLER_NOEC(ALL_FAULTS33,		33		)//33
f0107ebc:	6a 00                	push   $0x0
f0107ebe:	6a 21                	push   $0x21
f0107ec0:	eb 54                	jmp    f0107f16 <_alltraps>

f0107ec2 <ALL_FAULTS34>:
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f0107ec2:	6a 00                	push   $0x0
f0107ec4:	6a 22                	push   $0x22
f0107ec6:	eb 4e                	jmp    f0107f16 <_alltraps>

f0107ec8 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f0107ec8:	6a 00                	push   $0x0
f0107eca:	6a 23                	push   $0x23
f0107ecc:	eb 48                	jmp    f0107f16 <_alltraps>

f0107ece <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f0107ece:	6a 00                	push   $0x0
f0107ed0:	6a 24                	push   $0x24
f0107ed2:	eb 42                	jmp    f0107f16 <_alltraps>

f0107ed4 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f0107ed4:	6a 00                	push   $0x0
f0107ed6:	6a 25                	push   $0x25
f0107ed8:	eb 3c                	jmp    f0107f16 <_alltraps>

f0107eda <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f0107eda:	6a 00                	push   $0x0
f0107edc:	6a 26                	push   $0x26
f0107ede:	eb 36                	jmp    f0107f16 <_alltraps>

f0107ee0 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f0107ee0:	6a 00                	push   $0x0
f0107ee2:	6a 27                	push   $0x27
f0107ee4:	eb 30                	jmp    f0107f16 <_alltraps>

f0107ee6 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f0107ee6:	6a 00                	push   $0x0
f0107ee8:	6a 28                	push   $0x28
f0107eea:	eb 2a                	jmp    f0107f16 <_alltraps>

f0107eec <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f0107eec:	6a 00                	push   $0x0
f0107eee:	6a 29                	push   $0x29
f0107ef0:	eb 24                	jmp    f0107f16 <_alltraps>

f0107ef2 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f0107ef2:	6a 00                	push   $0x0
f0107ef4:	6a 2a                	push   $0x2a
f0107ef6:	eb 1e                	jmp    f0107f16 <_alltraps>

f0107ef8 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f0107ef8:	6a 00                	push   $0x0
f0107efa:	6a 2b                	push   $0x2b
f0107efc:	eb 18                	jmp    f0107f16 <_alltraps>

f0107efe <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f0107efe:	6a 00                	push   $0x0
f0107f00:	6a 2c                	push   $0x2c
f0107f02:	eb 12                	jmp    f0107f16 <_alltraps>

f0107f04 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f0107f04:	6a 00                	push   $0x0
f0107f06:	6a 2d                	push   $0x2d
f0107f08:	eb 0c                	jmp    f0107f16 <_alltraps>

f0107f0a <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f0107f0a:	6a 00                	push   $0x0
f0107f0c:	6a 2e                	push   $0x2e
f0107f0e:	eb 06                	jmp    f0107f16 <_alltraps>

f0107f10 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 the last IRQ
f0107f10:	6a 00                	push   $0x0
f0107f12:	6a 2f                	push   $0x2f
f0107f14:	eb 00                	jmp    f0107f16 <_alltraps>

f0107f16 <_alltraps>:
/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:

push %ds 
f0107f16:	1e                   	push   %ds
push %es 
f0107f17:	06                   	push   %es
pushal 	
f0107f18:	60                   	pusha  

mov $(GD_KD), %ax 
f0107f19:	66 b8 10 00          	mov    $0x10,%ax
mov %ax,%ds
f0107f1d:	8e d8                	mov    %eax,%ds
mov %ax,%es
f0107f1f:	8e c0                	mov    %eax,%es

push %esp
f0107f21:	54                   	push   %esp

call trap
f0107f22:	e8 dd f4 ff ff       	call   f0107404 <trap>

pop %ecx /* poping the pointer to the tf from the stack so that the stack top is at 
f0107f27:	59                   	pop    %ecx
			# the beginning values of the registers pushed by pusha*/
popal 	
f0107f28:	61                   	popa   
pop %es 
f0107f29:	07                   	pop    %es
pop %ds    
f0107f2a:	1f                   	pop    %ds

/*skipping the trap_no and the error code so that the stack top is at the old eip value*/
add $(8),%esp
f0107f2b:	83 c4 08             	add    $0x8,%esp

iret
f0107f2e:	cf                   	iret   

f0107f2f <fos_scheduler>:

struct Env* sched_next_circular(struct Env* env);

void
fos_scheduler(void)
{
f0107f2f:	55                   	push   %ebp
f0107f30:	89 e5                	mov    %esp,%ebp
f0107f32:	83 ec 18             	sub    $0x18,%esp
	// in circular fashion starting after the previously running env,
	// and switch to the first such environment found.
	// It's OK to choose the previously running env if no other env
	// is runnable.

	scheduler_status = SCH_STARTED;
f0107f35:	c7 05 34 2a 45 f0 01 	movl   $0x1,0xf0452a34
f0107f3c:	00 00 00 
	struct Env* current_env = NULL;
f0107f3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	{
		//we have a runnable env, so update the sched pointer and run it
		current_env = sched_next;
f0107f46:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f0107f4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		sched_next = sched_next_circular(sched_next);
f0107f4e:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f0107f53:	83 ec 0c             	sub    $0xc,%esp
f0107f56:	50                   	push   %eax
f0107f57:	e8 c8 00 00 00       	call   f0108024 <sched_next_circular>
f0107f5c:	83 c4 10             	add    $0x10,%esp
f0107f5f:	a3 e8 a9 42 f0       	mov    %eax,0xf042a9e8
	}

	//cprintf("Scheduler\n");
	if(current_env != NULL)
f0107f64:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107f68:	74 0b                	je     f0107f75 <fos_scheduler+0x46>
	{
		//cprintf("sched: %s\n",current_env->prog_name);
		env_run(current_env);
f0107f6a:	83 ec 0c             	sub    $0xc,%esp
f0107f6d:	ff 75 f4             	pushl  -0xc(%ebp)
f0107f70:	e8 06 d3 ff ff       	call   f010527b <env_run>
	else //if (envs[0].env_status == ENV_RUNNABLE)
		//	env_run(&envs[0]);
		//else
	{
		/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
		curenv = NULL;
f0107f75:	c7 05 38 a1 42 f0 00 	movl   $0x0,0xf042a138
f0107f7c:	00 00 00 
		//lcr3(K_PHYSICAL_ADDRESS(ptr_page_directory));
		lcr3(phys_page_directory);
f0107f7f:	a1 98 52 45 f0       	mov    0xf0455298,%eax
f0107f84:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107f87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f8a:	0f 22 d8             	mov    %eax,%cr3

		scheduler_status = SCH_STOPPED;
f0107f8d:	c7 05 34 2a 45 f0 00 	movl   $0x0,0xf0452a34
f0107f94:	00 00 00 
		//cprintf("[sched] no envs - nothing more to do!\n");
		while (1)
			run_command_prompt(NULL);
f0107f97:	83 ec 0c             	sub    $0xc,%esp
f0107f9a:	6a 00                	push   $0x0
f0107f9c:	e8 2f 8f ff ff       	call   f0100ed0 <run_command_prompt>
f0107fa1:	83 c4 10             	add    $0x10,%esp
f0107fa4:	eb f1                	jmp    f0107f97 <fos_scheduler+0x68>

f0107fa6 <sched_init>:
	}
}
 */

void sched_init()
{
f0107fa6:	55                   	push   %ebp
f0107fa7:	89 e5                	mov    %esp,%ebp
	old_pf_counter = 0;
f0107fa9:	c7 05 24 2a 45 f0 00 	movl   $0x0,0xf0452a24
f0107fb0:	00 00 00 
	LIST_INIT(&env_ready_queue);
f0107fb3:	c7 05 bc 52 45 f0 00 	movl   $0x0,0xf04552bc
f0107fba:	00 00 00 
f0107fbd:	c7 05 c0 52 45 f0 00 	movl   $0x0,0xf04552c0
f0107fc4:	00 00 00 
f0107fc7:	c7 05 c8 52 45 f0 00 	movl   $0x0,0xf04552c8
f0107fce:	00 00 00 
	LIST_INIT(&env_new_queue);
f0107fd1:	c7 05 ac 52 45 f0 00 	movl   $0x0,0xf04552ac
f0107fd8:	00 00 00 
f0107fdb:	c7 05 b0 52 45 f0 00 	movl   $0x0,0xf04552b0
f0107fe2:	00 00 00 
f0107fe5:	c7 05 b8 52 45 f0 00 	movl   $0x0,0xf04552b8
f0107fec:	00 00 00 
	LIST_INIT(&env_exit_queue);
f0107fef:	c7 05 9c 52 45 f0 00 	movl   $0x0,0xf045529c
f0107ff6:	00 00 00 
f0107ff9:	c7 05 a0 52 45 f0 00 	movl   $0x0,0xf04552a0
f0108000:	00 00 00 
f0108003:	c7 05 a8 52 45 f0 00 	movl   $0x0,0xf04552a8
f010800a:	00 00 00 
	sched_next = NULL;
f010800d:	c7 05 e8 a9 42 f0 00 	movl   $0x0,0xf042a9e8
f0108014:	00 00 00 
	scheduler_status = SCH_STOPPED;
f0108017:	c7 05 34 2a 45 f0 00 	movl   $0x0,0xf0452a34
f010801e:	00 00 00 
}
f0108021:	90                   	nop
f0108022:	5d                   	pop    %ebp
f0108023:	c3                   	ret    

f0108024 <sched_next_circular>:


struct Env* sched_next_circular(struct Env* env)
		{
f0108024:	55                   	push   %ebp
f0108025:	89 e5                	mov    %esp,%ebp
f0108027:	83 ec 10             	sub    $0x10,%esp
	if(env == NULL) return NULL;
f010802a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010802e:	75 07                	jne    f0108037 <sched_next_circular+0x13>
f0108030:	b8 00 00 00 00       	mov    $0x0,%eax
f0108035:	eb 1a                	jmp    f0108051 <sched_next_circular+0x2d>

	struct Env* next = LIST_NEXT(env);
f0108037:	8b 45 08             	mov    0x8(%ebp),%eax
f010803a:	8b 40 44             	mov    0x44(%eax),%eax
f010803d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(next == NULL) next = LIST_FIRST(&env_ready_queue);
f0108040:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0108044:	75 08                	jne    f010804e <sched_next_circular+0x2a>
f0108046:	a1 bc 52 45 f0       	mov    0xf04552bc,%eax
f010804b:	89 45 fc             	mov    %eax,-0x4(%ebp)

	return next;
f010804e:	8b 45 fc             	mov    -0x4(%ebp),%eax
		}
f0108051:	c9                   	leave  
f0108052:	c3                   	ret    

f0108053 <sched_insert_ready>:

void sched_insert_ready(struct Env* env)
{
f0108053:	55                   	push   %ebp
f0108054:	89 e5                	mov    %esp,%ebp
	if(env != NULL)
f0108056:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010805a:	0f 84 b9 00 00 00    	je     f0108119 <sched_insert_ready+0xc6>
	{
		env->env_status = ENV_READY ;
f0108060:	8b 45 08             	mov    0x8(%ebp),%eax
f0108063:	c7 40 54 01 00 00 00 	movl   $0x1,0x54(%eax)
		if(sched_next != NULL)
f010806a:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f010806f:	85 c0                	test   %eax,%eax
f0108071:	74 56                	je     f01080c9 <sched_insert_ready+0x76>
		{
			LIST_INSERT_BEFORE(&env_ready_queue, sched_next, env);
f0108073:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f0108078:	8b 50 48             	mov    0x48(%eax),%edx
f010807b:	8b 45 08             	mov    0x8(%ebp),%eax
f010807e:	89 50 48             	mov    %edx,0x48(%eax)
f0108081:	8b 15 e8 a9 42 f0    	mov    0xf042a9e8,%edx
f0108087:	8b 45 08             	mov    0x8(%ebp),%eax
f010808a:	89 50 44             	mov    %edx,0x44(%eax)
f010808d:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f0108092:	8b 40 48             	mov    0x48(%eax),%eax
f0108095:	85 c0                	test   %eax,%eax
f0108097:	74 10                	je     f01080a9 <sched_insert_ready+0x56>
f0108099:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f010809e:	8b 40 48             	mov    0x48(%eax),%eax
f01080a1:	8b 55 08             	mov    0x8(%ebp),%edx
f01080a4:	89 50 44             	mov    %edx,0x44(%eax)
f01080a7:	eb 08                	jmp    f01080b1 <sched_insert_ready+0x5e>
f01080a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01080ac:	a3 bc 52 45 f0       	mov    %eax,0xf04552bc
f01080b1:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f01080b6:	8b 55 08             	mov    0x8(%ebp),%edx
f01080b9:	89 50 48             	mov    %edx,0x48(%eax)
f01080bc:	a1 c8 52 45 f0       	mov    0xf04552c8,%eax
f01080c1:	40                   	inc    %eax
f01080c2:	a3 c8 52 45 f0       	mov    %eax,0xf04552c8
		{
			LIST_INSERT_TAIL(&env_ready_queue, env);
			sched_next = env;
		}
	}
}
f01080c7:	eb 50                	jmp    f0108119 <sched_insert_ready+0xc6>
		{
			LIST_INSERT_BEFORE(&env_ready_queue, sched_next, env);
		}
		else
		{
			LIST_INSERT_TAIL(&env_ready_queue, env);
f01080c9:	8b 15 c0 52 45 f0    	mov    0xf04552c0,%edx
f01080cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01080d2:	89 50 48             	mov    %edx,0x48(%eax)
f01080d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01080d8:	8b 40 48             	mov    0x48(%eax),%eax
f01080db:	85 c0                	test   %eax,%eax
f01080dd:	74 0d                	je     f01080ec <sched_insert_ready+0x99>
f01080df:	a1 c0 52 45 f0       	mov    0xf04552c0,%eax
f01080e4:	8b 55 08             	mov    0x8(%ebp),%edx
f01080e7:	89 50 44             	mov    %edx,0x44(%eax)
f01080ea:	eb 08                	jmp    f01080f4 <sched_insert_ready+0xa1>
f01080ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01080ef:	a3 bc 52 45 f0       	mov    %eax,0xf04552bc
f01080f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01080f7:	a3 c0 52 45 f0       	mov    %eax,0xf04552c0
f01080fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01080ff:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f0108106:	a1 c8 52 45 f0       	mov    0xf04552c8,%eax
f010810b:	40                   	inc    %eax
f010810c:	a3 c8 52 45 f0       	mov    %eax,0xf04552c8
			sched_next = env;
f0108111:	8b 45 08             	mov    0x8(%ebp),%eax
f0108114:	a3 e8 a9 42 f0       	mov    %eax,0xf042a9e8
		}
	}
}
f0108119:	90                   	nop
f010811a:	5d                   	pop    %ebp
f010811b:	c3                   	ret    

f010811c <sched_remove_ready>:

void sched_remove_ready(struct Env* env)
{
f010811c:	55                   	push   %ebp
f010811d:	89 e5                	mov    %esp,%ebp
	if(env != NULL)
f010811f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108123:	0f 84 a3 00 00 00    	je     f01081cc <sched_remove_ready+0xb0>
	{
		if(env == sched_next)
f0108129:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f010812e:	39 45 08             	cmp    %eax,0x8(%ebp)
f0108131:	75 24                	jne    f0108157 <sched_remove_ready+0x3b>
		{
			sched_next = sched_next_circular(env);
f0108133:	ff 75 08             	pushl  0x8(%ebp)
f0108136:	e8 e9 fe ff ff       	call   f0108024 <sched_next_circular>
f010813b:	83 c4 04             	add    $0x4,%esp
f010813e:	a3 e8 a9 42 f0       	mov    %eax,0xf042a9e8
			if(sched_next == env)
f0108143:	a1 e8 a9 42 f0       	mov    0xf042a9e8,%eax
f0108148:	3b 45 08             	cmp    0x8(%ebp),%eax
f010814b:	75 0a                	jne    f0108157 <sched_remove_ready+0x3b>
			{
				sched_next = NULL;
f010814d:	c7 05 e8 a9 42 f0 00 	movl   $0x0,0xf042a9e8
f0108154:	00 00 00 
			}
		}
		LIST_REMOVE(&env_ready_queue, env);
f0108157:	8b 45 08             	mov    0x8(%ebp),%eax
f010815a:	8b 40 44             	mov    0x44(%eax),%eax
f010815d:	85 c0                	test   %eax,%eax
f010815f:	74 11                	je     f0108172 <sched_remove_ready+0x56>
f0108161:	8b 45 08             	mov    0x8(%ebp),%eax
f0108164:	8b 40 44             	mov    0x44(%eax),%eax
f0108167:	8b 55 08             	mov    0x8(%ebp),%edx
f010816a:	8b 52 48             	mov    0x48(%edx),%edx
f010816d:	89 50 48             	mov    %edx,0x48(%eax)
f0108170:	eb 0b                	jmp    f010817d <sched_remove_ready+0x61>
f0108172:	8b 45 08             	mov    0x8(%ebp),%eax
f0108175:	8b 40 48             	mov    0x48(%eax),%eax
f0108178:	a3 c0 52 45 f0       	mov    %eax,0xf04552c0
f010817d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108180:	8b 40 48             	mov    0x48(%eax),%eax
f0108183:	85 c0                	test   %eax,%eax
f0108185:	74 11                	je     f0108198 <sched_remove_ready+0x7c>
f0108187:	8b 45 08             	mov    0x8(%ebp),%eax
f010818a:	8b 40 48             	mov    0x48(%eax),%eax
f010818d:	8b 55 08             	mov    0x8(%ebp),%edx
f0108190:	8b 52 44             	mov    0x44(%edx),%edx
f0108193:	89 50 44             	mov    %edx,0x44(%eax)
f0108196:	eb 0b                	jmp    f01081a3 <sched_remove_ready+0x87>
f0108198:	8b 45 08             	mov    0x8(%ebp),%eax
f010819b:	8b 40 44             	mov    0x44(%eax),%eax
f010819e:	a3 bc 52 45 f0       	mov    %eax,0xf04552bc
f01081a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081a6:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f01081ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01081b0:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f01081b7:	a1 c8 52 45 f0       	mov    0xf04552c8,%eax
f01081bc:	48                   	dec    %eax
f01081bd:	a3 c8 52 45 f0       	mov    %eax,0xf04552c8
		env->env_status = ENV_UNKNOWN;
f01081c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01081c5:	c7 40 54 05 00 00 00 	movl   $0x5,0x54(%eax)
	}
}
f01081cc:	90                   	nop
f01081cd:	c9                   	leave  
f01081ce:	c3                   	ret    

f01081cf <sched_insert_new>:

void sched_insert_new(struct Env* env)
{
f01081cf:	55                   	push   %ebp
f01081d0:	89 e5                	mov    %esp,%ebp
	if(env != NULL)
f01081d2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01081d6:	74 52                	je     f010822a <sched_insert_new+0x5b>
	{
		env->env_status = ENV_NEW ;
f01081d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01081db:	c7 40 54 03 00 00 00 	movl   $0x3,0x54(%eax)
		LIST_INSERT_TAIL(&env_new_queue, env);
f01081e2:	8b 15 b0 52 45 f0    	mov    0xf04552b0,%edx
f01081e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01081eb:	89 50 48             	mov    %edx,0x48(%eax)
f01081ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f1:	8b 40 48             	mov    0x48(%eax),%eax
f01081f4:	85 c0                	test   %eax,%eax
f01081f6:	74 0d                	je     f0108205 <sched_insert_new+0x36>
f01081f8:	a1 b0 52 45 f0       	mov    0xf04552b0,%eax
f01081fd:	8b 55 08             	mov    0x8(%ebp),%edx
f0108200:	89 50 44             	mov    %edx,0x44(%eax)
f0108203:	eb 08                	jmp    f010820d <sched_insert_new+0x3e>
f0108205:	8b 45 08             	mov    0x8(%ebp),%eax
f0108208:	a3 ac 52 45 f0       	mov    %eax,0xf04552ac
f010820d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108210:	a3 b0 52 45 f0       	mov    %eax,0xf04552b0
f0108215:	8b 45 08             	mov    0x8(%ebp),%eax
f0108218:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f010821f:	a1 b8 52 45 f0       	mov    0xf04552b8,%eax
f0108224:	40                   	inc    %eax
f0108225:	a3 b8 52 45 f0       	mov    %eax,0xf04552b8
	}
}
f010822a:	90                   	nop
f010822b:	5d                   	pop    %ebp
f010822c:	c3                   	ret    

f010822d <sched_remove_new>:
void sched_remove_new(struct Env* env)
{
f010822d:	55                   	push   %ebp
f010822e:	89 e5                	mov    %esp,%ebp
	if(env != NULL)
f0108230:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108234:	74 75                	je     f01082ab <sched_remove_new+0x7e>
	{
		LIST_REMOVE(&env_new_queue, env) ;
f0108236:	8b 45 08             	mov    0x8(%ebp),%eax
f0108239:	8b 40 44             	mov    0x44(%eax),%eax
f010823c:	85 c0                	test   %eax,%eax
f010823e:	74 11                	je     f0108251 <sched_remove_new+0x24>
f0108240:	8b 45 08             	mov    0x8(%ebp),%eax
f0108243:	8b 40 44             	mov    0x44(%eax),%eax
f0108246:	8b 55 08             	mov    0x8(%ebp),%edx
f0108249:	8b 52 48             	mov    0x48(%edx),%edx
f010824c:	89 50 48             	mov    %edx,0x48(%eax)
f010824f:	eb 0b                	jmp    f010825c <sched_remove_new+0x2f>
f0108251:	8b 45 08             	mov    0x8(%ebp),%eax
f0108254:	8b 40 48             	mov    0x48(%eax),%eax
f0108257:	a3 b0 52 45 f0       	mov    %eax,0xf04552b0
f010825c:	8b 45 08             	mov    0x8(%ebp),%eax
f010825f:	8b 40 48             	mov    0x48(%eax),%eax
f0108262:	85 c0                	test   %eax,%eax
f0108264:	74 11                	je     f0108277 <sched_remove_new+0x4a>
f0108266:	8b 45 08             	mov    0x8(%ebp),%eax
f0108269:	8b 40 48             	mov    0x48(%eax),%eax
f010826c:	8b 55 08             	mov    0x8(%ebp),%edx
f010826f:	8b 52 44             	mov    0x44(%edx),%edx
f0108272:	89 50 44             	mov    %edx,0x44(%eax)
f0108275:	eb 0b                	jmp    f0108282 <sched_remove_new+0x55>
f0108277:	8b 45 08             	mov    0x8(%ebp),%eax
f010827a:	8b 40 44             	mov    0x44(%eax),%eax
f010827d:	a3 ac 52 45 f0       	mov    %eax,0xf04552ac
f0108282:	8b 45 08             	mov    0x8(%ebp),%eax
f0108285:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f010828c:	8b 45 08             	mov    0x8(%ebp),%eax
f010828f:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f0108296:	a1 b8 52 45 f0       	mov    0xf04552b8,%eax
f010829b:	48                   	dec    %eax
f010829c:	a3 b8 52 45 f0       	mov    %eax,0xf04552b8
		env->env_status = ENV_UNKNOWN;
f01082a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01082a4:	c7 40 54 05 00 00 00 	movl   $0x5,0x54(%eax)
	}
}
f01082ab:	90                   	nop
f01082ac:	5d                   	pop    %ebp
f01082ad:	c3                   	ret    

f01082ae <sched_insert_exit>:

void sched_insert_exit(struct Env* env)
{
f01082ae:	55                   	push   %ebp
f01082af:	89 e5                	mov    %esp,%ebp
	if(env != NULL)
f01082b1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01082b5:	74 52                	je     f0108309 <sched_insert_exit+0x5b>
	{
		env->env_status = ENV_EXIT ;
f01082b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01082ba:	c7 40 54 04 00 00 00 	movl   $0x4,0x54(%eax)
		LIST_INSERT_TAIL(&env_exit_queue, env);
f01082c1:	8b 15 a0 52 45 f0    	mov    0xf04552a0,%edx
f01082c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01082ca:	89 50 48             	mov    %edx,0x48(%eax)
f01082cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01082d0:	8b 40 48             	mov    0x48(%eax),%eax
f01082d3:	85 c0                	test   %eax,%eax
f01082d5:	74 0d                	je     f01082e4 <sched_insert_exit+0x36>
f01082d7:	a1 a0 52 45 f0       	mov    0xf04552a0,%eax
f01082dc:	8b 55 08             	mov    0x8(%ebp),%edx
f01082df:	89 50 44             	mov    %edx,0x44(%eax)
f01082e2:	eb 08                	jmp    f01082ec <sched_insert_exit+0x3e>
f01082e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01082e7:	a3 9c 52 45 f0       	mov    %eax,0xf045529c
f01082ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01082ef:	a3 a0 52 45 f0       	mov    %eax,0xf04552a0
f01082f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01082f7:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f01082fe:	a1 a8 52 45 f0       	mov    0xf04552a8,%eax
f0108303:	40                   	inc    %eax
f0108304:	a3 a8 52 45 f0       	mov    %eax,0xf04552a8
	}
}
f0108309:	90                   	nop
f010830a:	5d                   	pop    %ebp
f010830b:	c3                   	ret    

f010830c <sched_remove_exit>:
void sched_remove_exit(struct Env* env)
{
f010830c:	55                   	push   %ebp
f010830d:	89 e5                	mov    %esp,%ebp
	if(env != NULL)
f010830f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108313:	74 75                	je     f010838a <sched_remove_exit+0x7e>
	{
		LIST_REMOVE(&env_exit_queue, env) ;
f0108315:	8b 45 08             	mov    0x8(%ebp),%eax
f0108318:	8b 40 44             	mov    0x44(%eax),%eax
f010831b:	85 c0                	test   %eax,%eax
f010831d:	74 11                	je     f0108330 <sched_remove_exit+0x24>
f010831f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108322:	8b 40 44             	mov    0x44(%eax),%eax
f0108325:	8b 55 08             	mov    0x8(%ebp),%edx
f0108328:	8b 52 48             	mov    0x48(%edx),%edx
f010832b:	89 50 48             	mov    %edx,0x48(%eax)
f010832e:	eb 0b                	jmp    f010833b <sched_remove_exit+0x2f>
f0108330:	8b 45 08             	mov    0x8(%ebp),%eax
f0108333:	8b 40 48             	mov    0x48(%eax),%eax
f0108336:	a3 a0 52 45 f0       	mov    %eax,0xf04552a0
f010833b:	8b 45 08             	mov    0x8(%ebp),%eax
f010833e:	8b 40 48             	mov    0x48(%eax),%eax
f0108341:	85 c0                	test   %eax,%eax
f0108343:	74 11                	je     f0108356 <sched_remove_exit+0x4a>
f0108345:	8b 45 08             	mov    0x8(%ebp),%eax
f0108348:	8b 40 48             	mov    0x48(%eax),%eax
f010834b:	8b 55 08             	mov    0x8(%ebp),%edx
f010834e:	8b 52 44             	mov    0x44(%edx),%edx
f0108351:	89 50 44             	mov    %edx,0x44(%eax)
f0108354:	eb 0b                	jmp    f0108361 <sched_remove_exit+0x55>
f0108356:	8b 45 08             	mov    0x8(%ebp),%eax
f0108359:	8b 40 44             	mov    0x44(%eax),%eax
f010835c:	a3 9c 52 45 f0       	mov    %eax,0xf045529c
f0108361:	8b 45 08             	mov    0x8(%ebp),%eax
f0108364:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f0108375:	a1 a8 52 45 f0       	mov    0xf04552a8,%eax
f010837a:	48                   	dec    %eax
f010837b:	a3 a8 52 45 f0       	mov    %eax,0xf04552a8
		env->env_status = ENV_UNKNOWN;
f0108380:	8b 45 08             	mov    0x8(%ebp),%eax
f0108383:	c7 40 54 05 00 00 00 	movl   $0x5,0x54(%eax)
	}
}
f010838a:	90                   	nop
f010838b:	5d                   	pop    %ebp
f010838c:	c3                   	ret    

f010838d <sched_print_all>:

void sched_print_all()
{
f010838d:	55                   	push   %ebp
f010838e:	89 e5                	mov    %esp,%ebp
f0108390:	83 ec 18             	sub    $0x18,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&env_new_queue))
f0108393:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f0108398:	85 c0                	test   %eax,%eax
f010839a:	74 6c                	je     f0108408 <sched_print_all+0x7b>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f010839c:	83 ec 0c             	sub    $0xc,%esp
f010839f:	68 90 1a 11 f0       	push   $0xf0111a90
f01083a4:	e8 b2 dc ff ff       	call   f010605b <cprintf>
f01083a9:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &env_new_queue)
f01083ac:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f01083b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01083b4:	eb 29                	jmp    f01083df <sched_print_all+0x52>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01083b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083b9:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f01083bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083c2:	8b 40 4c             	mov    0x4c(%eax),%eax
f01083c5:	83 ec 04             	sub    $0x4,%esp
f01083c8:	52                   	push   %edx
f01083c9:	50                   	push   %eax
f01083ca:	68 b2 1a 11 f0       	push   $0xf0111ab2
f01083cf:	e8 87 dc ff ff       	call   f010605b <cprintf>
f01083d4:	83 c4 10             	add    $0x10,%esp
{
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &env_new_queue)
f01083d7:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f01083dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01083df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083e3:	74 08                	je     f01083ed <sched_print_all+0x60>
f01083e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083e8:	8b 40 44             	mov    0x44(%eax),%eax
f01083eb:	eb 05                	jmp    f01083f2 <sched_print_all+0x65>
f01083ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01083f2:	a3 b4 52 45 f0       	mov    %eax,0xf04552b4
f01083f7:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f01083fc:	85 c0                	test   %eax,%eax
f01083fe:	75 b6                	jne    f01083b6 <sched_print_all+0x29>
f0108400:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108404:	75 b0                	jne    f01083b6 <sched_print_all+0x29>
f0108406:	eb 10                	jmp    f0108418 <sched_print_all+0x8b>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0108408:	83 ec 0c             	sub    $0xc,%esp
f010840b:	68 bc 1a 11 f0       	push   $0xf0111abc
f0108410:	e8 46 dc ff ff       	call   f010605b <cprintf>
f0108415:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0108418:	83 ec 0c             	sub    $0xc,%esp
f010841b:	68 d8 1a 11 f0       	push   $0xf0111ad8
f0108420:	e8 36 dc ff ff       	call   f010605b <cprintf>
f0108425:	83 c4 10             	add    $0x10,%esp
	if (!LIST_EMPTY(&env_ready_queue))
f0108428:	a1 bc 52 45 f0       	mov    0xf04552bc,%eax
f010842d:	85 c0                	test   %eax,%eax
f010842f:	74 6c                	je     f010849d <sched_print_all+0x110>
	{
		cprintf("The processes in READY queue are:\n");
f0108431:	83 ec 0c             	sub    $0xc,%esp
f0108434:	68 0c 1b 11 f0       	push   $0xf0111b0c
f0108439:	e8 1d dc ff ff       	call   f010605b <cprintf>
f010843e:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &env_ready_queue)
f0108441:	a1 bc 52 45 f0       	mov    0xf04552bc,%eax
f0108446:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108449:	eb 29                	jmp    f0108474 <sched_print_all+0xe7>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f010844b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010844e:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f0108454:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108457:	8b 40 4c             	mov    0x4c(%eax),%eax
f010845a:	83 ec 04             	sub    $0x4,%esp
f010845d:	52                   	push   %edx
f010845e:	50                   	push   %eax
f010845f:	68 b2 1a 11 f0       	push   $0xf0111ab2
f0108464:	e8 f2 db ff ff       	call   f010605b <cprintf>
f0108469:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
	if (!LIST_EMPTY(&env_ready_queue))
	{
		cprintf("The processes in READY queue are:\n");
		LIST_FOREACH(ptr_env, &env_ready_queue)
f010846c:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f0108471:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108474:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108478:	74 08                	je     f0108482 <sched_print_all+0xf5>
f010847a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010847d:	8b 40 44             	mov    0x44(%eax),%eax
f0108480:	eb 05                	jmp    f0108487 <sched_print_all+0xfa>
f0108482:	b8 00 00 00 00       	mov    $0x0,%eax
f0108487:	a3 c4 52 45 f0       	mov    %eax,0xf04552c4
f010848c:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f0108491:	85 c0                	test   %eax,%eax
f0108493:	75 b6                	jne    f010844b <sched_print_all+0xbe>
f0108495:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108499:	75 b0                	jne    f010844b <sched_print_all+0xbe>
f010849b:	eb 10                	jmp    f01084ad <sched_print_all+0x120>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in READY queue\n");
f010849d:	83 ec 0c             	sub    $0xc,%esp
f01084a0:	68 2f 1b 11 f0       	push   $0xf0111b2f
f01084a5:	e8 b1 db ff ff       	call   f010605b <cprintf>
f01084aa:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01084ad:	83 ec 0c             	sub    $0xc,%esp
f01084b0:	68 d8 1a 11 f0       	push   $0xf0111ad8
f01084b5:	e8 a1 db ff ff       	call   f010605b <cprintf>
f01084ba:	83 c4 10             	add    $0x10,%esp
	if (!LIST_EMPTY(&env_exit_queue))
f01084bd:	a1 9c 52 45 f0       	mov    0xf045529c,%eax
f01084c2:	85 c0                	test   %eax,%eax
f01084c4:	74 6c                	je     f0108532 <sched_print_all+0x1a5>
	{
		cprintf("The processes in EXIT queue are:\n");
f01084c6:	83 ec 0c             	sub    $0xc,%esp
f01084c9:	68 4c 1b 11 f0       	push   $0xf0111b4c
f01084ce:	e8 88 db ff ff       	call   f010605b <cprintf>
f01084d3:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &env_exit_queue)
f01084d6:	a1 9c 52 45 f0       	mov    0xf045529c,%eax
f01084db:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01084de:	eb 29                	jmp    f0108509 <sched_print_all+0x17c>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01084e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084e3:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f01084e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ec:	8b 40 4c             	mov    0x4c(%eax),%eax
f01084ef:	83 ec 04             	sub    $0x4,%esp
f01084f2:	52                   	push   %edx
f01084f3:	50                   	push   %eax
f01084f4:	68 b2 1a 11 f0       	push   $0xf0111ab2
f01084f9:	e8 5d db ff ff       	call   f010605b <cprintf>
f01084fe:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
	if (!LIST_EMPTY(&env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &env_exit_queue)
f0108501:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f0108506:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108509:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010850d:	74 08                	je     f0108517 <sched_print_all+0x18a>
f010850f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108512:	8b 40 44             	mov    0x44(%eax),%eax
f0108515:	eb 05                	jmp    f010851c <sched_print_all+0x18f>
f0108517:	b8 00 00 00 00       	mov    $0x0,%eax
f010851c:	a3 a4 52 45 f0       	mov    %eax,0xf04552a4
f0108521:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f0108526:	85 c0                	test   %eax,%eax
f0108528:	75 b6                	jne    f01084e0 <sched_print_all+0x153>
f010852a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010852e:	75 b0                	jne    f01084e0 <sched_print_all+0x153>
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
	}
}
f0108530:	eb 10                	jmp    f0108542 <sched_print_all+0x1b5>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0108532:	83 ec 0c             	sub    $0xc,%esp
f0108535:	68 6e 1b 11 f0       	push   $0xf0111b6e
f010853a:	e8 1c db ff ff       	call   f010605b <cprintf>
f010853f:	83 c4 10             	add    $0x10,%esp
	}
}
f0108542:	90                   	nop
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <sched_run_all>:

void sched_run_all()
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	83 ec 18             	sub    $0x18,%esp
	struct Env* ptr_env=NULL;
f010854b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &env_new_queue)
f0108552:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f0108557:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010855a:	eb 1e                	jmp    f010857a <sched_run_all+0x35>
	{
		sched_remove_new(ptr_env);
f010855c:	ff 75 f4             	pushl  -0xc(%ebp)
f010855f:	e8 c9 fc ff ff       	call   f010822d <sched_remove_new>
f0108564:	83 c4 04             	add    $0x4,%esp
		sched_insert_ready(ptr_env);
f0108567:	ff 75 f4             	pushl  -0xc(%ebp)
f010856a:	e8 e4 fa ff ff       	call   f0108053 <sched_insert_ready>
f010856f:	83 c4 04             	add    $0x4,%esp
}

void sched_run_all()
{
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &env_new_queue)
f0108572:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f0108577:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010857a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010857e:	74 08                	je     f0108588 <sched_run_all+0x43>
f0108580:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108583:	8b 40 44             	mov    0x44(%eax),%eax
f0108586:	eb 05                	jmp    f010858d <sched_run_all+0x48>
f0108588:	b8 00 00 00 00       	mov    $0x0,%eax
f010858d:	a3 b4 52 45 f0       	mov    %eax,0xf04552b4
f0108592:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f0108597:	85 c0                	test   %eax,%eax
f0108599:	75 c1                	jne    f010855c <sched_run_all+0x17>
f010859b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010859f:	75 bb                	jne    f010855c <sched_run_all+0x17>
	{
		sched_remove_new(ptr_env);
		sched_insert_ready(ptr_env);
	}
	/*2015*///if scheduler not run yet, then invoke it!
	if (scheduler_status == SCH_STOPPED)
f01085a1:	a1 34 2a 45 f0       	mov    0xf0452a34,%eax
f01085a6:	85 c0                	test   %eax,%eax
f01085a8:	75 05                	jne    f01085af <sched_run_all+0x6a>
		fos_scheduler();
f01085aa:	e8 80 f9 ff ff       	call   f0107f2f <fos_scheduler>
}
f01085af:	90                   	nop
f01085b0:	c9                   	leave  
f01085b1:	c3                   	ret    

f01085b2 <sched_kill_all>:

void sched_kill_all()
{
f01085b2:	55                   	push   %ebp
f01085b3:	89 e5                	mov    %esp,%ebp
f01085b5:	83 ec 18             	sub    $0x18,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&env_new_queue))
f01085b8:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f01085bd:	85 c0                	test   %eax,%eax
f01085bf:	0f 84 98 00 00 00    	je     f010865d <sched_kill_all+0xab>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01085c5:	83 ec 0c             	sub    $0xc,%esp
f01085c8:	68 8c 1b 11 f0       	push   $0xf0111b8c
f01085cd:	e8 89 da ff ff       	call   f010605b <cprintf>
f01085d2:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &env_new_queue)
f01085d5:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f01085da:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01085dd:	eb 55                	jmp    f0108634 <sched_kill_all+0x82>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01085df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085e2:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f01085e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085eb:	8b 40 4c             	mov    0x4c(%eax),%eax
f01085ee:	83 ec 04             	sub    $0x4,%esp
f01085f1:	52                   	push   %edx
f01085f2:	50                   	push   %eax
f01085f3:	68 b8 1b 11 f0       	push   $0xf0111bb8
f01085f8:	e8 5e da ff ff       	call   f010605b <cprintf>
f01085fd:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0108600:	83 ec 0c             	sub    $0xc,%esp
f0108603:	ff 75 f4             	pushl  -0xc(%ebp)
f0108606:	e8 22 fc ff ff       	call   f010822d <sched_remove_new>
f010860b:	83 c4 10             	add    $0x10,%esp
			start_env_free(ptr_env);
f010860e:	83 ec 0c             	sub    $0xc,%esp
f0108611:	ff 75 f4             	pushl  -0xc(%ebp)
f0108614:	e8 7b cd ff ff       	call   f0105394 <start_env_free>
f0108619:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f010861c:	83 ec 0c             	sub    $0xc,%esp
f010861f:	68 cb 1b 11 f0       	push   $0xf0111bcb
f0108624:	e8 32 da ff ff       	call   f010605b <cprintf>
f0108629:	83 c4 10             	add    $0x10,%esp
{
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &env_new_queue)
f010862c:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f0108631:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108634:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108638:	74 08                	je     f0108642 <sched_kill_all+0x90>
f010863a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010863d:	8b 40 44             	mov    0x44(%eax),%eax
f0108640:	eb 05                	jmp    f0108647 <sched_kill_all+0x95>
f0108642:	b8 00 00 00 00       	mov    $0x0,%eax
f0108647:	a3 b4 52 45 f0       	mov    %eax,0xf04552b4
f010864c:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f0108651:	85 c0                	test   %eax,%eax
f0108653:	75 8a                	jne    f01085df <sched_kill_all+0x2d>
f0108655:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108659:	75 84                	jne    f01085df <sched_kill_all+0x2d>
f010865b:	eb 10                	jmp    f010866d <sched_kill_all+0xbb>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f010865d:	83 ec 0c             	sub    $0xc,%esp
f0108660:	68 d1 1b 11 f0       	push   $0xf0111bd1
f0108665:	e8 f1 d9 ff ff       	call   f010605b <cprintf>
f010866a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f010866d:	83 ec 0c             	sub    $0xc,%esp
f0108670:	68 d8 1a 11 f0       	push   $0xf0111ad8
f0108675:	e8 e1 d9 ff ff       	call   f010605b <cprintf>
f010867a:	83 c4 10             	add    $0x10,%esp
	if (!LIST_EMPTY(&env_ready_queue))
f010867d:	a1 bc 52 45 f0       	mov    0xf04552bc,%eax
f0108682:	85 c0                	test   %eax,%eax
f0108684:	0f 84 98 00 00 00    	je     f0108722 <sched_kill_all+0x170>
	{
		cprintf("KILLING the processes in the READY queue...\n");
f010868a:	83 ec 0c             	sub    $0xc,%esp
f010868d:	68 ec 1b 11 f0       	push   $0xf0111bec
f0108692:	e8 c4 d9 ff ff       	call   f010605b <cprintf>
f0108697:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &env_ready_queue)
f010869a:	a1 bc 52 45 f0       	mov    0xf04552bc,%eax
f010869f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01086a2:	eb 55                	jmp    f01086f9 <sched_kill_all+0x147>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01086a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086a7:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f01086ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01086b0:	8b 40 4c             	mov    0x4c(%eax),%eax
f01086b3:	83 ec 04             	sub    $0x4,%esp
f01086b6:	52                   	push   %edx
f01086b7:	50                   	push   %eax
f01086b8:	68 b8 1b 11 f0       	push   $0xf0111bb8
f01086bd:	e8 99 d9 ff ff       	call   f010605b <cprintf>
f01086c2:	83 c4 10             	add    $0x10,%esp
			sched_remove_ready(ptr_env);
f01086c5:	83 ec 0c             	sub    $0xc,%esp
f01086c8:	ff 75 f4             	pushl  -0xc(%ebp)
f01086cb:	e8 4c fa ff ff       	call   f010811c <sched_remove_ready>
f01086d0:	83 c4 10             	add    $0x10,%esp
			start_env_free(ptr_env);
f01086d3:	83 ec 0c             	sub    $0xc,%esp
f01086d6:	ff 75 f4             	pushl  -0xc(%ebp)
f01086d9:	e8 b6 cc ff ff       	call   f0105394 <start_env_free>
f01086de:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01086e1:	83 ec 0c             	sub    $0xc,%esp
f01086e4:	68 cb 1b 11 f0       	push   $0xf0111bcb
f01086e9:	e8 6d d9 ff ff       	call   f010605b <cprintf>
f01086ee:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
	if (!LIST_EMPTY(&env_ready_queue))
	{
		cprintf("KILLING the processes in the READY queue...\n");
		LIST_FOREACH(ptr_env, &env_ready_queue)
f01086f1:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f01086f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01086f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01086fd:	74 08                	je     f0108707 <sched_kill_all+0x155>
f01086ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108702:	8b 40 44             	mov    0x44(%eax),%eax
f0108705:	eb 05                	jmp    f010870c <sched_kill_all+0x15a>
f0108707:	b8 00 00 00 00       	mov    $0x0,%eax
f010870c:	a3 c4 52 45 f0       	mov    %eax,0xf04552c4
f0108711:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f0108716:	85 c0                	test   %eax,%eax
f0108718:	75 8a                	jne    f01086a4 <sched_kill_all+0xf2>
f010871a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010871e:	75 84                	jne    f01086a4 <sched_kill_all+0xf2>
f0108720:	eb 10                	jmp    f0108732 <sched_kill_all+0x180>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in READY queue\n");
f0108722:	83 ec 0c             	sub    $0xc,%esp
f0108725:	68 2f 1b 11 f0       	push   $0xf0111b2f
f010872a:	e8 2c d9 ff ff       	call   f010605b <cprintf>
f010872f:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0108732:	83 ec 0c             	sub    $0xc,%esp
f0108735:	68 d8 1a 11 f0       	push   $0xf0111ad8
f010873a:	e8 1c d9 ff ff       	call   f010605b <cprintf>
f010873f:	83 c4 10             	add    $0x10,%esp
	if (!LIST_EMPTY(&env_exit_queue))
f0108742:	a1 9c 52 45 f0       	mov    0xf045529c,%eax
f0108747:	85 c0                	test   %eax,%eax
f0108749:	0f 84 98 00 00 00    	je     f01087e7 <sched_kill_all+0x235>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f010874f:	83 ec 0c             	sub    $0xc,%esp
f0108752:	68 1c 1c 11 f0       	push   $0xf0111c1c
f0108757:	e8 ff d8 ff ff       	call   f010605b <cprintf>
f010875c:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &env_exit_queue)
f010875f:	a1 9c 52 45 f0       	mov    0xf045529c,%eax
f0108764:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108767:	eb 55                	jmp    f01087be <sched_kill_all+0x20c>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0108769:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010876c:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f0108772:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108775:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108778:	83 ec 04             	sub    $0x4,%esp
f010877b:	52                   	push   %edx
f010877c:	50                   	push   %eax
f010877d:	68 b8 1b 11 f0       	push   $0xf0111bb8
f0108782:	e8 d4 d8 ff ff       	call   f010605b <cprintf>
f0108787:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f010878a:	83 ec 0c             	sub    $0xc,%esp
f010878d:	ff 75 f4             	pushl  -0xc(%ebp)
f0108790:	e8 77 fb ff ff       	call   f010830c <sched_remove_exit>
f0108795:	83 c4 10             	add    $0x10,%esp
			start_env_free(ptr_env);
f0108798:	83 ec 0c             	sub    $0xc,%esp
f010879b:	ff 75 f4             	pushl  -0xc(%ebp)
f010879e:	e8 f1 cb ff ff       	call   f0105394 <start_env_free>
f01087a3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01087a6:	83 ec 0c             	sub    $0xc,%esp
f01087a9:	68 cb 1b 11 f0       	push   $0xf0111bcb
f01087ae:	e8 a8 d8 ff ff       	call   f010605b <cprintf>
f01087b3:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
	if (!LIST_EMPTY(&env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &env_exit_queue)
f01087b6:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f01087bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01087be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01087c2:	74 08                	je     f01087cc <sched_kill_all+0x21a>
f01087c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087c7:	8b 40 44             	mov    0x44(%eax),%eax
f01087ca:	eb 05                	jmp    f01087d1 <sched_kill_all+0x21f>
f01087cc:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d1:	a3 a4 52 45 f0       	mov    %eax,0xf04552a4
f01087d6:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f01087db:	85 c0                	test   %eax,%eax
f01087dd:	75 8a                	jne    f0108769 <sched_kill_all+0x1b7>
f01087df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01087e3:	75 84                	jne    f0108769 <sched_kill_all+0x1b7>
f01087e5:	eb 10                	jmp    f01087f7 <sched_kill_all+0x245>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01087e7:	83 ec 0c             	sub    $0xc,%esp
f01087ea:	68 6e 1b 11 f0       	push   $0xf0111b6e
f01087ef:	e8 67 d8 ff ff       	call   f010605b <cprintf>
f01087f4:	83 c4 10             	add    $0x10,%esp
	}

	//reinvoke the scheduler since there're no env to return back to it
	fos_scheduler();
f01087f7:	e8 33 f7 ff ff       	call   f0107f2f <fos_scheduler>

f01087fc <sched_new_env>:
}


void sched_new_env(struct Env* e)
{
f01087fc:	55                   	push   %ebp
f01087fd:	89 e5                	mov    %esp,%ebp
	//add the given env to the scheduler NEW queue
	if (e!=NULL)
f01087ff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108803:	74 0b                	je     f0108810 <sched_new_env+0x14>
	{
		sched_insert_new(e);
f0108805:	ff 75 08             	pushl  0x8(%ebp)
f0108808:	e8 c2 f9 ff ff       	call   f01081cf <sched_insert_new>
f010880d:	83 c4 04             	add    $0x4,%esp
	}
}
f0108810:	90                   	nop
f0108811:	c9                   	leave  
f0108812:	c3                   	ret    

f0108813 <sched_run_env>:

	sched_insert_new(e);
}
*/
void sched_run_env(uint32 envId)
{
f0108813:	55                   	push   %ebp
f0108814:	89 e5                	mov    %esp,%ebp
f0108816:	83 ec 18             	sub    $0x18,%esp
	struct Env* ptr_env=NULL;
f0108819:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &env_new_queue)
f0108820:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f0108825:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108828:	eb 37                	jmp    f0108861 <sched_run_env+0x4e>
	{
		if(ptr_env->env_id == envId)
f010882a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010882d:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108830:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108833:	75 24                	jne    f0108859 <sched_run_env+0x46>
		{
			sched_remove_new(ptr_env);
f0108835:	ff 75 f4             	pushl  -0xc(%ebp)
f0108838:	e8 f0 f9 ff ff       	call   f010822d <sched_remove_new>
f010883d:	83 c4 04             	add    $0x4,%esp
			sched_insert_ready(ptr_env);
f0108840:	ff 75 f4             	pushl  -0xc(%ebp)
f0108843:	e8 0b f8 ff ff       	call   f0108053 <sched_insert_ready>
f0108848:	83 c4 04             	add    $0x4,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (scheduler_status == SCH_STOPPED)
f010884b:	a1 34 2a 45 f0       	mov    0xf0452a34,%eax
f0108850:	85 c0                	test   %eax,%eax
f0108852:	75 36                	jne    f010888a <sched_run_env+0x77>
			{
				fos_scheduler();
f0108854:	e8 d6 f6 ff ff       	call   f0107f2f <fos_scheduler>
}
*/
void sched_run_env(uint32 envId)
{
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &env_new_queue)
f0108859:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f010885e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108861:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108865:	74 08                	je     f010886f <sched_run_env+0x5c>
f0108867:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010886a:	8b 40 44             	mov    0x44(%eax),%eax
f010886d:	eb 05                	jmp    f0108874 <sched_run_env+0x61>
f010886f:	b8 00 00 00 00       	mov    $0x0,%eax
f0108874:	a3 b4 52 45 f0       	mov    %eax,0xf04552b4
f0108879:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f010887e:	85 c0                	test   %eax,%eax
f0108880:	75 a8                	jne    f010882a <sched_run_env+0x17>
f0108882:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108886:	75 a2                	jne    f010882a <sched_run_env+0x17>
				fos_scheduler();
			}
			break;
		}
	}
}
f0108888:	eb 01                	jmp    f010888b <sched_run_env+0x78>
			/*2015*///if scheduler not run yet, then invoke it!
			if (scheduler_status == SCH_STOPPED)
			{
				fos_scheduler();
			}
			break;
f010888a:	90                   	nop
		}
	}
}
f010888b:	90                   	nop
f010888c:	c9                   	leave  
f010888d:	c3                   	ret    

f010888e <sched_exit_env>:

void sched_exit_env(uint32 envId)
{
f010888e:	55                   	push   %ebp
f010888f:	89 e5                	mov    %esp,%ebp
f0108891:	83 ec 18             	sub    $0x18,%esp
	struct Env* ptr_env=NULL;
f0108894:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &env_new_queue)
f010889b:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f01088a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088a3:	eb 49                	jmp    f01088ee <sched_exit_env+0x60>
	{
		if(ptr_env->env_id == envId)
f01088a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088a8:	8b 40 4c             	mov    0x4c(%eax),%eax
f01088ab:	3b 45 08             	cmp    0x8(%ebp),%eax
f01088ae:	75 36                	jne    f01088e6 <sched_exit_env+0x58>
		{
			sched_remove_new(ptr_env);
f01088b0:	ff 75 f4             	pushl  -0xc(%ebp)
f01088b3:	e8 75 f9 ff ff       	call   f010822d <sched_remove_new>
f01088b8:	83 c4 04             	add    $0x4,%esp
			sched_insert_exit(ptr_env);
f01088bb:	ff 75 f4             	pushl  -0xc(%ebp)
f01088be:	e8 eb f9 ff ff       	call   f01082ae <sched_insert_exit>
f01088c3:	83 c4 04             	add    $0x4,%esp
			if(isBufferingEnabled()) {cleanup_buffers(ptr_env);}
f01088c6:	e8 40 ed ff ff       	call   f010760b <isBufferingEnabled>
f01088cb:	85 c0                	test   %eax,%eax
f01088cd:	0f 84 d4 00 00 00    	je     f01089a7 <sched_exit_env+0x119>
f01088d3:	83 ec 0c             	sub    $0xc,%esp
f01088d6:	ff 75 f4             	pushl  -0xc(%ebp)
f01088d9:	e8 98 d2 ff ff       	call   f0105b76 <cleanup_buffers>
f01088de:	83 c4 10             	add    $0x10,%esp
			return;
f01088e1:	e9 c1 00 00 00       	jmp    f01089a7 <sched_exit_env+0x119>
}

void sched_exit_env(uint32 envId)
{
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &env_new_queue)
f01088e6:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f01088eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01088f2:	74 08                	je     f01088fc <sched_exit_env+0x6e>
f01088f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088f7:	8b 40 44             	mov    0x44(%eax),%eax
f01088fa:	eb 05                	jmp    f0108901 <sched_exit_env+0x73>
f01088fc:	b8 00 00 00 00       	mov    $0x0,%eax
f0108901:	a3 b4 52 45 f0       	mov    %eax,0xf04552b4
f0108906:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f010890b:	85 c0                	test   %eax,%eax
f010890d:	75 96                	jne    f01088a5 <sched_exit_env+0x17>
f010890f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108913:	75 90                	jne    f01088a5 <sched_exit_env+0x17>
			sched_insert_exit(ptr_env);
			if(isBufferingEnabled()) {cleanup_buffers(ptr_env);}
			return;
		}
	}
	ptr_env=NULL;
f0108915:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &env_ready_queue)
f010891c:	a1 bc 52 45 f0       	mov    0xf04552bc,%eax
f0108921:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108924:	eb 58                	jmp    f010897e <sched_exit_env+0xf0>
	{
		if(ptr_env->env_id == envId)
f0108926:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108929:	8b 40 4c             	mov    0x4c(%eax),%eax
f010892c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010892f:	75 45                	jne    f0108976 <sched_exit_env+0xe8>
		{
			sched_remove_ready(ptr_env);
f0108931:	83 ec 0c             	sub    $0xc,%esp
f0108934:	ff 75 f4             	pushl  -0xc(%ebp)
f0108937:	e8 e0 f7 ff ff       	call   f010811c <sched_remove_ready>
f010893c:	83 c4 10             	add    $0x10,%esp
			sched_insert_exit(ptr_env);
f010893f:	83 ec 0c             	sub    $0xc,%esp
f0108942:	ff 75 f4             	pushl  -0xc(%ebp)
f0108945:	e8 64 f9 ff ff       	call   f01082ae <sched_insert_exit>
f010894a:	83 c4 10             	add    $0x10,%esp
			if(isBufferingEnabled()) {cleanup_buffers(ptr_env);}
f010894d:	e8 b9 ec ff ff       	call   f010760b <isBufferingEnabled>
f0108952:	85 c0                	test   %eax,%eax
f0108954:	74 0e                	je     f0108964 <sched_exit_env+0xd6>
f0108956:	83 ec 0c             	sub    $0xc,%esp
f0108959:	ff 75 f4             	pushl  -0xc(%ebp)
f010895c:	e8 15 d2 ff ff       	call   f0105b76 <cleanup_buffers>
f0108961:	83 c4 10             	add    $0x10,%esp

			//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back to an exited env
			if (curenv->env_id == envId)
f0108964:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108969:	8b 40 4c             	mov    0x4c(%eax),%eax
f010896c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010896f:	75 39                	jne    f01089aa <sched_exit_env+0x11c>
			{
				fos_scheduler();
f0108971:	e8 b9 f5 ff ff       	call   f0107f2f <fos_scheduler>
			if(isBufferingEnabled()) {cleanup_buffers(ptr_env);}
			return;
		}
	}
	ptr_env=NULL;
	LIST_FOREACH(ptr_env, &env_ready_queue)
f0108976:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f010897b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010897e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108982:	74 08                	je     f010898c <sched_exit_env+0xfe>
f0108984:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108987:	8b 40 44             	mov    0x44(%eax),%eax
f010898a:	eb 05                	jmp    f0108991 <sched_exit_env+0x103>
f010898c:	b8 00 00 00 00       	mov    $0x0,%eax
f0108991:	a3 c4 52 45 f0       	mov    %eax,0xf04552c4
f0108996:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f010899b:	85 c0                	test   %eax,%eax
f010899d:	75 87                	jne    f0108926 <sched_exit_env+0x98>
f010899f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01089a3:	75 81                	jne    f0108926 <sched_exit_env+0x98>
f01089a5:	eb 04                	jmp    f01089ab <sched_exit_env+0x11d>
		if(ptr_env->env_id == envId)
		{
			sched_remove_new(ptr_env);
			sched_insert_exit(ptr_env);
			if(isBufferingEnabled()) {cleanup_buffers(ptr_env);}
			return;
f01089a7:	90                   	nop
f01089a8:	eb 01                	jmp    f01089ab <sched_exit_env+0x11d>
			//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back to an exited env
			if (curenv->env_id == envId)
			{
				fos_scheduler();
			}
			return;
f01089aa:	90                   	nop
		}
	}
}
f01089ab:	c9                   	leave  
f01089ac:	c3                   	ret    

f01089ad <sched_kill_env>:

/*2015*/
void sched_kill_env(uint32 envId)
{
f01089ad:	55                   	push   %ebp
f01089ae:	89 e5                	mov    %esp,%ebp
f01089b0:	83 ec 18             	sub    $0x18,%esp
	struct Env* ptr_env=NULL;
f01089b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &env_new_queue)
f01089ba:	a1 ac 52 45 f0       	mov    0xf04552ac,%eax
f01089bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01089c2:	eb 65                	jmp    f0108a29 <sched_kill_env+0x7c>
	{
		if(ptr_env->env_id == envId)
f01089c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089c7:	8b 40 4c             	mov    0x4c(%eax),%eax
f01089ca:	3b 45 08             	cmp    0x8(%ebp),%eax
f01089cd:	75 52                	jne    f0108a21 <sched_kill_env+0x74>
		{
			cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f01089cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089d2:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f01089d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01089db:	8b 40 4c             	mov    0x4c(%eax),%eax
f01089de:	83 ec 04             	sub    $0x4,%esp
f01089e1:	52                   	push   %edx
f01089e2:	50                   	push   %eax
f01089e3:	68 48 1c 11 f0       	push   $0xf0111c48
f01089e8:	e8 6e d6 ff ff       	call   f010605b <cprintf>
f01089ed:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01089f0:	83 ec 0c             	sub    $0xc,%esp
f01089f3:	ff 75 f4             	pushl  -0xc(%ebp)
f01089f6:	e8 32 f8 ff ff       	call   f010822d <sched_remove_new>
f01089fb:	83 c4 10             	add    $0x10,%esp
			start_env_free(ptr_env);
f01089fe:	83 ec 0c             	sub    $0xc,%esp
f0108a01:	ff 75 f4             	pushl  -0xc(%ebp)
f0108a04:	e8 8b c9 ff ff       	call   f0105394 <start_env_free>
f0108a09:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0108a0c:	83 ec 0c             	sub    $0xc,%esp
f0108a0f:	68 cb 1b 11 f0       	push   $0xf0111bcb
f0108a14:	e8 42 d6 ff ff       	call   f010605b <cprintf>
f0108a19:	83 c4 10             	add    $0x10,%esp
			return;
f0108a1c:	e9 ad 01 00 00       	jmp    f0108bce <sched_kill_env+0x221>

/*2015*/
void sched_kill_env(uint32 envId)
{
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &env_new_queue)
f0108a21:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f0108a26:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108a29:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a2d:	74 08                	je     f0108a37 <sched_kill_env+0x8a>
f0108a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a32:	8b 40 44             	mov    0x44(%eax),%eax
f0108a35:	eb 05                	jmp    f0108a3c <sched_kill_env+0x8f>
f0108a37:	b8 00 00 00 00       	mov    $0x0,%eax
f0108a3c:	a3 b4 52 45 f0       	mov    %eax,0xf04552b4
f0108a41:	a1 b4 52 45 f0       	mov    0xf04552b4,%eax
f0108a46:	85 c0                	test   %eax,%eax
f0108a48:	0f 85 76 ff ff ff    	jne    f01089c4 <sched_kill_env+0x17>
f0108a4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a52:	0f 85 6c ff ff ff    	jne    f01089c4 <sched_kill_env+0x17>
			start_env_free(ptr_env);
			cprintf("DONE\n");
			return;
		}
	}
	ptr_env=NULL;
f0108a58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &env_ready_queue)
f0108a5f:	a1 bc 52 45 f0       	mov    0xf04552bc,%eax
f0108a64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108a67:	e9 8e 00 00 00       	jmp    f0108afa <sched_kill_env+0x14d>
	{
		if(ptr_env->env_id == envId)
f0108a6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a6f:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108a72:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108a75:	75 7b                	jne    f0108af2 <sched_kill_env+0x145>
		{
			cprintf("killing[%d] %s from the READY queue...", ptr_env->env_id, ptr_env->prog_name);
f0108a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a7a:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f0108a80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a83:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108a86:	83 ec 04             	sub    $0x4,%esp
f0108a89:	52                   	push   %edx
f0108a8a:	50                   	push   %eax
f0108a8b:	68 70 1c 11 f0       	push   $0xf0111c70
f0108a90:	e8 c6 d5 ff ff       	call   f010605b <cprintf>
f0108a95:	83 c4 10             	add    $0x10,%esp
			sched_remove_ready(ptr_env);
f0108a98:	83 ec 0c             	sub    $0xc,%esp
f0108a9b:	ff 75 f4             	pushl  -0xc(%ebp)
f0108a9e:	e8 79 f6 ff ff       	call   f010811c <sched_remove_ready>
f0108aa3:	83 c4 10             	add    $0x10,%esp
			start_env_free(ptr_env);
f0108aa6:	83 ec 0c             	sub    $0xc,%esp
f0108aa9:	ff 75 f4             	pushl  -0xc(%ebp)
f0108aac:	e8 e3 c8 ff ff       	call   f0105394 <start_env_free>
f0108ab1:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0108ab4:	83 ec 0c             	sub    $0xc,%esp
f0108ab7:	68 cb 1b 11 f0       	push   $0xf0111bcb
f0108abc:	e8 9a d5 ff ff       	call   f010605b <cprintf>
f0108ac1:	83 c4 10             	add    $0x10,%esp

			//If it's the curenv, then reset it and reinvoke the scheduler
			//as there's no meaning to return back to a killed env
			if (curenv->env_id == envId)
f0108ac4:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108ac9:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108acc:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108acf:	0f 85 f8 00 00 00    	jne    f0108bcd <sched_kill_env+0x220>
			{
				//lcr3(K_PHYSICAL_ADDRESS(ptr_page_directory));
				lcr3(phys_page_directory);
f0108ad5:	a1 98 52 45 f0       	mov    0xf0455298,%eax
f0108ada:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108add:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ae0:	0f 22 d8             	mov    %eax,%cr3
				curenv = NULL;
f0108ae3:	c7 05 38 a1 42 f0 00 	movl   $0x0,0xf042a138
f0108aea:	00 00 00 
				fos_scheduler();
f0108aed:	e8 3d f4 ff ff       	call   f0107f2f <fos_scheduler>
			cprintf("DONE\n");
			return;
		}
	}
	ptr_env=NULL;
	LIST_FOREACH(ptr_env, &env_ready_queue)
f0108af2:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f0108af7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108afa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108afe:	74 08                	je     f0108b08 <sched_kill_env+0x15b>
f0108b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b03:	8b 40 44             	mov    0x44(%eax),%eax
f0108b06:	eb 05                	jmp    f0108b0d <sched_kill_env+0x160>
f0108b08:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b0d:	a3 c4 52 45 f0       	mov    %eax,0xf04552c4
f0108b12:	a1 c4 52 45 f0       	mov    0xf04552c4,%eax
f0108b17:	85 c0                	test   %eax,%eax
f0108b19:	0f 85 4d ff ff ff    	jne    f0108a6c <sched_kill_env+0xbf>
f0108b1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108b23:	0f 85 43 ff ff ff    	jne    f0108a6c <sched_kill_env+0xbf>
				fos_scheduler();
			}
			return;
		}
	}
	ptr_env=NULL;
f0108b29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &env_exit_queue)
f0108b30:	a1 9c 52 45 f0       	mov    0xf045529c,%eax
f0108b35:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108b38:	eb 62                	jmp    f0108b9c <sched_kill_env+0x1ef>
	{
		if(ptr_env->env_id == envId)
f0108b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b3d:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108b40:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108b43:	75 4f                	jne    f0108b94 <sched_kill_env+0x1e7>
		{
			cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0108b45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b48:	8b 90 ec 02 00 00    	mov    0x2ec(%eax),%edx
f0108b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b51:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108b54:	83 ec 04             	sub    $0x4,%esp
f0108b57:	52                   	push   %edx
f0108b58:	50                   	push   %eax
f0108b59:	68 98 1c 11 f0       	push   $0xf0111c98
f0108b5e:	e8 f8 d4 ff ff       	call   f010605b <cprintf>
f0108b63:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f0108b66:	83 ec 0c             	sub    $0xc,%esp
f0108b69:	ff 75 f4             	pushl  -0xc(%ebp)
f0108b6c:	e8 9b f7 ff ff       	call   f010830c <sched_remove_exit>
f0108b71:	83 c4 10             	add    $0x10,%esp
			start_env_free(ptr_env);
f0108b74:	83 ec 0c             	sub    $0xc,%esp
f0108b77:	ff 75 f4             	pushl  -0xc(%ebp)
f0108b7a:	e8 15 c8 ff ff       	call   f0105394 <start_env_free>
f0108b7f:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0108b82:	83 ec 0c             	sub    $0xc,%esp
f0108b85:	68 cb 1b 11 f0       	push   $0xf0111bcb
f0108b8a:	e8 cc d4 ff ff       	call   f010605b <cprintf>
f0108b8f:	83 c4 10             	add    $0x10,%esp
			return;
f0108b92:	eb 3a                	jmp    f0108bce <sched_kill_env+0x221>
			}
			return;
		}
	}
	ptr_env=NULL;
	LIST_FOREACH(ptr_env, &env_exit_queue)
f0108b94:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f0108b99:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108b9c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ba0:	74 08                	je     f0108baa <sched_kill_env+0x1fd>
f0108ba2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ba5:	8b 40 44             	mov    0x44(%eax),%eax
f0108ba8:	eb 05                	jmp    f0108baf <sched_kill_env+0x202>
f0108baa:	b8 00 00 00 00       	mov    $0x0,%eax
f0108baf:	a3 a4 52 45 f0       	mov    %eax,0xf04552a4
f0108bb4:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f0108bb9:	85 c0                	test   %eax,%eax
f0108bbb:	0f 85 79 ff ff ff    	jne    f0108b3a <sched_kill_env+0x18d>
f0108bc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108bc5:	0f 85 6f ff ff ff    	jne    f0108b3a <sched_kill_env+0x18d>
f0108bcb:	eb 01                	jmp    f0108bce <sched_kill_env+0x221>
				//lcr3(K_PHYSICAL_ADDRESS(ptr_page_directory));
				lcr3(phys_page_directory);
				curenv = NULL;
				fos_scheduler();
			}
			return;
f0108bcd:	90                   	nop
			start_env_free(ptr_env);
			cprintf("DONE\n");
			return;
		}
	}
}
f0108bce:	c9                   	leave  
f0108bcf:	c3                   	ret    

f0108bd0 <clock_interrupt_handler>:


void clock_interrupt_handler()
{
f0108bd0:	55                   	push   %ebp
f0108bd1:	89 e5                	mov    %esp,%ebp
f0108bd3:	83 ec 08             	sub    $0x8,%esp
	if(isPageReplacmentAlgorithmLRU())
f0108bd6:	e8 9e e9 ff ff       	call   f0107579 <isPageReplacmentAlgorithmLRU>
f0108bdb:	85 c0                	test   %eax,%eax
f0108bdd:	74 05                	je     f0108be4 <clock_interrupt_handler+0x14>
	{
		update_WS_time_stamps();
f0108bdf:	e8 05 00 00 00       	call   f0108be9 <update_WS_time_stamps>
	}
	//cprintf("Clock Handler\n") ;
	fos_scheduler();
f0108be4:	e8 46 f3 ff ff       	call   f0107f2f <fos_scheduler>

f0108be9 <update_WS_time_stamps>:
	}

}
 */
void update_WS_time_stamps()
{
f0108be9:	55                   	push   %ebp
f0108bea:	89 e5                	mov    %esp,%ebp
f0108bec:	53                   	push   %ebx
f0108bed:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = curenv;
f0108bf0:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108bf5:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0108bf8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108bfc:	0f 84 bc 01 00 00    	je     f0108dbe <update_WS_time_stamps+0x1d5>
	{
		{
			int i ;
			for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0108c02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108c09:	e9 c7 00 00 00       	jmp    f0108cd5 <update_WS_time_stamps+0xec>
			{
				if( curr_env_ptr->ptr_pageWorkingSet[i].empty != 1)
f0108c0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108c11:	8b 48 78             	mov    0x78(%eax),%ecx
f0108c14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108c17:	89 d0                	mov    %edx,%eax
f0108c19:	01 c0                	add    %eax,%eax
f0108c1b:	01 d0                	add    %edx,%eax
f0108c1d:	c1 e0 02             	shl    $0x2,%eax
f0108c20:	01 c8                	add    %ecx,%eax
f0108c22:	8a 40 04             	mov    0x4(%eax),%al
f0108c25:	3c 01                	cmp    $0x1,%al
f0108c27:	0f 84 a5 00 00 00    	je     f0108cd2 <update_WS_time_stamps+0xe9>
				{
					//update the time if the page was referenced
					uint32 page_va = curr_env_ptr->ptr_pageWorkingSet[i].virtual_address ;
f0108c2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108c30:	8b 48 78             	mov    0x78(%eax),%ecx
f0108c33:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108c36:	89 d0                	mov    %edx,%eax
f0108c38:	01 c0                	add    %eax,%eax
f0108c3a:	01 d0                	add    %edx,%eax
f0108c3c:	c1 e0 02             	shl    $0x2,%eax
f0108c3f:	01 c8                	add    %ecx,%eax
f0108c41:	8b 00                	mov    (%eax),%eax
f0108c43:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr, page_va) ;
f0108c46:	83 ec 08             	sub    $0x8,%esp
f0108c49:	ff 75 e8             	pushl  -0x18(%ebp)
f0108c4c:	ff 75 ec             	pushl  -0x14(%ebp)
f0108c4f:	e8 c7 b6 ff ff       	call   f010431b <pt_get_page_permissions>
f0108c54:	83 c4 10             	add    $0x10,%esp
f0108c57:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = curr_env_ptr->ptr_pageWorkingSet[i].time_stamp;
f0108c5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108c5d:	8b 48 78             	mov    0x78(%eax),%ecx
f0108c60:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108c63:	89 d0                	mov    %edx,%eax
f0108c65:	01 c0                	add    %eax,%eax
f0108c67:	01 d0                	add    %edx,%eax
f0108c69:	c1 e0 02             	shl    $0x2,%eax
f0108c6c:	01 c8                	add    %ecx,%eax
f0108c6e:	8b 40 08             	mov    0x8(%eax),%eax
f0108c71:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0108c74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108c77:	83 e0 20             	and    $0x20,%eax
f0108c7a:	85 c0                	test   %eax,%eax
f0108c7c:	74 37                	je     f0108cb5 <update_WS_time_stamps+0xcc>
					{
						curr_env_ptr->ptr_pageWorkingSet[i].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0108c7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108c81:	8b 48 78             	mov    0x78(%eax),%ecx
f0108c84:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108c87:	89 d0                	mov    %edx,%eax
f0108c89:	01 c0                	add    %eax,%eax
f0108c8b:	01 d0                	add    %edx,%eax
f0108c8d:	c1 e0 02             	shl    $0x2,%eax
f0108c90:	01 c8                	add    %ecx,%eax
f0108c92:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108c95:	c1 ea 02             	shr    $0x2,%edx
f0108c98:	81 ca 00 00 00 80    	or     $0x80000000,%edx
f0108c9e:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr, page_va, 0 , PERM_USED) ;
f0108ca1:	6a 20                	push   $0x20
f0108ca3:	6a 00                	push   $0x0
f0108ca5:	ff 75 e8             	pushl  -0x18(%ebp)
f0108ca8:	ff 75 ec             	pushl  -0x14(%ebp)
f0108cab:	e8 07 b3 ff ff       	call   f0103fb7 <pt_set_page_permissions>
f0108cb0:	83 c4 10             	add    $0x10,%esp
f0108cb3:	eb 1d                	jmp    f0108cd2 <update_WS_time_stamps+0xe9>
					}
					else
					{
						curr_env_ptr->ptr_pageWorkingSet[i].time_stamp = (oldTimeStamp>>2);
f0108cb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108cb8:	8b 48 78             	mov    0x78(%eax),%ecx
f0108cbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108cbe:	89 d0                	mov    %edx,%eax
f0108cc0:	01 c0                	add    %eax,%eax
f0108cc2:	01 d0                	add    %edx,%eax
f0108cc4:	c1 e0 02             	shl    $0x2,%eax
f0108cc7:	01 c8                	add    %ecx,%eax
f0108cc9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0108ccc:	c1 ea 02             	shr    $0x2,%edx
f0108ccf:	89 50 08             	mov    %edx,0x8(%eax)

	if(curr_env_ptr != NULL)
	{
		{
			int i ;
			for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0108cd2:	ff 45 f4             	incl   -0xc(%ebp)
f0108cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108cd8:	8b 50 74             	mov    0x74(%eax),%edx
f0108cdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108cde:	39 c2                	cmp    %eax,%edx
f0108ce0:	0f 87 28 ff ff ff    	ja     f0108c0e <update_WS_time_stamps+0x25>
			}
		}

		{
			int t ;
			for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0108ce6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0108ced:	e9 c2 00 00 00       	jmp    f0108db4 <update_WS_time_stamps+0x1cb>
			{
				if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0108cf2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0108cf5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108cf8:	89 d0                	mov    %edx,%eax
f0108cfa:	01 c0                	add    %eax,%eax
f0108cfc:	01 d0                	add    %edx,%eax
f0108cfe:	c1 e0 02             	shl    $0x2,%eax
f0108d01:	01 c8                	add    %ecx,%eax
f0108d03:	83 e8 80             	sub    $0xffffff80,%eax
f0108d06:	8a 00                	mov    (%eax),%al
f0108d08:	3c 01                	cmp    $0x1,%al
f0108d0a:	0f 84 a1 00 00 00    	je     f0108db1 <update_WS_time_stamps+0x1c8>
				{
					//update the time if the page was referenced
					uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0108d10:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0108d13:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108d16:	89 d0                	mov    %edx,%eax
f0108d18:	01 c0                	add    %eax,%eax
f0108d1a:	01 d0                	add    %edx,%eax
f0108d1c:	c1 e0 02             	shl    $0x2,%eax
f0108d1f:	01 c8                	add    %ecx,%eax
f0108d21:	83 c0 7c             	add    $0x7c,%eax
f0108d24:	8b 00                	mov    (%eax),%eax
f0108d26:	89 45 dc             	mov    %eax,-0x24(%ebp)
					uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0108d29:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0108d2c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108d2f:	89 d0                	mov    %edx,%eax
f0108d31:	01 c0                	add    %eax,%eax
f0108d33:	01 d0                	add    %edx,%eax
f0108d35:	c1 e0 02             	shl    $0x2,%eax
f0108d38:	01 c8                	add    %ecx,%eax
f0108d3a:	05 84 00 00 00       	add    $0x84,%eax
f0108d3f:	8b 00                	mov    (%eax),%eax
f0108d41:	89 45 d8             	mov    %eax,-0x28(%ebp)

					if (pd_is_table_used(curr_env_ptr, table_va))
f0108d44:	83 ec 08             	sub    $0x8,%esp
f0108d47:	ff 75 dc             	pushl  -0x24(%ebp)
f0108d4a:	ff 75 ec             	pushl  -0x14(%ebp)
f0108d4d:	e8 c9 b1 ff ff       	call   f0103f1b <pd_is_table_used>
f0108d52:	83 c4 10             	add    $0x10,%esp
f0108d55:	85 c0                	test   %eax,%eax
f0108d57:	74 38                	je     f0108d91 <update_WS_time_stamps+0x1a8>
					{
						curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0108d59:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108d5c:	c1 e8 02             	shr    $0x2,%eax
f0108d5f:	0d 00 00 00 80       	or     $0x80000000,%eax
f0108d64:	89 c1                	mov    %eax,%ecx
f0108d66:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0108d69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108d6c:	89 d0                	mov    %edx,%eax
f0108d6e:	01 c0                	add    %eax,%eax
f0108d70:	01 d0                	add    %edx,%eax
f0108d72:	c1 e0 02             	shl    $0x2,%eax
f0108d75:	01 d8                	add    %ebx,%eax
f0108d77:	05 84 00 00 00       	add    $0x84,%eax
f0108d7c:	89 08                	mov    %ecx,(%eax)
						pd_set_table_unused(curr_env_ptr, table_va);
f0108d7e:	83 ec 08             	sub    $0x8,%esp
f0108d81:	ff 75 dc             	pushl  -0x24(%ebp)
f0108d84:	ff 75 ec             	pushl  -0x14(%ebp)
f0108d87:	e8 b2 b1 ff ff       	call   f0103f3e <pd_set_table_unused>
f0108d8c:	83 c4 10             	add    $0x10,%esp
f0108d8f:	eb 20                	jmp    f0108db1 <update_WS_time_stamps+0x1c8>
					}
					else
					{
						curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0108d91:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108d94:	c1 e8 02             	shr    $0x2,%eax
f0108d97:	89 c1                	mov    %eax,%ecx
f0108d99:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0108d9c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108d9f:	89 d0                	mov    %edx,%eax
f0108da1:	01 c0                	add    %eax,%eax
f0108da3:	01 d0                	add    %edx,%eax
f0108da5:	c1 e0 02             	shl    $0x2,%eax
f0108da8:	01 d8                	add    %ebx,%eax
f0108daa:	05 84 00 00 00       	add    $0x84,%eax
f0108daf:	89 08                	mov    %ecx,(%eax)
			}
		}

		{
			int t ;
			for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0108db1:	ff 45 f0             	incl   -0x10(%ebp)
f0108db4:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0108db8:	0f 8e 34 ff ff ff    	jle    f0108cf2 <update_WS_time_stamps+0x109>
					}
				}
			}
		}
	}
}
f0108dbe:	90                   	nop
f0108dbf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108dc2:	c9                   	leave  
f0108dc3:	c3                   	ret    

f0108dc4 <to_frame_number>:
struct Frame_Info *get_frame_info(uint32 *ptr_page_directory, void *virtual_address, uint32 **ptr_page_table);
void decrement_references(struct Frame_Info* ptr_frame_info);
void initialize_frame_info(struct Frame_Info *ptr_frame_info);

static inline uint32 to_frame_number(struct Frame_Info *ptr_frame_info)
{
f0108dc4:	55                   	push   %ebp
f0108dc5:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108dc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0108dca:	8b 15 84 52 45 f0    	mov    0xf0455284,%edx
f0108dd0:	29 d0                	sub    %edx,%eax
f0108dd2:	c1 f8 03             	sar    $0x3,%eax
f0108dd5:	89 c2                	mov    %eax,%edx
f0108dd7:	89 d0                	mov    %edx,%eax
f0108dd9:	c1 e0 02             	shl    $0x2,%eax
f0108ddc:	01 d0                	add    %edx,%eax
f0108dde:	c1 e0 02             	shl    $0x2,%eax
f0108de1:	01 d0                	add    %edx,%eax
f0108de3:	c1 e0 02             	shl    $0x2,%eax
f0108de6:	01 d0                	add    %edx,%eax
f0108de8:	89 c1                	mov    %eax,%ecx
f0108dea:	c1 e1 08             	shl    $0x8,%ecx
f0108ded:	01 c8                	add    %ecx,%eax
f0108def:	89 c1                	mov    %eax,%ecx
f0108df1:	c1 e1 10             	shl    $0x10,%ecx
f0108df4:	01 c8                	add    %ecx,%eax
f0108df6:	01 c0                	add    %eax,%eax
f0108df8:	01 d0                	add    %edx,%eax
}
f0108dfa:	5d                   	pop    %ebp
f0108dfb:	c3                   	ret    

f0108dfc <to_physical_address>:

static inline uint32 to_physical_address(struct Frame_Info *ptr_frame_info)
{
f0108dfc:	55                   	push   %ebp
f0108dfd:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108dff:	ff 75 08             	pushl  0x8(%ebp)
f0108e02:	e8 bd ff ff ff       	call   f0108dc4 <to_frame_number>
f0108e07:	83 c4 04             	add    $0x4,%esp
f0108e0a:	c1 e0 0c             	shl    $0xc,%eax
}
f0108e0d:	c9                   	leave  
f0108e0e:	c3                   	ret    

f0108e0f <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len)
{
f0108e0f:	55                   	push   %ebp
f0108e10:	89 e5                	mov    %esp,%ebp
f0108e12:	83 ec 08             	sub    $0x8,%esp
	// Destroy the environment if not.

	// LAB 3: Your code here.

	// Print the string supplied by the user.
	cprintf("[%s %d] %.*s",curenv->prog_name, curenv->env_id, len, s);
f0108e15:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108e1a:	8b 50 4c             	mov    0x4c(%eax),%edx
f0108e1d:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108e22:	8b 80 ec 02 00 00    	mov    0x2ec(%eax),%eax
f0108e28:	83 ec 0c             	sub    $0xc,%esp
f0108e2b:	ff 75 08             	pushl  0x8(%ebp)
f0108e2e:	ff 75 0c             	pushl  0xc(%ebp)
f0108e31:	52                   	push   %edx
f0108e32:	50                   	push   %eax
f0108e33:	68 c0 1c 11 f0       	push   $0xf0111cc0
f0108e38:	e8 1e d2 ff ff       	call   f010605b <cprintf>
f0108e3d:	83 c4 20             	add    $0x20,%esp
	//cprintf("%.*s", len, s);
}
f0108e40:	90                   	nop
f0108e41:	c9                   	leave  
f0108e42:	c3                   	ret    

f0108e43 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f0108e43:	55                   	push   %ebp
f0108e44:	89 e5                	mov    %esp,%ebp
f0108e46:	83 ec 18             	sub    $0x18,%esp
f0108e49:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e4c:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f0108e4f:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f0108e53:	83 ec 08             	sub    $0x8,%esp
f0108e56:	50                   	push   %eax
f0108e57:	68 cd 1c 11 f0       	push   $0xf0111ccd
f0108e5c:	e8 fa d1 ff ff       	call   f010605b <cprintf>
f0108e61:	83 c4 10             	add    $0x10,%esp
}
f0108e64:	90                   	nop
f0108e65:	c9                   	leave  
f0108e66:	c3                   	ret    

f0108e67 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f0108e67:	55                   	push   %ebp
f0108e68:	89 e5                	mov    %esp,%ebp
f0108e6a:	83 ec 18             	sub    $0x18,%esp
	//while ((c = cons_getc()) == 0)
	//2013: instead of busywaiting inside kernel code , we moved the waiting to user code,
	// this allows any other running user programs to run beacause the clock interrupt works in user mode
	// (the kernel system call by default disables the interrupts, so any loops inside the kernel while
	// handling an interrupt will cause the clock interrupt to be disabled)
	c = cons_getc2();
f0108e6d:	e8 8e 7a ff ff       	call   f0100900 <cons_getc2>
f0108e72:	89 45 f4             	mov    %eax,-0xc(%ebp)
	/* do nothing */;

	return c;
f0108e75:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108e78:	c9                   	leave  
f0108e79:	c3                   	ret    

f0108e7a <sys_getenvid>:


// Returns the current environment's envid.
static int32 sys_getenvid(void)
{
f0108e7a:	55                   	push   %ebp
f0108e7b:	89 e5                	mov    %esp,%ebp
	//return curenv->env_id;
	return (curenv - envs) ;
f0108e7d:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108e82:	89 c2                	mov    %eax,%edx
f0108e84:	a1 34 a1 42 f0       	mov    0xf042a134,%eax
f0108e89:	29 c2                	sub    %eax,%edx
f0108e8b:	89 d0                	mov    %edx,%eax
f0108e8d:	c1 f8 03             	sar    $0x3,%eax
f0108e90:	89 c2                	mov    %eax,%edx
f0108e92:	89 d0                	mov    %edx,%eax
f0108e94:	c1 e0 03             	shl    $0x3,%eax
f0108e97:	01 d0                	add    %edx,%eax
f0108e99:	01 c0                	add    %eax,%eax
f0108e9b:	01 d0                	add    %edx,%eax
f0108e9d:	c1 e0 03             	shl    $0x3,%eax
f0108ea0:	01 d0                	add    %edx,%eax
f0108ea2:	89 c1                	mov    %eax,%ecx
f0108ea4:	c1 e1 08             	shl    $0x8,%ecx
f0108ea7:	01 c8                	add    %ecx,%eax
f0108ea9:	01 c0                	add    %eax,%eax
f0108eab:	01 d0                	add    %edx,%eax
f0108ead:	01 c0                	add    %eax,%eax
f0108eaf:	01 d0                	add    %edx,%eax
f0108eb1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0108eb8:	01 d0                	add    %edx,%eax
f0108eba:	89 c2                	mov    %eax,%edx
f0108ebc:	c1 e2 09             	shl    $0x9,%edx
f0108ebf:	29 c2                	sub    %eax,%edx
f0108ec1:	89 d0                	mov    %edx,%eax
f0108ec3:	f7 d8                	neg    %eax
}
f0108ec5:	5d                   	pop    %ebp
f0108ec6:	c3                   	ret    

f0108ec7 <sys_env_destroy>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_env_destroy(int32 envid)
{
f0108ec7:	55                   	push   %ebp
f0108ec8:	89 e5                	mov    %esp,%ebp
f0108eca:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 0)) < 0)
f0108ecd:	83 ec 04             	sub    $0x4,%esp
f0108ed0:	6a 00                	push   $0x0
f0108ed2:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108ed5:	50                   	push   %eax
f0108ed6:	ff 75 08             	pushl  0x8(%ebp)
f0108ed9:	e8 d9 93 ff ff       	call   f01022b7 <envid2env>
f0108ede:	83 c4 10             	add    $0x10,%esp
f0108ee1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108ee4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ee8:	79 05                	jns    f0108eef <sys_env_destroy+0x28>
		return r;
f0108eea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108eed:	eb 5e                	jmp    f0108f4d <sys_env_destroy+0x86>

	if (e == curenv)
f0108eef:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108ef2:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108ef7:	39 c2                	cmp    %eax,%edx
f0108ef9:	75 1b                	jne    f0108f16 <sys_env_destroy+0x4f>
	{
		cprintf("[%08x] exiting gracefully\n", curenv->env_id);
f0108efb:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108f00:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108f03:	83 ec 08             	sub    $0x8,%esp
f0108f06:	50                   	push   %eax
f0108f07:	68 d0 1c 11 f0       	push   $0xf0111cd0
f0108f0c:	e8 4a d1 ff ff       	call   f010605b <cprintf>
f0108f11:	83 c4 10             	add    $0x10,%esp
f0108f14:	eb 20                	jmp    f0108f36 <sys_env_destroy+0x6f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
f0108f16:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f19:	8b 50 4c             	mov    0x4c(%eax),%edx
f0108f1c:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108f21:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108f24:	83 ec 04             	sub    $0x4,%esp
f0108f27:	52                   	push   %edx
f0108f28:	50                   	push   %eax
f0108f29:	68 eb 1c 11 f0       	push   $0xf0111ceb
f0108f2e:	e8 28 d1 ff ff       	call   f010605b <cprintf>
f0108f33:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f0108f36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f39:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108f3c:	83 ec 0c             	sub    $0xc,%esp
f0108f3f:	50                   	push   %eax
f0108f40:	e8 68 fa ff ff       	call   f01089ad <sched_kill_env>
f0108f45:	83 c4 10             	add    $0x10,%esp

	return 0;
f0108f48:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108f4d:	c9                   	leave  
f0108f4e:	c3                   	ret    

f0108f4f <sys_env_exit>:

static void sys_env_exit()
{
f0108f4f:	55                   	push   %ebp
f0108f50:	89 e5                	mov    %esp,%ebp
f0108f52:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f0108f55:	e8 e0 cb ff ff       	call   f0105b3a <env_exit>
	//env_run_cmd_prmpt();
}
f0108f5a:	90                   	nop
f0108f5b:	c9                   	leave  
f0108f5c:	c3                   	ret    

f0108f5d <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f0108f5d:	55                   	push   %ebp
f0108f5e:	89 e5                	mov    %esp,%ebp
f0108f60:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = curenv;
f0108f63:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0108f68:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct Frame_Info *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f0108f6b:	83 ec 0c             	sub    $0xc,%esp
f0108f6e:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0108f71:	50                   	push   %eax
f0108f72:	e8 21 9c ff ff       	call   f0102b98 <allocate_frame>
f0108f77:	83 c4 10             	add    $0x10,%esp
f0108f7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f0108f7d:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f0108f81:	75 08                	jne    f0108f8b <__sys_allocate_page+0x2e>
		return r ;
f0108f83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f86:	e9 e8 00 00 00       	jmp    f0109073 <__sys_allocate_page+0x116>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f0108f8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f8e:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0108f93:	77 0c                	ja     f0108fa1 <__sys_allocate_page+0x44>
f0108f95:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f98:	25 ff 0f 00 00       	and    $0xfff,%eax
f0108f9d:	85 c0                	test   %eax,%eax
f0108f9f:	74 0a                	je     f0108fab <__sys_allocate_page+0x4e>
		return E_INVAL;
f0108fa1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f0108fa6:	e9 c8 00 00 00       	jmp    f0109073 <__sys_allocate_page+0x116>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f0108fab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108fae:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f0108fb3:	83 f8 04             	cmp    $0x4,%eax
f0108fb6:	74 0a                	je     f0108fc2 <__sys_allocate_page+0x65>
		return E_INVAL;
f0108fb8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f0108fbd:	e9 b1 00 00 00       	jmp    f0109073 <__sys_allocate_page+0x116>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f0108fc2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108fc5:	83 ec 0c             	sub    $0xc,%esp
f0108fc8:	50                   	push   %eax
f0108fc9:	e8 2e fe ff ff       	call   f0108dfc <to_physical_address>
f0108fce:	83 c4 10             	add    $0x10,%esp
f0108fd1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(USE_KHEAP)
	{
		//FIX: we should implement a better solution for this, but for now
			//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
			//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, (void*)USER_LIMIT, PERM_WRITEABLE);
f0108fd4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108fd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108fda:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108fdd:	6a 02                	push   $0x2
f0108fdf:	68 00 00 80 ef       	push   $0xef800000
f0108fe4:	52                   	push   %edx
f0108fe5:	50                   	push   %eax
f0108fe6:	e8 b0 9f ff ff       	call   f0102f9b <map_frame>
f0108feb:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f0108fee:	83 ec 04             	sub    $0x4,%esp
f0108ff1:	68 00 10 00 00       	push   $0x1000
f0108ff6:	6a 00                	push   $0x0
f0108ff8:	68 00 00 80 ef       	push   $0xef800000
f0108ffd:	e8 9c 5c 00 00       	call   f010ec9e <memset>
f0109002:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f0109005:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0109008:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010900b:	8b 40 08             	mov    0x8(%eax),%eax
f010900e:	40                   	inc    %eax
f010900f:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, (void*)USER_LIMIT);
f0109013:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109016:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109019:	83 ec 08             	sub    $0x8,%esp
f010901c:	68 00 00 80 ef       	push   $0xef800000
f0109021:	50                   	push   %eax
f0109022:	e8 a3 a0 ff ff       	call   f01030ca <unmap_frame>
f0109027:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010902a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010902d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109030:	8b 40 08             	mov    0x8(%eax),%eax
f0109033:	48                   	dec    %eax
f0109034:	66 89 42 08          	mov    %ax,0x8(%edx)
	else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}

	r = map_frame(e->env_page_directory, ptr_frame_info, va, perm) ;
f0109038:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010903b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010903e:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109041:	ff 75 0c             	pushl  0xc(%ebp)
f0109044:	ff 75 08             	pushl  0x8(%ebp)
f0109047:	52                   	push   %edx
f0109048:	50                   	push   %eax
f0109049:	e8 4d 9f ff ff       	call   f0102f9b <map_frame>
f010904e:	83 c4 10             	add    $0x10,%esp
f0109051:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f0109054:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f0109058:	75 14                	jne    f010906e <__sys_allocate_page+0x111>
	{
		decrement_references(ptr_frame_info);
f010905a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010905d:	83 ec 0c             	sub    $0xc,%esp
f0109060:	50                   	push   %eax
f0109061:	e8 7a 9c ff ff       	call   f0102ce0 <decrement_references>
f0109066:	83 c4 10             	add    $0x10,%esp
		return r;
f0109069:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010906c:	eb 05                	jmp    f0109073 <__sys_allocate_page+0x116>
	}
	return 0 ;
f010906e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109073:	c9                   	leave  
f0109074:	c3                   	ret    

f0109075 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f0109075:	55                   	push   %ebp
f0109076:	89 e5                	mov    %esp,%ebp
f0109078:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010907b:	83 ec 04             	sub    $0x4,%esp
f010907e:	68 03 1d 11 f0       	push   $0xf0111d03
f0109083:	68 d4 00 00 00       	push   $0xd4
f0109088:	68 21 1d 11 f0       	push   $0xf0111d21
f010908d:	e8 ca 70 ff ff       	call   f010015c <_panic>

f0109092 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f0109092:	55                   	push   %ebp
f0109093:	89 e5                	mov    %esp,%ebp
f0109095:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f0109098:	83 ec 04             	sub    $0x4,%esp
f010909b:	68 30 1d 11 f0       	push   $0xf0111d30
f01090a0:	68 e3 00 00 00       	push   $0xe3
f01090a5:	68 21 1d 11 f0       	push   $0xf0111d21
f01090aa:	e8 ad 70 ff ff       	call   f010015c <_panic>

f01090af <sys_calculate_required_frames>:
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f01090af:	55                   	push   %ebp
f01090b0:	89 e5                	mov    %esp,%ebp
f01090b2:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(curenv->env_page_directory, start_virtual_address, size);
f01090b5:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01090ba:	8b 40 5c             	mov    0x5c(%eax),%eax
f01090bd:	83 ec 04             	sub    $0x4,%esp
f01090c0:	ff 75 0c             	pushl  0xc(%ebp)
f01090c3:	ff 75 08             	pushl  0x8(%ebp)
f01090c6:	50                   	push   %eax
f01090c7:	e8 a0 a3 ff ff       	call   f010346c <calculate_required_frames>
f01090cc:	83 c4 10             	add    $0x10,%esp
}
f01090cf:	c9                   	leave  
f01090d0:	c3                   	ret    

f01090d1 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f01090d1:	55                   	push   %ebp
f01090d2:	89 e5                	mov    %esp,%ebp
f01090d4:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f01090d7:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01090da:	83 ec 0c             	sub    $0xc,%esp
f01090dd:	50                   	push   %eax
f01090de:	e8 39 a4 ff ff       	call   f010351c <calculate_available_frames>
f01090e3:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f01090e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01090e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090ec:	01 d0                	add    %edx,%eax

}
f01090ee:	c9                   	leave  
f01090ef:	c3                   	ret    

f01090f0 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f01090f0:	55                   	push   %ebp
f01090f1:	89 e5                	mov    %esp,%ebp
f01090f3:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f01090f6:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01090f9:	83 ec 0c             	sub    $0xc,%esp
f01090fc:	50                   	push   %eax
f01090fd:	e8 1a a4 ff ff       	call   f010351c <calculate_available_frames>
f0109102:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f0109105:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109108:	c9                   	leave  
f0109109:	c3                   	ret    

f010910a <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010910a:	55                   	push   %ebp
f010910b:	89 e5                	mov    %esp,%ebp
f010910d:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f0109110:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0109113:	83 ec 0c             	sub    $0xc,%esp
f0109116:	50                   	push   %eax
f0109117:	e8 00 a4 ff ff       	call   f010351c <calculate_available_frames>
f010911c:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010911f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0109122:	c9                   	leave  
f0109123:	c3                   	ret    

f0109124 <sys_pf_calculate_allocated_pages>:

int sys_pf_calculate_allocated_pages(void)
{
f0109124:	55                   	push   %ebp
f0109125:	89 e5                	mov    %esp,%ebp
f0109127:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(curenv);
f010912a:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010912f:	83 ec 0c             	sub    $0xc,%esp
f0109132:	50                   	push   %eax
f0109133:	e8 45 15 00 00       	call   f010a67d <pf_calculate_allocated_pages>
f0109138:	83 c4 10             	add    $0x10,%esp
}
f010913b:	c9                   	leave  
f010913c:	c3                   	ret    

f010913d <sys_freeMem>:

void sys_freeMem(uint32 virtual_address, uint32 size)
{
f010913d:	55                   	push   %ebp
f010913e:	89 e5                	mov    %esp,%ebp
f0109140:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f0109143:	e8 c3 e4 ff ff       	call   f010760b <isBufferingEnabled>
f0109148:	85 c0                	test   %eax,%eax
f010914a:	74 19                	je     f0109165 <sys_freeMem+0x28>
	{
		__freeMem_with_buffering(curenv, virtual_address, size);
f010914c:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0109151:	83 ec 04             	sub    $0x4,%esp
f0109154:	ff 75 0c             	pushl  0xc(%ebp)
f0109157:	ff 75 08             	pushl  0x8(%ebp)
f010915a:	50                   	push   %eax
f010915b:	e8 e9 a2 ff ff       	call   f0103449 <__freeMem_with_buffering>
f0109160:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		freeMem(curenv, virtual_address, size);
	}
	return;
f0109163:	eb 18                	jmp    f010917d <sys_freeMem+0x40>
	{
		__freeMem_with_buffering(curenv, virtual_address, size);
	}
	else
	{
		freeMem(curenv, virtual_address, size);
f0109165:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010916a:	83 ec 04             	sub    $0x4,%esp
f010916d:	ff 75 0c             	pushl  0xc(%ebp)
f0109170:	ff 75 08             	pushl  0x8(%ebp)
f0109173:	50                   	push   %eax
f0109174:	e8 30 a1 ff ff       	call   f01032a9 <freeMem>
f0109179:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010917c:	90                   	nop
}
f010917d:	c9                   	leave  
f010917e:	c3                   	ret    

f010917f <sys_allocateMem>:

void sys_allocateMem(uint32 virtual_address, uint32 size)
{
f010917f:	55                   	push   %ebp
f0109180:	89 e5                	mov    %esp,%ebp
f0109182:	83 ec 08             	sub    $0x8,%esp
	allocateMem(curenv, virtual_address, size);
f0109185:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010918a:	83 ec 04             	sub    $0x4,%esp
f010918d:	ff 75 0c             	pushl  0xc(%ebp)
f0109190:	ff 75 08             	pushl  0x8(%ebp)
f0109193:	50                   	push   %eax
f0109194:	e8 95 a0 ff ff       	call   f010322e <allocateMem>
f0109199:	83 c4 10             	add    $0x10,%esp
	return;
f010919c:	90                   	nop
}
f010919d:	c9                   	leave  
f010919e:	c3                   	ret    

f010919f <sys_disable_interrupt>:

//NEW!! 2012...
void sys_disable_interrupt()
{
f010919f:	55                   	push   %ebp
f01091a0:	89 e5                	mov    %esp,%ebp
	curenv->env_tf.tf_eflags &= ~FL_IF ;
f01091a2:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01091a7:	8b 15 38 a1 42 f0    	mov    0xf042a138,%edx
f01091ad:	8b 52 38             	mov    0x38(%edx),%edx
f01091b0:	80 e6 fd             	and    $0xfd,%dh
f01091b3:	89 50 38             	mov    %edx,0x38(%eax)
}
f01091b6:	90                   	nop
f01091b7:	5d                   	pop    %ebp
f01091b8:	c3                   	ret    

f01091b9 <sys_enable_interrupt>:
void sys_enable_interrupt()
{
f01091b9:	55                   	push   %ebp
f01091ba:	89 e5                	mov    %esp,%ebp
	curenv->env_tf.tf_eflags |= FL_IF ;
f01091bc:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01091c1:	8b 15 38 a1 42 f0    	mov    0xf042a138,%edx
f01091c7:	8b 52 38             	mov    0x38(%edx),%edx
f01091ca:	80 ce 02             	or     $0x2,%dh
f01091cd:	89 50 38             	mov    %edx,0x38(%eax)
}
f01091d0:	90                   	nop
f01091d1:	5d                   	pop    %ebp
f01091d2:	c3                   	ret    

f01091d3 <sys_clearFFL>:

void sys_clearFFL()
{
f01091d3:	55                   	push   %ebp
f01091d4:	89 e5                	mov    %esp,%ebp
f01091d6:	83 ec 18             	sub    $0x18,%esp
	int size = LIST_SIZE(&free_frame_list) ;
f01091d9:	a1 80 52 45 f0       	mov    0xf0455280,%eax
f01091de:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int i = 0 ;
f01091e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Frame_Info* ptr_tmp_FI ;
	for (; i < size ; i++)
f01091e8:	eb 12                	jmp    f01091fc <sys_clearFFL+0x29>
	{
		allocate_frame(&ptr_tmp_FI) ;
f01091ea:	83 ec 0c             	sub    $0xc,%esp
f01091ed:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01091f0:	50                   	push   %eax
f01091f1:	e8 a2 99 ff ff       	call   f0102b98 <allocate_frame>
f01091f6:	83 c4 10             	add    $0x10,%esp
void sys_clearFFL()
{
	int size = LIST_SIZE(&free_frame_list) ;
	int i = 0 ;
	struct Frame_Info* ptr_tmp_FI ;
	for (; i < size ; i++)
f01091f9:	ff 45 f4             	incl   -0xc(%ebp)
f01091fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091ff:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109202:	7c e6                	jl     f01091ea <sys_clearFFL+0x17>
	{
		allocate_frame(&ptr_tmp_FI) ;
	}
}
f0109204:	90                   	nop
f0109205:	c9                   	leave  
f0109206:	c3                   	ret    

f0109207 <sys_createSemaphore>:

int sys_createSemaphore(char* semaphoreName, uint32 initialValue)
{
f0109207:	55                   	push   %ebp
f0109208:	89 e5                	mov    %esp,%ebp
f010920a:	83 ec 08             	sub    $0x8,%esp
	return createSemaphore(semaphoreName, initialValue);
f010920d:	83 ec 08             	sub    $0x8,%esp
f0109210:	ff 75 0c             	pushl  0xc(%ebp)
f0109213:	ff 75 08             	pushl  0x8(%ebp)
f0109216:	e8 27 18 00 00       	call   f010aa42 <createSemaphore>
f010921b:	83 c4 10             	add    $0x10,%esp
}
f010921e:	c9                   	leave  
f010921f:	c3                   	ret    

f0109220 <sys_waitSemaphore>:

void sys_waitSemaphore(char* semaphoreName)
{
f0109220:	55                   	push   %ebp
f0109221:	89 e5                	mov    %esp,%ebp
f0109223:	83 ec 08             	sub    $0x8,%esp
	waitSemaphore(semaphoreName);
f0109226:	83 ec 0c             	sub    $0xc,%esp
f0109229:	ff 75 08             	pushl  0x8(%ebp)
f010922c:	e8 2b 18 00 00       	call   f010aa5c <waitSemaphore>
f0109231:	83 c4 10             	add    $0x10,%esp
}
f0109234:	90                   	nop
f0109235:	c9                   	leave  
f0109236:	c3                   	ret    

f0109237 <sys_signalSemaphore>:

void sys_signalSemaphore(char* semaphoreName)
{
f0109237:	55                   	push   %ebp
f0109238:	89 e5                	mov    %esp,%ebp
f010923a:	83 ec 08             	sub    $0x8,%esp
	signalSemaphore(semaphoreName);
f010923d:	83 ec 0c             	sub    $0xc,%esp
f0109240:	ff 75 08             	pushl  0x8(%ebp)
f0109243:	e8 2e 18 00 00       	call   f010aa76 <signalSemaphore>
f0109248:	83 c4 10             	add    $0x10,%esp
}
f010924b:	90                   	nop
f010924c:	c9                   	leave  
f010924d:	c3                   	ret    

f010924e <sys_getSemaphoreValue>:

int sys_getSemaphoreValue(char* semaphoreName)
{
f010924e:	55                   	push   %ebp
f010924f:	89 e5                	mov    %esp,%ebp
f0109251:	83 ec 18             	sub    $0x18,%esp
	int semNo = getSemaphoreNumber(semaphoreName);
f0109254:	83 ec 0c             	sub    $0xc,%esp
f0109257:	ff 75 08             	pushl  0x8(%ebp)
f010925a:	e8 7b 17 00 00       	call   f010a9da <getSemaphoreNumber>
f010925f:	83 c4 10             	add    $0x10,%esp
f0109262:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(semNo>=0 && semNo < nSemaphores) ;
f0109265:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109269:	78 0a                	js     f0109275 <sys_getSemaphoreValue+0x27>
f010926b:	a1 e4 52 45 f0       	mov    0xf04552e4,%eax
f0109270:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0109273:	7c 19                	jl     f010928e <sys_getSemaphoreValue+0x40>
f0109275:	68 50 1d 11 f0       	push   $0xf0111d50
f010927a:	68 70 1d 11 f0       	push   $0xf0111d70
f010927f:	68 3f 01 00 00       	push   $0x13f
f0109284:	68 21 1d 11 f0       	push   $0xf0111d21
f0109289:	e8 ce 6e ff ff       	call   f010015c <_panic>

	return semaphores[semNo].value ;
f010928e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109291:	89 d0                	mov    %edx,%eax
f0109293:	c1 e0 02             	shl    $0x2,%eax
f0109296:	01 d0                	add    %edx,%eax
f0109298:	01 c0                	add    %eax,%eax
f010929a:	01 d0                	add    %edx,%eax
f010929c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01092a3:	01 c8                	add    %ecx,%eax
f01092a5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01092ac:	01 c8                	add    %ecx,%eax
f01092ae:	01 d0                	add    %edx,%eax
f01092b0:	05 d0 fb 4b f0       	add    $0xf04bfbd0,%eax
f01092b5:	8b 00                	mov    (%eax),%eax
}
f01092b7:	c9                   	leave  
f01092b8:	c3                   	ret    

f01092b9 <sys_createSharedObject>:

int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void** returned_shared_address)
{
f01092b9:	55                   	push   %ebp
f01092ba:	89 e5                	mov    %esp,%ebp
f01092bc:	83 ec 18             	sub    $0x18,%esp
f01092bf:	8b 45 10             	mov    0x10(%ebp),%eax
f01092c2:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(shareName, size, isWritable, returned_shared_address);
f01092c5:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
f01092c9:	ff 75 14             	pushl  0x14(%ebp)
f01092cc:	50                   	push   %eax
f01092cd:	ff 75 0c             	pushl  0xc(%ebp)
f01092d0:	ff 75 08             	pushl  0x8(%ebp)
f01092d3:	e8 f8 18 00 00       	call   f010abd0 <createSharedObject>
f01092d8:	83 c4 10             	add    $0x10,%esp
}
f01092db:	c9                   	leave  
f01092dc:	c3                   	ret    

f01092dd <sys_getSharedObject>:


int sys_getSharedObject(char* shareName, void** returned_shared_address)
{
f01092dd:	55                   	push   %ebp
f01092de:	89 e5                	mov    %esp,%ebp
f01092e0:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(shareName, returned_shared_address);
f01092e3:	83 ec 08             	sub    $0x8,%esp
f01092e6:	ff 75 0c             	pushl  0xc(%ebp)
f01092e9:	ff 75 08             	pushl  0x8(%ebp)
f01092ec:	e8 07 19 00 00       	call   f010abf8 <getSharedObject>
f01092f1:	83 c4 10             	add    $0x10,%esp
}
f01092f4:	c9                   	leave  
f01092f5:	c3                   	ret    

f01092f6 <sys_freeSharedObject>:

int sys_freeSharedObject(char* shareName)
{
f01092f6:	55                   	push   %ebp
f01092f7:	89 e5                	mov    %esp,%ebp
f01092f9:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(shareName);
f01092fc:	83 ec 0c             	sub    $0xc,%esp
f01092ff:	ff 75 08             	pushl  0x8(%ebp)
f0109302:	e8 13 19 00 00       	call   f010ac1a <freeSharedObject>
f0109307:	83 c4 10             	add    $0x10,%esp
}
f010930a:	c9                   	leave  
f010930b:	c3                   	ret    

f010930c <sys_getCurrentSharedAddress>:

uint32 sys_getCurrentSharedAddress()
{
f010930c:	55                   	push   %ebp
f010930d:	89 e5                	mov    %esp,%ebp
	return curenv->shared_free_address;
f010930f:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f0109314:	8b 80 f0 02 00 00    	mov    0x2f0(%eax),%eax
}
f010931a:	5d                   	pop    %ebp
f010931b:	c3                   	ret    

f010931c <sys_getMaxShares>:

uint32 sys_getMaxShares()
{
f010931c:	55                   	push   %ebp
f010931d:	89 e5                	mov    %esp,%ebp
	return MAX_SHARES;
f010931f:	b8 64 00 00 00       	mov    $0x64,%eax
}
f0109324:	5d                   	pop    %ebp
f0109325:	c3                   	ret    

f0109326 <sys_create_env>:

//=========

int sys_create_env(char* programName, unsigned int page_WS_size)
{
f0109326:	55                   	push   %ebp
f0109327:	89 e5                	mov    %esp,%ebp
f0109329:	83 ec 18             	sub    $0x18,%esp
	struct Env* env =  env_create(programName, page_WS_size);
f010932c:	83 ec 08             	sub    $0x8,%esp
f010932f:	ff 75 0c             	pushl  0xc(%ebp)
f0109332:	ff 75 08             	pushl  0x8(%ebp)
f0109335:	e8 ed b8 ff ff       	call   f0104c27 <env_create>
f010933a:	83 c4 10             	add    $0x10,%esp
f010933d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f0109340:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109344:	75 07                	jne    f010934d <sys_create_env+0x27>
	{
		return E_ENV_CREATION_ERROR;
f0109346:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010934b:	eb 14                	jmp    f0109361 <sys_create_env+0x3b>
	}

	//2015
	sched_new_env(env);
f010934d:	83 ec 0c             	sub    $0xc,%esp
f0109350:	ff 75 f4             	pushl  -0xc(%ebp)
f0109353:	e8 a4 f4 ff ff       	call   f01087fc <sched_new_env>
f0109358:	83 c4 10             	add    $0x10,%esp

	return env->env_id;
f010935b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010935e:	8b 40 4c             	mov    0x4c(%eax),%eax
}
f0109361:	c9                   	leave  
f0109362:	c3                   	ret    

f0109363 <sys_run_env>:

void sys_run_env(int32 envId)
{
f0109363:	55                   	push   %ebp
f0109364:	89 e5                	mov    %esp,%ebp
f0109366:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f0109369:	8b 45 08             	mov    0x8(%ebp),%eax
f010936c:	83 ec 0c             	sub    $0xc,%esp
f010936f:	50                   	push   %eax
f0109370:	e8 9e f4 ff ff       	call   f0108813 <sched_run_env>
f0109375:	83 c4 10             	add    $0x10,%esp
}
f0109378:	90                   	nop
f0109379:	c9                   	leave  
f010937a:	c3                   	ret    

f010937b <sys_free_env>:

void sys_free_env(int32 envId)
{
f010937b:	55                   	push   %ebp
f010937c:	89 e5                	mov    %esp,%ebp
f010937e:	83 ec 08             	sub    $0x8,%esp
	//2015
	sched_kill_env(envId);
f0109381:	8b 45 08             	mov    0x8(%ebp),%eax
f0109384:	83 ec 0c             	sub    $0xc,%esp
f0109387:	50                   	push   %eax
f0109388:	e8 20 f6 ff ff       	call   f01089ad <sched_kill_env>
f010938d:	83 c4 10             	add    $0x10,%esp
}
f0109390:	90                   	nop
f0109391:	c9                   	leave  
f0109392:	c3                   	ret    

f0109393 <sys_get_virtual_time>:

struct uint64 sys_get_virtual_time()
{
f0109393:	55                   	push   %ebp
f0109394:	89 e5                	mov    %esp,%ebp
f0109396:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f0109399:	0f 31                	rdtsc  
f010939b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010939e:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f01093a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01093a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
f01093aa:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f01093ad:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01093b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01093b3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01093b6:	89 01                	mov    %eax,(%ecx)
f01093b8:	89 51 04             	mov    %edx,0x4(%ecx)
}
f01093bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01093be:	c9                   	leave  
f01093bf:	c2 04 00             	ret    $0x4

f01093c2 <sys_moveMem>:

//2014
void sys_moveMem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f01093c2:	55                   	push   %ebp
f01093c3:	89 e5                	mov    %esp,%ebp
f01093c5:	83 ec 08             	sub    $0x8,%esp
	moveMem(curenv, src_virtual_address, dst_virtual_address, size);
f01093c8:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f01093cd:	ff 75 10             	pushl  0x10(%ebp)
f01093d0:	ff 75 0c             	pushl  0xc(%ebp)
f01093d3:	ff 75 08             	pushl  0x8(%ebp)
f01093d6:	50                   	push   %eax
f01093d7:	e8 73 a0 ff ff       	call   f010344f <moveMem>
f01093dc:	83 c4 10             	add    $0x10,%esp
	return;
f01093df:	90                   	nop
}
f01093e0:	c9                   	leave  
f01093e1:	c3                   	ret    

f01093e2 <sys_rcr2>:
uint32 sys_rcr2()
{
f01093e2:	55                   	push   %ebp
f01093e3:	89 e5                	mov    %esp,%ebp
f01093e5:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f01093e8:	0f 20 d0             	mov    %cr2,%eax
f01093eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f01093ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f01093f1:	90                   	nop
}
f01093f2:	c9                   	leave  
f01093f3:	c3                   	ret    

f01093f4 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f01093f4:	55                   	push   %ebp
f01093f5:	89 e5                	mov    %esp,%ebp
f01093f7:	83 ec 04             	sub    $0x4,%esp
f01093fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01093fd:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f0109400:	8a 45 fc             	mov    -0x4(%ebp),%al
f0109403:	a2 60 a1 42 f0       	mov    %al,0xf042a160
}
f0109408:	90                   	nop
f0109409:	c9                   	leave  
f010940a:	c3                   	ret    

f010940b <rsttst>:

int tstcnt;
void rsttst()
{
f010940b:	55                   	push   %ebp
f010940c:	89 e5                	mov    %esp,%ebp
	tstcnt = 0;
f010940e:	c7 05 e0 52 45 f0 00 	movl   $0x0,0xf04552e0
f0109415:	00 00 00 
}
f0109418:	90                   	nop
f0109419:	5d                   	pop    %ebp
f010941a:	c3                   	ret    

f010941b <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f010941b:	55                   	push   %ebp
f010941c:	89 e5                	mov    %esp,%ebp
f010941e:	83 ec 28             	sub    $0x28,%esp
f0109421:	8b 45 14             	mov    0x14(%ebp),%eax
f0109424:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f0109427:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f010942e:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f0109432:	83 f8 65             	cmp    $0x65,%eax
f0109435:	74 5d                	je     f0109494 <tst+0x79>
f0109437:	83 f8 65             	cmp    $0x65,%eax
f010943a:	7f 0a                	jg     f0109446 <tst+0x2b>
f010943c:	83 f8 62             	cmp    $0x62,%eax
f010943f:	74 73                	je     f01094b4 <tst+0x99>
f0109441:	e9 91 00 00 00       	jmp    f01094d7 <tst+0xbc>
f0109446:	83 f8 67             	cmp    $0x67,%eax
f0109449:	74 29                	je     f0109474 <tst+0x59>
f010944b:	83 f8 6c             	cmp    $0x6c,%eax
f010944e:	0f 85 83 00 00 00    	jne    f01094d7 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f0109454:	8b 45 08             	mov    0x8(%ebp),%eax
f0109457:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010945a:	73 09                	jae    f0109465 <tst+0x4a>
			chk = 1;
f010945c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0109463:	eb 68                	jmp    f01094cd <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f0109465:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0109469:	74 62                	je     f01094cd <tst+0xb2>
			chk = 1;
f010946b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0109472:	eb 59                	jmp    f01094cd <tst+0xb2>
	case 'g':
		if (n > v1)
f0109474:	8b 45 08             	mov    0x8(%ebp),%eax
f0109477:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010947a:	76 09                	jbe    f0109485 <tst+0x6a>
			chk = 1;
f010947c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0109483:	eb 4b                	jmp    f01094d0 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f0109485:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0109489:	74 45                	je     f01094d0 <tst+0xb5>
			chk = 1;
f010948b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0109492:	eb 3c                	jmp    f01094d0 <tst+0xb5>
	case 'e':
		if (n == v1)
f0109494:	8b 45 08             	mov    0x8(%ebp),%eax
f0109497:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010949a:	75 09                	jne    f01094a5 <tst+0x8a>
			chk = 1;
f010949c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f01094a3:	eb 2e                	jmp    f01094d3 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f01094a5:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f01094a9:	74 28                	je     f01094d3 <tst+0xb8>
			chk = 1;
f01094ab:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01094b2:	eb 1f                	jmp    f01094d3 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v1)
f01094b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01094b7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01094ba:	72 1a                	jb     f01094d6 <tst+0xbb>
f01094bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01094bf:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01094c2:	77 12                	ja     f01094d6 <tst+0xbb>
			chk = 1;
f01094c4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01094cb:	eb 09                	jmp    f01094d6 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01094cd:	90                   	nop
f01094ce:	eb 07                	jmp    f01094d7 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01094d0:	90                   	nop
f01094d1:	eb 04                	jmp    f01094d7 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01094d3:	90                   	nop
f01094d4:	eb 01                	jmp    f01094d7 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v1)
			chk = 1;
		break;
f01094d6:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f01094d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01094db:	75 17                	jne    f01094f4 <tst+0xd9>
f01094dd:	83 ec 04             	sub    $0x4,%esp
f01094e0:	68 85 1d 11 f0       	push   $0xf0111d85
f01094e5:	68 b1 01 00 00       	push   $0x1b1
f01094ea:	68 21 1d 11 f0       	push   $0xf0111d21
f01094ef:	e8 68 6c ff ff       	call   f010015c <_panic>
	tstcnt++ ;
f01094f4:	a1 e0 52 45 f0       	mov    0xf04552e0,%eax
f01094f9:	40                   	inc    %eax
f01094fa:	a3 e0 52 45 f0       	mov    %eax,0xf04552e0
	return;
f01094ff:	90                   	nop
}
f0109500:	c9                   	leave  
f0109501:	c3                   	ret    

f0109502 <chktst>:

void chktst(uint32 n)
{
f0109502:	55                   	push   %ebp
f0109503:	89 e5                	mov    %esp,%ebp
f0109505:	83 ec 08             	sub    $0x8,%esp
	if (tstcnt == n)
f0109508:	a1 e0 52 45 f0       	mov    0xf04552e0,%eax
f010950d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109510:	75 12                	jne    f0109524 <chktst+0x22>
		cprintf("\nCongratulations... test runs successfully\n");
f0109512:	83 ec 0c             	sub    $0xc,%esp
f0109515:	68 98 1d 11 f0       	push   $0xf0111d98
f010951a:	e8 3c cb ff ff       	call   f010605b <cprintf>
f010951f:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0109522:	eb 17                	jmp    f010953b <chktst+0x39>
void chktst(uint32 n)
{
	if (tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0109524:	83 ec 04             	sub    $0x4,%esp
f0109527:	68 c4 1d 11 f0       	push   $0xf0111dc4
f010952c:	68 bb 01 00 00       	push   $0x1bb
f0109531:	68 21 1d 11 f0       	push   $0xf0111d21
f0109536:	e8 21 6c ff ff       	call   f010015c <_panic>
}
f010953b:	c9                   	leave  
f010953c:	c3                   	ret    

f010953d <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010953d:	55                   	push   %ebp
f010953e:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f0109540:	a1 2c 2a 45 f0       	mov    0xf0452a2c,%eax
}
f0109545:	5d                   	pop    %ebp
f0109546:	c3                   	ret    

f0109547 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f0109547:	55                   	push   %ebp
f0109548:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010954a:	8b 45 08             	mov    0x8(%ebp),%eax
f010954d:	a3 2c 2a 45 f0       	mov    %eax,0xf0452a2c
}
f0109552:	90                   	nop
f0109553:	5d                   	pop    %ebp
f0109554:	c3                   	ret    

f0109555 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f0109555:	55                   	push   %ebp
f0109556:	89 e5                	mov    %esp,%ebp
f0109558:	56                   	push   %esi
f0109559:	53                   	push   %ebx
f010955a:	83 ec 10             	sub    $0x10,%esp
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.
	switch(syscallno)
f010955d:	83 7d 08 28          	cmpl   $0x28,0x8(%ebp)
f0109561:	0f 87 74 03 00 00    	ja     f01098db <syscall+0x386>
f0109567:	8b 45 08             	mov    0x8(%ebp),%eax
f010956a:	c1 e0 02             	shl    $0x2,%eax
f010956d:	05 e0 1d 11 f0       	add    $0xf0111de0,%eax
f0109572:	8b 00                	mov    (%eax),%eax
f0109574:	ff e0                	jmp    *%eax
	{
	case SYS_cputs:
		sys_cputs((const char*)a1,a2);
f0109576:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109579:	83 ec 08             	sub    $0x8,%esp
f010957c:	ff 75 10             	pushl  0x10(%ebp)
f010957f:	50                   	push   %eax
f0109580:	e8 8a f8 ff ff       	call   f0108e0f <sys_cputs>
f0109585:	83 c4 10             	add    $0x10,%esp
		return 0;
f0109588:	b8 00 00 00 00       	mov    $0x0,%eax
f010958d:	e9 4e 03 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f0109592:	e8 d0 f8 ff ff       	call   f0108e67 <sys_cgetc>
f0109597:	e9 44 03 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010959c:	e8 d9 f8 ff ff       	call   f0108e7a <sys_getenvid>
f01095a1:	e9 3a 03 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_env_destroy:
		return sys_env_destroy(a1);
f01095a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095a9:	83 ec 0c             	sub    $0xc,%esp
f01095ac:	50                   	push   %eax
f01095ad:	e8 15 f9 ff ff       	call   f0108ec7 <sys_env_destroy>
f01095b2:	83 c4 10             	add    $0x10,%esp
f01095b5:	e9 26 03 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_env_exit:
		sys_env_exit();
f01095ba:	e8 90 f9 ff ff       	call   f0108f4f <sys_env_exit>
		return 0;
f01095bf:	b8 00 00 00 00       	mov    $0x0,%eax
f01095c4:	e9 17 03 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f01095c9:	83 ec 08             	sub    $0x8,%esp
f01095cc:	ff 75 10             	pushl  0x10(%ebp)
f01095cf:	ff 75 0c             	pushl  0xc(%ebp)
f01095d2:	e8 d8 fa ff ff       	call   f01090af <sys_calculate_required_frames>
f01095d7:	83 c4 10             	add    $0x10,%esp
f01095da:	e9 01 03 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f01095df:	e8 ed fa ff ff       	call   f01090d1 <sys_calculate_free_frames>
f01095e4:	e9 f7 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f01095e9:	e8 02 fb ff ff       	call   f01090f0 <sys_calculate_modified_frames>
f01095ee:	e9 ed 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f01095f3:	e8 12 fb ff ff       	call   f010910a <sys_calculate_notmod_frames>
f01095f8:	e9 e3 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f01095fd:	e8 22 fb ff ff       	call   f0109124 <sys_pf_calculate_allocated_pages>
f0109602:	e9 d9 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_freeMem:
		sys_freeMem(a1, a2);
f0109607:	83 ec 08             	sub    $0x8,%esp
f010960a:	ff 75 10             	pushl  0x10(%ebp)
f010960d:	ff 75 0c             	pushl  0xc(%ebp)
f0109610:	e8 28 fb ff ff       	call   f010913d <sys_freeMem>
f0109615:	83 c4 10             	add    $0x10,%esp
		return 0;
f0109618:	b8 00 00 00 00       	mov    $0x0,%eax
f010961d:	e9 be 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f0109622:	8b 55 10             	mov    0x10(%ebp),%edx
f0109625:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109628:	83 ec 08             	sub    $0x8,%esp
f010962b:	52                   	push   %edx
f010962c:	50                   	push   %eax
f010962d:	e8 2b f9 ff ff       	call   f0108f5d <__sys_allocate_page>
f0109632:	83 c4 10             	add    $0x10,%esp
		return 0;
f0109635:	b8 00 00 00 00       	mov    $0x0,%eax
f010963a:	e9 a1 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010963f:	8b 75 1c             	mov    0x1c(%ebp),%esi
f0109642:	8b 5d 18             	mov    0x18(%ebp),%ebx
f0109645:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109648:	8b 55 10             	mov    0x10(%ebp),%edx
f010964b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010964e:	83 ec 0c             	sub    $0xc,%esp
f0109651:	56                   	push   %esi
f0109652:	53                   	push   %ebx
f0109653:	51                   	push   %ecx
f0109654:	52                   	push   %edx
f0109655:	50                   	push   %eax
f0109656:	e8 1a fa ff ff       	call   f0109075 <__sys_map_frame>
f010965b:	83 c4 20             	add    $0x20,%esp
		return 0;
f010965e:	b8 00 00 00 00       	mov    $0x0,%eax
f0109663:	e9 78 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f0109668:	8b 55 10             	mov    0x10(%ebp),%edx
f010966b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010966e:	83 ec 08             	sub    $0x8,%esp
f0109671:	52                   	push   %edx
f0109672:	50                   	push   %eax
f0109673:	e8 1a fa ff ff       	call   f0109092 <__sys_unmap_frame>
f0109678:	83 c4 10             	add    $0x10,%esp
		return 0;
f010967b:	b8 00 00 00 00       	mov    $0x0,%eax
f0109680:	e9 5b 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_allocateMem:
		//LOG_STATMENT(cprintf("KERNEL syscall: a2 %x\n", a2));
		sys_allocateMem(a1, (uint32)a2);
f0109685:	83 ec 08             	sub    $0x8,%esp
f0109688:	ff 75 10             	pushl  0x10(%ebp)
f010968b:	ff 75 0c             	pushl  0xc(%ebp)
f010968e:	e8 ec fa ff ff       	call   f010917f <sys_allocateMem>
f0109693:	83 c4 10             	add    $0x10,%esp
		return 0;
f0109696:	b8 00 00 00 00       	mov    $0x0,%eax
f010969b:	e9 40 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_disableINTR:
		sys_disable_interrupt();
f01096a0:	e8 fa fa ff ff       	call   f010919f <sys_disable_interrupt>
		return 0;
f01096a5:	b8 00 00 00 00       	mov    $0x0,%eax
f01096aa:	e9 31 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_enableINTR:
		sys_enable_interrupt();
f01096af:	e8 05 fb ff ff       	call   f01091b9 <sys_enable_interrupt>
		return 0;
f01096b4:	b8 00 00 00 00       	mov    $0x0,%eax
f01096b9:	e9 22 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f01096be:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096c1:	0f be c0             	movsbl %al,%eax
f01096c4:	83 ec 0c             	sub    $0xc,%esp
f01096c7:	50                   	push   %eax
f01096c8:	e8 76 f7 ff ff       	call   f0108e43 <sys_cputc>
f01096cd:	83 c4 10             	add    $0x10,%esp
		return 0;
f01096d0:	b8 00 00 00 00       	mov    $0x0,%eax
f01096d5:	e9 06 02 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f01096da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096dd:	0f be c0             	movsbl %al,%eax
f01096e0:	83 ec 0c             	sub    $0xc,%esp
f01096e3:	50                   	push   %eax
f01096e4:	e8 ea fa ff ff       	call   f01091d3 <sys_clearFFL>
f01096e9:	83 c4 10             	add    $0x10,%esp
		return 0;
f01096ec:	b8 00 00 00 00       	mov    $0x0,%eax
f01096f1:	e9 ea 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_create_semaphore:
		return sys_createSemaphore((char*)a1, a2);
f01096f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096f9:	83 ec 08             	sub    $0x8,%esp
f01096fc:	ff 75 10             	pushl  0x10(%ebp)
f01096ff:	50                   	push   %eax
f0109700:	e8 02 fb ff ff       	call   f0109207 <sys_createSemaphore>
f0109705:	83 c4 10             	add    $0x10,%esp
f0109708:	e9 d3 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_wait_semaphore:
		sys_waitSemaphore((char*)a1);
f010970d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109710:	83 ec 0c             	sub    $0xc,%esp
f0109713:	50                   	push   %eax
f0109714:	e8 07 fb ff ff       	call   f0109220 <sys_waitSemaphore>
f0109719:	83 c4 10             	add    $0x10,%esp
		return 0;
f010971c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109721:	e9 ba 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_signal_semaphore:
		sys_signalSemaphore((char*)a1);
f0109726:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109729:	83 ec 0c             	sub    $0xc,%esp
f010972c:	50                   	push   %eax
f010972d:	e8 05 fb ff ff       	call   f0109237 <sys_signalSemaphore>
f0109732:	83 c4 10             	add    $0x10,%esp
		return 0;
f0109735:	b8 00 00 00 00       	mov    $0x0,%eax
f010973a:	e9 a1 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_get_semaphore_value:
		return sys_getSemaphoreValue((char*)a1);
f010973f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109742:	83 ec 0c             	sub    $0xc,%esp
f0109745:	50                   	push   %eax
f0109746:	e8 03 fb ff ff       	call   f010924e <sys_getSemaphoreValue>
f010974b:	83 c4 10             	add    $0x10,%esp
f010974e:	e9 8d 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void**)a4);
f0109753:	8b 4d 18             	mov    0x18(%ebp),%ecx
f0109756:	8b 45 14             	mov    0x14(%ebp),%eax
f0109759:	0f b6 d0             	movzbl %al,%edx
f010975c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010975f:	51                   	push   %ecx
f0109760:	52                   	push   %edx
f0109761:	ff 75 10             	pushl  0x10(%ebp)
f0109764:	50                   	push   %eax
f0109765:	e8 4f fb ff ff       	call   f01092b9 <sys_createSharedObject>
f010976a:	83 c4 10             	add    $0x10,%esp
f010976d:	e9 6e 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((char*)a1, (void**)a2);
f0109772:	8b 55 10             	mov    0x10(%ebp),%edx
f0109775:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109778:	83 ec 08             	sub    $0x8,%esp
f010977b:	52                   	push   %edx
f010977c:	50                   	push   %eax
f010977d:	e8 5b fb ff ff       	call   f01092dd <sys_getSharedObject>
f0109782:	83 c4 10             	add    $0x10,%esp
f0109785:	e9 56 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((char*)a1);
f010978a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010978d:	83 ec 0c             	sub    $0xc,%esp
f0109790:	50                   	push   %eax
f0109791:	e8 60 fb ff ff       	call   f01092f6 <sys_freeSharedObject>
f0109796:	83 c4 10             	add    $0x10,%esp
f0109799:	e9 42 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_get_current_shared_address:
		return sys_getCurrentSharedAddress();
f010979e:	e8 69 fb ff ff       	call   f010930c <sys_getCurrentSharedAddress>
f01097a3:	e9 38 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_get_max_shares:
		return sys_getMaxShares();
f01097a8:	e8 6f fb ff ff       	call   f010931c <sys_getMaxShares>
f01097ad:	e9 2e 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2);
f01097b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097b5:	83 ec 08             	sub    $0x8,%esp
f01097b8:	ff 75 10             	pushl  0x10(%ebp)
f01097bb:	50                   	push   %eax
f01097bc:	e8 65 fb ff ff       	call   f0109326 <sys_create_env>
f01097c1:	83 c4 10             	add    $0x10,%esp
f01097c4:	e9 17 01 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_free_env:
		sys_free_env((int32)a1);
f01097c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097cc:	83 ec 0c             	sub    $0xc,%esp
f01097cf:	50                   	push   %eax
f01097d0:	e8 a6 fb ff ff       	call   f010937b <sys_free_env>
f01097d5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01097d8:	b8 00 00 00 00       	mov    $0x0,%eax
f01097dd:	e9 fe 00 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f01097e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097e5:	83 ec 0c             	sub    $0xc,%esp
f01097e8:	50                   	push   %eax
f01097e9:	e8 75 fb ff ff       	call   f0109363 <sys_run_env>
f01097ee:	83 c4 10             	add    $0x10,%esp
		return 0;
f01097f1:	b8 00 00 00 00       	mov    $0x0,%eax
f01097f6:	e9 e5 00 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;

	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f01097fb:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01097fe:	83 ec 0c             	sub    $0xc,%esp
f0109801:	50                   	push   %eax
f0109802:	e8 8c fb ff ff       	call   f0109393 <sys_get_virtual_time>
f0109807:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010980a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010980d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f0109810:	8b 45 10             	mov    0x10(%ebp),%eax
f0109813:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f0109816:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0109819:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010981c:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010981e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109821:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109824:	89 10                	mov    %edx,(%eax)
		return 0;
f0109826:	b8 00 00 00 00       	mov    $0x0,%eax
f010982b:	e9 b0 00 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	}
	case SYS_moveMem:
		sys_moveMem(a1, a2, a3);
f0109830:	83 ec 04             	sub    $0x4,%esp
f0109833:	ff 75 14             	pushl  0x14(%ebp)
f0109836:	ff 75 10             	pushl  0x10(%ebp)
f0109839:	ff 75 0c             	pushl  0xc(%ebp)
f010983c:	e8 81 fb ff ff       	call   f01093c2 <sys_moveMem>
f0109841:	83 c4 10             	add    $0x10,%esp
		return 0;
f0109844:	b8 00 00 00 00       	mov    $0x0,%eax
f0109849:	e9 92 00 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010984e:	e8 8f fb ff ff       	call   f01093e2 <sys_rcr2>
f0109853:	e9 88 00 00 00       	jmp    f01098e0 <syscall+0x38b>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f0109858:	8b 45 0c             	mov    0xc(%ebp),%eax
f010985b:	0f b6 c0             	movzbl %al,%eax
f010985e:	83 ec 0c             	sub    $0xc,%esp
f0109861:	50                   	push   %eax
f0109862:	e8 8d fb ff ff       	call   f01093f4 <sys_bypassPageFault>
f0109867:	83 c4 10             	add    $0x10,%esp
		return 0;
f010986a:	b8 00 00 00 00       	mov    $0x0,%eax
f010986f:	eb 6f                	jmp    f01098e0 <syscall+0x38b>

	case SYS_rsttst:
		rsttst();
f0109871:	e8 95 fb ff ff       	call   f010940b <rsttst>
		return 0;
f0109876:	b8 00 00 00 00       	mov    $0x0,%eax
f010987b:	eb 63                	jmp    f01098e0 <syscall+0x38b>
	case SYS_chktst:
		chktst(a1);
f010987d:	83 ec 0c             	sub    $0xc,%esp
f0109880:	ff 75 0c             	pushl  0xc(%ebp)
f0109883:	e8 7a fc ff ff       	call   f0109502 <chktst>
f0109888:	83 c4 10             	add    $0x10,%esp
		return 0;
f010988b:	b8 00 00 00 00       	mov    $0x0,%eax
f0109890:	eb 4e                	jmp    f01098e0 <syscall+0x38b>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f0109892:	8b 55 1c             	mov    0x1c(%ebp),%edx
f0109895:	8b 45 18             	mov    0x18(%ebp),%eax
f0109898:	0f be c0             	movsbl %al,%eax
f010989b:	83 ec 0c             	sub    $0xc,%esp
f010989e:	52                   	push   %edx
f010989f:	50                   	push   %eax
f01098a0:	ff 75 14             	pushl  0x14(%ebp)
f01098a3:	ff 75 10             	pushl  0x10(%ebp)
f01098a6:	ff 75 0c             	pushl  0xc(%ebp)
f01098a9:	e8 6d fb ff ff       	call   f010941b <tst>
f01098ae:	83 c4 20             	add    $0x20,%esp
		return 0;
f01098b1:	b8 00 00 00 00       	mov    $0x0,%eax
f01098b6:	eb 28                	jmp    f01098e0 <syscall+0x38b>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f01098b8:	e8 80 fc ff ff       	call   f010953d <sys_get_heap_strategy>
f01098bd:	eb 21                	jmp    f01098e0 <syscall+0x38b>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f01098bf:	83 ec 0c             	sub    $0xc,%esp
f01098c2:	ff 75 0c             	pushl  0xc(%ebp)
f01098c5:	e8 7d fc ff ff       	call   f0109547 <sys_set_uheap_strategy>
f01098ca:	83 c4 10             	add    $0x10,%esp
		return 0;
f01098cd:	b8 00 00 00 00       	mov    $0x0,%eax
f01098d2:	eb 0c                	jmp    f01098e0 <syscall+0x38b>

	case NSYSCALLS:
		return 	-E_INVAL;
f01098d4:	b8 03 00 00 00       	mov    $0x3,%eax
f01098d9:	eb 05                	jmp    f01098e0 <syscall+0x38b>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f01098db:	b8 03 00 00 00       	mov    $0x3,%eax
}
f01098e0:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01098e3:	5b                   	pop    %ebx
f01098e4:	5e                   	pop    %esi
f01098e5:	5d                   	pop    %ebp
f01098e6:	c3                   	ret    

f01098e7 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f01098e7:	55                   	push   %ebp
f01098e8:	89 e5                	mov    %esp,%ebp
f01098ea:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f01098ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f01098f0:	8b 00                	mov    (%eax),%eax
f01098f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01098f5:	8b 45 10             	mov    0x10(%ebp),%eax
f01098f8:	8b 00                	mov    (%eax),%eax
f01098fa:	89 45 f8             	mov    %eax,-0x8(%ebp)
f01098fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	
	while (l <= r) {
f0109904:	e9 ca 00 00 00       	jmp    f01099d3 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f0109909:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010990c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010990f:	01 d0                	add    %edx,%eax
f0109911:	89 c2                	mov    %eax,%edx
f0109913:	c1 ea 1f             	shr    $0x1f,%edx
f0109916:	01 d0                	add    %edx,%eax
f0109918:	d1 f8                	sar    %eax
f010991a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010991d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		
		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f0109923:	eb 03                	jmp    f0109928 <stab_binsearch+0x41>
			m--;
f0109925:	ff 4d f0             	decl   -0x10(%ebp)
	
	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;
		
		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f0109928:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010992b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010992e:	7c 1e                	jl     f010994e <stab_binsearch+0x67>
f0109930:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109933:	89 d0                	mov    %edx,%eax
f0109935:	01 c0                	add    %eax,%eax
f0109937:	01 d0                	add    %edx,%eax
f0109939:	c1 e0 02             	shl    $0x2,%eax
f010993c:	89 c2                	mov    %eax,%edx
f010993e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109941:	01 d0                	add    %edx,%eax
f0109943:	8a 40 04             	mov    0x4(%eax),%al
f0109946:	0f b6 c0             	movzbl %al,%eax
f0109949:	3b 45 14             	cmp    0x14(%ebp),%eax
f010994c:	75 d7                	jne    f0109925 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010994e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109951:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0109954:	7d 09                	jge    f010995f <stab_binsearch+0x78>
			l = true_m + 1;
f0109956:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109959:	40                   	inc    %eax
f010995a:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010995d:	eb 74                	jmp    f01099d3 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010995f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f0109966:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109969:	89 d0                	mov    %edx,%eax
f010996b:	01 c0                	add    %eax,%eax
f010996d:	01 d0                	add    %edx,%eax
f010996f:	c1 e0 02             	shl    $0x2,%eax
f0109972:	89 c2                	mov    %eax,%edx
f0109974:	8b 45 08             	mov    0x8(%ebp),%eax
f0109977:	01 d0                	add    %edx,%eax
f0109979:	8b 40 08             	mov    0x8(%eax),%eax
f010997c:	3b 45 18             	cmp    0x18(%ebp),%eax
f010997f:	73 11                	jae    f0109992 <stab_binsearch+0xab>
			*region_left = m;
f0109981:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109984:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109987:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f0109989:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010998c:	40                   	inc    %eax
f010998d:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0109990:	eb 41                	jmp    f01099d3 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f0109992:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109995:	89 d0                	mov    %edx,%eax
f0109997:	01 c0                	add    %eax,%eax
f0109999:	01 d0                	add    %edx,%eax
f010999b:	c1 e0 02             	shl    $0x2,%eax
f010999e:	89 c2                	mov    %eax,%edx
f01099a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01099a3:	01 d0                	add    %edx,%eax
f01099a5:	8b 40 08             	mov    0x8(%eax),%eax
f01099a8:	3b 45 18             	cmp    0x18(%ebp),%eax
f01099ab:	76 14                	jbe    f01099c1 <stab_binsearch+0xda>
			*region_right = m - 1;
f01099ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099b0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01099b3:	8b 45 10             	mov    0x10(%ebp),%eax
f01099b6:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f01099b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099bb:	48                   	dec    %eax
f01099bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
f01099bf:	eb 12                	jmp    f01099d3 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f01099c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01099c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01099c7:	89 10                	mov    %edx,(%eax)
			l = m;
f01099c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f01099cf:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;
	
	while (l <= r) {
f01099d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01099d6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01099d9:	0f 8e 2a ff ff ff    	jle    f0109909 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f01099df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01099e3:	75 0f                	jne    f01099f4 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f01099e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01099e8:	8b 00                	mov    (%eax),%eax
f01099ea:	8d 50 ff             	lea    -0x1(%eax),%edx
f01099ed:	8b 45 10             	mov    0x10(%ebp),%eax
f01099f0:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f01099f2:	eb 3d                	jmp    f0109a31 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f01099f4:	8b 45 10             	mov    0x10(%ebp),%eax
f01099f7:	8b 00                	mov    (%eax),%eax
f01099f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01099fc:	eb 03                	jmp    f0109a01 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f01099fe:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f0109a01:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a04:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f0109a06:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0109a09:	7d 1e                	jge    f0109a29 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f0109a0b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0109a0e:	89 d0                	mov    %edx,%eax
f0109a10:	01 c0                	add    %eax,%eax
f0109a12:	01 d0                	add    %edx,%eax
f0109a14:	c1 e0 02             	shl    $0x2,%eax
f0109a17:	89 c2                	mov    %eax,%edx
f0109a19:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a1c:	01 d0                	add    %edx,%eax
f0109a1e:	8a 40 04             	mov    0x4(%eax),%al
f0109a21:	0f b6 c0             	movzbl %al,%eax
f0109a24:	3b 45 14             	cmp    0x14(%ebp),%eax
f0109a27:	75 d5                	jne    f01099fe <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f0109a29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a2c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0109a2f:	89 10                	mov    %edx,(%eax)
	}
}
f0109a31:	90                   	nop
f0109a32:	c9                   	leave  
f0109a33:	c3                   	ret    

f0109a34 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f0109a34:	55                   	push   %ebp
f0109a35:	89 e5                	mov    %esp,%ebp
f0109a37:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f0109a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a3d:	c7 00 84 1e 11 f0    	movl   $0xf0111e84,(%eax)
	info->eip_line = 0;
f0109a43:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a46:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f0109a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a50:	c7 40 08 84 1e 11 f0 	movl   $0xf0111e84,0x8(%eax)
	info->eip_fn_namelen = 9;
f0109a57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a5a:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f0109a61:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a64:	8b 55 08             	mov    0x8(%ebp),%edx
f0109a67:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f0109a6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a6d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f0109a74:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a77:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f0109a7c:	76 1e                	jbe    f0109a9c <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f0109a7e:	c7 45 f4 50 2b 11 f0 	movl   $0xf0112b50,-0xc(%ebp)
		stab_end = __STAB_END__;
f0109a85:	c7 45 f0 48 a1 12 f0 	movl   $0xf012a148,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f0109a8c:	c7 45 ec 49 a1 12 f0 	movl   $0xf012a149,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f0109a93:	c7 45 e8 a1 18 13 f0 	movl   $0xf01318a1,-0x18(%ebp)
f0109a9a:	eb 2a                	jmp    f0109ac6 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f0109a9c:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.
		
		stabs = usd->stabs;
f0109aa3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109aa6:	8b 00                	mov    (%eax),%eax
f0109aa8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f0109aab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109aae:	8b 40 04             	mov    0x4(%eax),%eax
f0109ab1:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f0109ab4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109ab7:	8b 40 08             	mov    0x8(%eax),%eax
f0109aba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f0109abd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109ac0:	8b 40 0c             	mov    0xc(%eax),%eax
f0109ac3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f0109ac6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109ac9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109acc:	76 0a                	jbe    f0109ad8 <debuginfo_eip+0xa4>
f0109ace:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109ad1:	48                   	dec    %eax
f0109ad2:	8a 00                	mov    (%eax),%al
f0109ad4:	84 c0                	test   %al,%al
f0109ad6:	74 0a                	je     f0109ae2 <debuginfo_eip+0xae>
		return -1;
f0109ad8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109add:	e9 01 02 00 00       	jmp    f0109ce3 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.
	
	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f0109ae2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f0109ae9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109aef:	29 c2                	sub    %eax,%edx
f0109af1:	89 d0                	mov    %edx,%eax
f0109af3:	c1 f8 02             	sar    $0x2,%eax
f0109af6:	89 c2                	mov    %eax,%edx
f0109af8:	89 d0                	mov    %edx,%eax
f0109afa:	c1 e0 02             	shl    $0x2,%eax
f0109afd:	01 d0                	add    %edx,%eax
f0109aff:	c1 e0 02             	shl    $0x2,%eax
f0109b02:	01 d0                	add    %edx,%eax
f0109b04:	c1 e0 02             	shl    $0x2,%eax
f0109b07:	01 d0                	add    %edx,%eax
f0109b09:	89 c1                	mov    %eax,%ecx
f0109b0b:	c1 e1 08             	shl    $0x8,%ecx
f0109b0e:	01 c8                	add    %ecx,%eax
f0109b10:	89 c1                	mov    %eax,%ecx
f0109b12:	c1 e1 10             	shl    $0x10,%ecx
f0109b15:	01 c8                	add    %ecx,%eax
f0109b17:	01 c0                	add    %eax,%eax
f0109b19:	01 d0                	add    %edx,%eax
f0109b1b:	48                   	dec    %eax
f0109b1c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f0109b1f:	ff 75 08             	pushl  0x8(%ebp)
f0109b22:	6a 64                	push   $0x64
f0109b24:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0109b27:	50                   	push   %eax
f0109b28:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0109b2b:	50                   	push   %eax
f0109b2c:	ff 75 f4             	pushl  -0xc(%ebp)
f0109b2f:	e8 b3 fd ff ff       	call   f01098e7 <stab_binsearch>
f0109b34:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f0109b37:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109b3a:	85 c0                	test   %eax,%eax
f0109b3c:	75 0a                	jne    f0109b48 <debuginfo_eip+0x114>
		return -1;
f0109b3e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109b43:	e9 9b 01 00 00       	jmp    f0109ce3 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f0109b48:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109b4b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f0109b4e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109b51:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f0109b54:	ff 75 08             	pushl  0x8(%ebp)
f0109b57:	6a 24                	push   $0x24
f0109b59:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0109b5c:	50                   	push   %eax
f0109b5d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0109b60:	50                   	push   %eax
f0109b61:	ff 75 f4             	pushl  -0xc(%ebp)
f0109b64:	e8 7e fd ff ff       	call   f01098e7 <stab_binsearch>
f0109b69:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f0109b6c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0109b6f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b72:	39 c2                	cmp    %eax,%edx
f0109b74:	0f 8f 86 00 00 00    	jg     f0109c00 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f0109b7a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109b7d:	89 c2                	mov    %eax,%edx
f0109b7f:	89 d0                	mov    %edx,%eax
f0109b81:	01 c0                	add    %eax,%eax
f0109b83:	01 d0                	add    %edx,%eax
f0109b85:	c1 e0 02             	shl    $0x2,%eax
f0109b88:	89 c2                	mov    %eax,%edx
f0109b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b8d:	01 d0                	add    %edx,%eax
f0109b8f:	8b 00                	mov    (%eax),%eax
f0109b91:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0109b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109b97:	29 d1                	sub    %edx,%ecx
f0109b99:	89 ca                	mov    %ecx,%edx
f0109b9b:	39 d0                	cmp    %edx,%eax
f0109b9d:	73 22                	jae    f0109bc1 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f0109b9f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109ba2:	89 c2                	mov    %eax,%edx
f0109ba4:	89 d0                	mov    %edx,%eax
f0109ba6:	01 c0                	add    %eax,%eax
f0109ba8:	01 d0                	add    %edx,%eax
f0109baa:	c1 e0 02             	shl    $0x2,%eax
f0109bad:	89 c2                	mov    %eax,%edx
f0109baf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109bb2:	01 d0                	add    %edx,%eax
f0109bb4:	8b 10                	mov    (%eax),%edx
f0109bb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109bb9:	01 c2                	add    %eax,%edx
f0109bbb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109bbe:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f0109bc1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109bc4:	89 c2                	mov    %eax,%edx
f0109bc6:	89 d0                	mov    %edx,%eax
f0109bc8:	01 c0                	add    %eax,%eax
f0109bca:	01 d0                	add    %edx,%eax
f0109bcc:	c1 e0 02             	shl    $0x2,%eax
f0109bcf:	89 c2                	mov    %eax,%edx
f0109bd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109bd4:	01 d0                	add    %edx,%eax
f0109bd6:	8b 50 08             	mov    0x8(%eax),%edx
f0109bd9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109bdc:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f0109bdf:	8b 55 08             	mov    0x8(%ebp),%edx
f0109be2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109be5:	8b 40 10             	mov    0x10(%eax),%eax
f0109be8:	29 c2                	sub    %eax,%edx
f0109bea:	89 d0                	mov    %edx,%eax
f0109bec:	c1 f8 02             	sar    $0x2,%eax
f0109bef:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f0109bf2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109bf5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f0109bf8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109bfb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0109bfe:	eb 15                	jmp    f0109c15 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f0109c00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109c03:	8b 55 08             	mov    0x8(%ebp),%edx
f0109c06:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f0109c09:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109c0c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f0109c0f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109c12:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f0109c15:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109c18:	8b 40 08             	mov    0x8(%eax),%eax
f0109c1b:	83 ec 08             	sub    $0x8,%esp
f0109c1e:	6a 3a                	push   $0x3a
f0109c20:	50                   	push   %eax
f0109c21:	e8 4c 50 00 00       	call   f010ec72 <strfind>
f0109c26:	83 c4 10             	add    $0x10,%esp
f0109c29:	89 c2                	mov    %eax,%edx
f0109c2b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109c2e:	8b 40 08             	mov    0x8(%eax),%eax
f0109c31:	29 c2                	sub    %eax,%edx
f0109c33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109c36:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f0109c39:	eb 03                	jmp    f0109c3e <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f0109c3b:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f0109c3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109c41:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0109c44:	7c 4e                	jl     f0109c94 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f0109c46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0109c49:	89 d0                	mov    %edx,%eax
f0109c4b:	01 c0                	add    %eax,%eax
f0109c4d:	01 d0                	add    %edx,%eax
f0109c4f:	c1 e0 02             	shl    $0x2,%eax
f0109c52:	89 c2                	mov    %eax,%edx
f0109c54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109c57:	01 d0                	add    %edx,%eax
f0109c59:	8a 40 04             	mov    0x4(%eax),%al
f0109c5c:	3c 84                	cmp    $0x84,%al
f0109c5e:	74 34                	je     f0109c94 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f0109c60:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0109c63:	89 d0                	mov    %edx,%eax
f0109c65:	01 c0                	add    %eax,%eax
f0109c67:	01 d0                	add    %edx,%eax
f0109c69:	c1 e0 02             	shl    $0x2,%eax
f0109c6c:	89 c2                	mov    %eax,%edx
f0109c6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109c71:	01 d0                	add    %edx,%eax
f0109c73:	8a 40 04             	mov    0x4(%eax),%al
f0109c76:	3c 64                	cmp    $0x64,%al
f0109c78:	75 c1                	jne    f0109c3b <debuginfo_eip+0x207>
f0109c7a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0109c7d:	89 d0                	mov    %edx,%eax
f0109c7f:	01 c0                	add    %eax,%eax
f0109c81:	01 d0                	add    %edx,%eax
f0109c83:	c1 e0 02             	shl    $0x2,%eax
f0109c86:	89 c2                	mov    %eax,%edx
f0109c88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109c8b:	01 d0                	add    %edx,%eax
f0109c8d:	8b 40 08             	mov    0x8(%eax),%eax
f0109c90:	85 c0                	test   %eax,%eax
f0109c92:	74 a7                	je     f0109c3b <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f0109c94:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109c97:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0109c9a:	7c 42                	jl     f0109cde <debuginfo_eip+0x2aa>
f0109c9c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0109c9f:	89 d0                	mov    %edx,%eax
f0109ca1:	01 c0                	add    %eax,%eax
f0109ca3:	01 d0                	add    %edx,%eax
f0109ca5:	c1 e0 02             	shl    $0x2,%eax
f0109ca8:	89 c2                	mov    %eax,%edx
f0109caa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109cad:	01 d0                	add    %edx,%eax
f0109caf:	8b 00                	mov    (%eax),%eax
f0109cb1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0109cb4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109cb7:	29 d1                	sub    %edx,%ecx
f0109cb9:	89 ca                	mov    %ecx,%edx
f0109cbb:	39 d0                	cmp    %edx,%eax
f0109cbd:	73 1f                	jae    f0109cde <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f0109cbf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0109cc2:	89 d0                	mov    %edx,%eax
f0109cc4:	01 c0                	add    %eax,%eax
f0109cc6:	01 d0                	add    %edx,%eax
f0109cc8:	c1 e0 02             	shl    $0x2,%eax
f0109ccb:	89 c2                	mov    %eax,%edx
f0109ccd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109cd0:	01 d0                	add    %edx,%eax
f0109cd2:	8b 10                	mov    (%eax),%edx
f0109cd4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109cd7:	01 c2                	add    %eax,%edx
f0109cd9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109cdc:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.

	
	return 0;
f0109cde:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109ce3:	c9                   	leave  
f0109ce4:	c3                   	ret    

f0109ce5 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0109ce5:	55                   	push   %ebp
f0109ce6:	89 e5                	mov    %esp,%ebp
f0109ce8:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0109ceb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cee:	05 00 14 00 00       	add    $0x1400,%eax
f0109cf3:	c1 e0 03             	shl    $0x3,%eax
f0109cf6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0109cf9:	83 ec 04             	sub    $0x4,%esp
f0109cfc:	6a 08                	push   $0x8
f0109cfe:	ff 75 0c             	pushl  0xc(%ebp)
f0109d01:	ff 75 f4             	pushl  -0xc(%ebp)
f0109d04:	e8 fa 54 00 00       	call   f010f203 <ide_read>
f0109d09:	83 c4 10             	add    $0x10,%esp
f0109d0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0109d0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0109d12:	c9                   	leave  
f0109d13:	c3                   	ret    

f0109d14 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0109d14:	55                   	push   %ebp
f0109d15:	89 e5                	mov    %esp,%ebp
f0109d17:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0109d1a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d1d:	05 00 14 00 00       	add    $0x1400,%eax
f0109d22:	c1 e0 03             	shl    $0x3,%eax
f0109d25:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0109d28:	83 ec 04             	sub    $0x4,%esp
f0109d2b:	6a 08                	push   $0x8
f0109d2d:	ff 75 0c             	pushl  0xc(%ebp)
f0109d30:	ff 75 f4             	pushl  -0xc(%ebp)
f0109d33:	e8 0b 56 00 00       	call   f010f343 <ide_write>
f0109d38:	83 c4 10             	add    $0x10,%esp
f0109d3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0109d3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109d42:	74 14                	je     f0109d58 <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0109d44:	83 ec 04             	sub    $0x4,%esp
f0109d47:	68 90 1e 11 f0       	push   $0xf0111e90
f0109d4c:	6a 37                	push   $0x37
f0109d4e:	68 a7 1e 11 f0       	push   $0xf0111ea7
f0109d53:	e8 04 64 ff ff       	call   f010015c <_panic>
	return success;
f0109d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0109d5b:	c9                   	leave  
f0109d5c:	c3                   	ret    

f0109d5d <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0109d5d:	55                   	push   %ebp
f0109d5e:	89 e5                	mov    %esp,%ebp
f0109d60:	53                   	push   %ebx
f0109d61:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&disk_free_frame_list);
f0109d64:	c7 05 94 67 4c f0 00 	movl   $0x0,0xf04c6794
f0109d6b:	00 00 00 
f0109d6e:	c7 05 98 67 4c f0 00 	movl   $0x0,0xf04c6798
f0109d75:	00 00 00 
f0109d78:	c7 05 a0 67 4c f0 00 	movl   $0x0,0xf04c67a0
f0109d7f:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0109d82:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0109d89:	e9 bc 00 00 00       	jmp    f0109e4a <initialize_disk_page_file+0xed>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0109d8e:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109d94:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109d97:	89 d0                	mov    %edx,%eax
f0109d99:	01 c0                	add    %eax,%eax
f0109d9b:	01 d0                	add    %edx,%eax
f0109d9d:	c1 e0 03             	shl    $0x3,%eax
f0109da0:	01 c8                	add    %ecx,%eax
f0109da2:	83 ec 0c             	sub    $0xc,%esp
f0109da5:	50                   	push   %eax
f0109da6:	e8 d2 8d ff ff       	call   f0102b7d <initialize_frame_info>
f0109dab:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&disk_free_frame_list, &disk_frames_info[i]);
f0109dae:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109db4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109db7:	89 d0                	mov    %edx,%eax
f0109db9:	01 c0                	add    %eax,%eax
f0109dbb:	01 d0                	add    %edx,%eax
f0109dbd:	c1 e0 03             	shl    $0x3,%eax
f0109dc0:	01 c8                	add    %ecx,%eax
f0109dc2:	8b 15 94 67 4c f0    	mov    0xf04c6794,%edx
f0109dc8:	89 10                	mov    %edx,(%eax)
f0109dca:	8b 00                	mov    (%eax),%eax
f0109dcc:	85 c0                	test   %eax,%eax
f0109dce:	74 1f                	je     f0109def <initialize_disk_page_file+0x92>
f0109dd0:	8b 15 94 67 4c f0    	mov    0xf04c6794,%edx
f0109dd6:	8b 1d 70 52 45 f0    	mov    0xf0455270,%ebx
f0109ddc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0109ddf:	89 c8                	mov    %ecx,%eax
f0109de1:	01 c0                	add    %eax,%eax
f0109de3:	01 c8                	add    %ecx,%eax
f0109de5:	c1 e0 03             	shl    $0x3,%eax
f0109de8:	01 d8                	add    %ebx,%eax
f0109dea:	89 42 04             	mov    %eax,0x4(%edx)
f0109ded:	eb 19                	jmp    f0109e08 <initialize_disk_page_file+0xab>
f0109def:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109df5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109df8:	89 d0                	mov    %edx,%eax
f0109dfa:	01 c0                	add    %eax,%eax
f0109dfc:	01 d0                	add    %edx,%eax
f0109dfe:	c1 e0 03             	shl    $0x3,%eax
f0109e01:	01 c8                	add    %ecx,%eax
f0109e03:	a3 98 67 4c f0       	mov    %eax,0xf04c6798
f0109e08:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109e0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109e11:	89 d0                	mov    %edx,%eax
f0109e13:	01 c0                	add    %eax,%eax
f0109e15:	01 d0                	add    %edx,%eax
f0109e17:	c1 e0 03             	shl    $0x3,%eax
f0109e1a:	01 c8                	add    %ecx,%eax
f0109e1c:	a3 94 67 4c f0       	mov    %eax,0xf04c6794
f0109e21:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109e27:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109e2a:	89 d0                	mov    %edx,%eax
f0109e2c:	01 c0                	add    %eax,%eax
f0109e2e:	01 d0                	add    %edx,%eax
f0109e30:	c1 e0 03             	shl    $0x3,%eax
f0109e33:	01 c8                	add    %ecx,%eax
f0109e35:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109e3c:	a1 a0 67 4c f0       	mov    0xf04c67a0,%eax
f0109e41:	40                   	inc    %eax
f0109e42:	a3 a0 67 4c f0       	mov    %eax,0xf04c67a0
{
	int i;
	LIST_INIT(&disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0109e47:	ff 45 f4             	incl   -0xc(%ebp)
f0109e4a:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0109e51:	0f 8e 37 ff ff ff    	jle    f0109d8e <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0109e57:	90                   	nop
f0109e58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109e5b:	c9                   	leave  
f0109e5c:	c3                   	ret    

f0109e5d <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct Frame_Info *ptr_frame_info)
{
f0109e5d:	55                   	push   %ebp
f0109e5e:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0109e60:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e63:	8b 15 70 52 45 f0    	mov    0xf0455270,%edx
f0109e69:	29 d0                	sub    %edx,%eax
f0109e6b:	c1 f8 03             	sar    $0x3,%eax
f0109e6e:	89 c2                	mov    %eax,%edx
f0109e70:	89 d0                	mov    %edx,%eax
f0109e72:	c1 e0 02             	shl    $0x2,%eax
f0109e75:	01 d0                	add    %edx,%eax
f0109e77:	c1 e0 02             	shl    $0x2,%eax
f0109e7a:	01 d0                	add    %edx,%eax
f0109e7c:	c1 e0 02             	shl    $0x2,%eax
f0109e7f:	01 d0                	add    %edx,%eax
f0109e81:	89 c1                	mov    %eax,%ecx
f0109e83:	c1 e1 08             	shl    $0x8,%ecx
f0109e86:	01 c8                	add    %ecx,%eax
f0109e88:	89 c1                	mov    %eax,%ecx
f0109e8a:	c1 e1 10             	shl    $0x10,%ecx
f0109e8d:	01 c8                	add    %ecx,%eax
f0109e8f:	01 c0                	add    %eax,%eax
f0109e91:	01 d0                	add    %edx,%eax
}
f0109e93:	5d                   	pop    %ebp
f0109e94:	c3                   	ret    

f0109e95 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0109e95:	55                   	push   %ebp
f0109e96:	89 e5                	mov    %esp,%ebp
f0109e98:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	struct Frame_Info *ptr_frame_info = LIST_FIRST(&disk_free_frame_list);
f0109e9b:	a1 94 67 4c f0       	mov    0xf04c6794,%eax
f0109ea0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL)
f0109ea3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109ea7:	75 0a                	jne    f0109eb3 <allocate_disk_frame+0x1e>
		return E_NO_PAGE_FILE_SPACE;
f0109ea9:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0109eae:	e9 8d 00 00 00       	jmp    f0109f40 <allocate_disk_frame+0xab>

	LIST_REMOVE(&disk_free_frame_list, ptr_frame_info);
f0109eb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109eb6:	8b 00                	mov    (%eax),%eax
f0109eb8:	85 c0                	test   %eax,%eax
f0109eba:	74 10                	je     f0109ecc <allocate_disk_frame+0x37>
f0109ebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ebf:	8b 00                	mov    (%eax),%eax
f0109ec1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109ec4:	8b 52 04             	mov    0x4(%edx),%edx
f0109ec7:	89 50 04             	mov    %edx,0x4(%eax)
f0109eca:	eb 0b                	jmp    f0109ed7 <allocate_disk_frame+0x42>
f0109ecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ecf:	8b 40 04             	mov    0x4(%eax),%eax
f0109ed2:	a3 98 67 4c f0       	mov    %eax,0xf04c6798
f0109ed7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109eda:	8b 40 04             	mov    0x4(%eax),%eax
f0109edd:	85 c0                	test   %eax,%eax
f0109edf:	74 0f                	je     f0109ef0 <allocate_disk_frame+0x5b>
f0109ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ee4:	8b 40 04             	mov    0x4(%eax),%eax
f0109ee7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109eea:	8b 12                	mov    (%edx),%edx
f0109eec:	89 10                	mov    %edx,(%eax)
f0109eee:	eb 0a                	jmp    f0109efa <allocate_disk_frame+0x65>
f0109ef0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ef3:	8b 00                	mov    (%eax),%eax
f0109ef5:	a3 94 67 4c f0       	mov    %eax,0xf04c6794
f0109efa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109efd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f06:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109f0d:	a1 a0 67 4c f0       	mov    0xf04c67a0,%eax
f0109f12:	48                   	dec    %eax
f0109f13:	a3 a0 67 4c f0       	mov    %eax,0xf04c67a0
	initialize_frame_info(ptr_frame_info);
f0109f18:	83 ec 0c             	sub    $0xc,%esp
f0109f1b:	ff 75 f4             	pushl  -0xc(%ebp)
f0109f1e:	e8 5a 8c ff ff       	call   f0102b7d <initialize_frame_info>
f0109f23:	83 c4 10             	add    $0x10,%esp
	*dfn = to_disk_frame_number(ptr_frame_info);
f0109f26:	83 ec 0c             	sub    $0xc,%esp
f0109f29:	ff 75 f4             	pushl  -0xc(%ebp)
f0109f2c:	e8 2c ff ff ff       	call   f0109e5d <to_disk_frame_number>
f0109f31:	83 c4 10             	add    $0x10,%esp
f0109f34:	89 c2                	mov    %eax,%edx
f0109f36:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f39:	89 10                	mov    %edx,(%eax)
	return 0;
f0109f3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109f40:	c9                   	leave  
f0109f41:	c3                   	ret    

f0109f42 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0109f42:	55                   	push   %ebp
f0109f43:	89 e5                	mov    %esp,%ebp
f0109f45:	53                   	push   %ebx
	// Fill this function in
	if(dfn == 0) return;
f0109f46:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109f4a:	0f 84 9b 00 00 00    	je     f0109feb <free_disk_frame+0xa9>
	LIST_INSERT_HEAD(&disk_free_frame_list, &disk_frames_info[dfn]);
f0109f50:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109f56:	8b 55 08             	mov    0x8(%ebp),%edx
f0109f59:	89 d0                	mov    %edx,%eax
f0109f5b:	01 c0                	add    %eax,%eax
f0109f5d:	01 d0                	add    %edx,%eax
f0109f5f:	c1 e0 03             	shl    $0x3,%eax
f0109f62:	01 c8                	add    %ecx,%eax
f0109f64:	8b 15 94 67 4c f0    	mov    0xf04c6794,%edx
f0109f6a:	89 10                	mov    %edx,(%eax)
f0109f6c:	8b 00                	mov    (%eax),%eax
f0109f6e:	85 c0                	test   %eax,%eax
f0109f70:	74 1f                	je     f0109f91 <free_disk_frame+0x4f>
f0109f72:	8b 15 94 67 4c f0    	mov    0xf04c6794,%edx
f0109f78:	8b 1d 70 52 45 f0    	mov    0xf0455270,%ebx
f0109f7e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109f81:	89 c8                	mov    %ecx,%eax
f0109f83:	01 c0                	add    %eax,%eax
f0109f85:	01 c8                	add    %ecx,%eax
f0109f87:	c1 e0 03             	shl    $0x3,%eax
f0109f8a:	01 d8                	add    %ebx,%eax
f0109f8c:	89 42 04             	mov    %eax,0x4(%edx)
f0109f8f:	eb 19                	jmp    f0109faa <free_disk_frame+0x68>
f0109f91:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109f97:	8b 55 08             	mov    0x8(%ebp),%edx
f0109f9a:	89 d0                	mov    %edx,%eax
f0109f9c:	01 c0                	add    %eax,%eax
f0109f9e:	01 d0                	add    %edx,%eax
f0109fa0:	c1 e0 03             	shl    $0x3,%eax
f0109fa3:	01 c8                	add    %ecx,%eax
f0109fa5:	a3 98 67 4c f0       	mov    %eax,0xf04c6798
f0109faa:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109fb0:	8b 55 08             	mov    0x8(%ebp),%edx
f0109fb3:	89 d0                	mov    %edx,%eax
f0109fb5:	01 c0                	add    %eax,%eax
f0109fb7:	01 d0                	add    %edx,%eax
f0109fb9:	c1 e0 03             	shl    $0x3,%eax
f0109fbc:	01 c8                	add    %ecx,%eax
f0109fbe:	a3 94 67 4c f0       	mov    %eax,0xf04c6794
f0109fc3:	8b 0d 70 52 45 f0    	mov    0xf0455270,%ecx
f0109fc9:	8b 55 08             	mov    0x8(%ebp),%edx
f0109fcc:	89 d0                	mov    %edx,%eax
f0109fce:	01 c0                	add    %eax,%eax
f0109fd0:	01 d0                	add    %edx,%eax
f0109fd2:	c1 e0 03             	shl    $0x3,%eax
f0109fd5:	01 c8                	add    %ecx,%eax
f0109fd7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109fde:	a1 a0 67 4c f0       	mov    0xf04c67a0,%eax
f0109fe3:	40                   	inc    %eax
f0109fe4:	a3 a0 67 4c f0       	mov    %eax,0xf04c67a0
f0109fe9:	eb 01                	jmp    f0109fec <free_disk_frame+0xaa>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0109feb:	90                   	nop
	LIST_INSERT_HEAD(&disk_free_frame_list, &disk_frames_info[dfn]);
}
f0109fec:	5b                   	pop    %ebx
f0109fed:	5d                   	pop    %ebp
f0109fee:	c3                   	ret    

f0109fef <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const void *virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0109fef:	55                   	push   %ebp
f0109ff0:	89 e5                	mov    %esp,%ebp
f0109ff2:	53                   	push   %ebx
f0109ff3:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0109ff6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ff9:	c1 e8 16             	shr    $0x16,%eax
f0109ffc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a003:	8b 45 08             	mov    0x8(%ebp),%eax
f010a006:	01 d0                	add    %edx,%eax
f010a008:	8b 00                	mov    (%eax),%eax
f010a00a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010a00d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a010:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010a015:	77 1d                	ja     f010a034 <get_disk_page_table+0x45>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010a017:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a01a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a01f:	83 ec 0c             	sub    $0xc,%esp
f010a022:	50                   	push   %eax
f010a023:	e8 7b 11 00 00       	call   f010b1a3 <kheap_virtual_address>
f010a028:	83 c4 10             	add    $0x10,%esp
f010a02b:	89 c2                	mov    %eax,%edx
f010a02d:	8b 45 14             	mov    0x14(%ebp),%eax
f010a030:	89 10                	mov    %edx,(%eax)
f010a032:	eb 44                	jmp    f010a078 <get_disk_page_table+0x89>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f010a034:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a037:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a03c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a03f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a042:	c1 e8 0c             	shr    $0xc,%eax
f010a045:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a048:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f010a04d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f010a050:	72 17                	jb     f010a069 <get_disk_page_table+0x7a>
f010a052:	ff 75 f0             	pushl  -0x10(%ebp)
f010a055:	68 bc 1e 11 f0       	push   $0xf0111ebc
f010a05a:	68 9b 00 00 00       	push   $0x9b
f010a05f:	68 a7 1e 11 f0       	push   $0xf0111ea7
f010a064:	e8 f3 60 ff ff       	call   f010015c <_panic>
f010a069:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a06c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010a071:	89 c2                	mov    %eax,%edx
f010a073:	8b 45 14             	mov    0x14(%ebp),%eax
f010a076:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010a078:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a07c:	0f 85 80 00 00 00    	jne    f010a102 <get_disk_page_table+0x113>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010a082:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a086:	74 6a                	je     f010a0f2 <get_disk_page_table+0x103>
		{

			if(USE_KHEAP)
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010a088:	83 ec 0c             	sub    $0xc,%esp
f010a08b:	68 00 10 00 00       	push   $0x1000
f010a090:	e8 90 0c 00 00       	call   f010ad25 <kmalloc>
f010a095:	83 c4 10             	add    $0x10,%esp
f010a098:	89 c2                	mov    %eax,%edx
f010a09a:	8b 45 14             	mov    0x14(%ebp),%eax
f010a09d:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f010a09f:	8b 45 14             	mov    0x14(%ebp),%eax
f010a0a2:	8b 00                	mov    (%eax),%eax
f010a0a4:	85 c0                	test   %eax,%eax
f010a0a6:	75 07                	jne    f010a0af <get_disk_page_table+0xc0>
				{
					return E_NO_VM;
f010a0a8:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010a0ad:	eb 58                	jmp    f010a107 <get_disk_page_table+0x118>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010a0af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a0b2:	c1 e8 16             	shr    $0x16,%eax
f010a0b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a0bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0bf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010a0c2:	8b 45 14             	mov    0x14(%ebp),%eax
f010a0c5:	8b 00                	mov    (%eax),%eax
f010a0c7:	83 ec 0c             	sub    $0xc,%esp
f010a0ca:	50                   	push   %eax
f010a0cb:	e8 f2 10 00 00       	call   f010b1c2 <kheap_physical_address>
f010a0d0:	83 c4 10             	add    $0x10,%esp
f010a0d3:	83 c8 01             	or     $0x1,%eax
f010a0d6:	89 03                	mov    %eax,(%ebx)
				*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f010a0d8:	8b 45 14             	mov    0x14(%ebp),%eax
f010a0db:	8b 00                	mov    (%eax),%eax
f010a0dd:	83 ec 04             	sub    $0x4,%esp
f010a0e0:	68 00 10 00 00       	push   $0x1000
f010a0e5:	6a 00                	push   $0x0
f010a0e7:	50                   	push   %eax
f010a0e8:	e8 b1 4b 00 00       	call   f010ec9e <memset>
f010a0ed:	83 c4 10             	add    $0x10,%esp
f010a0f0:	eb 10                	jmp    f010a102 <get_disk_page_table+0x113>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f010a0f2:	8b 45 14             	mov    0x14(%ebp),%eax
f010a0f5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f010a0fb:	b8 00 00 00 00       	mov    $0x0,%eax
f010a100:	eb 05                	jmp    f010a107 <get_disk_page_table+0x118>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f010a102:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a107:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a10a:	c9                   	leave  
f010a10b:	c3                   	ret    

f010a10c <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f010a10c:	55                   	push   %ebp
f010a10d:	89 e5                	mov    %esp,%ebp
f010a10f:	83 ec 28             	sub    $0x28,%esp
f010a112:	8b 45 10             	mov    0x10(%ebp),%eax
f010a115:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010a118:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f010a11c:	74 1c                	je     f010a13a <pf_add_empty_env_page+0x2e>
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f010a11e:	a1 88 52 45 f0       	mov    0xf0455288,%eax
f010a123:	83 ec 04             	sub    $0x4,%esp
f010a126:	50                   	push   %eax
f010a127:	ff 75 0c             	pushl  0xc(%ebp)
f010a12a:	ff 75 08             	pushl  0x8(%ebp)
f010a12d:	e8 b3 00 00 00       	call   f010a1e5 <pf_add_env_page>
f010a132:	83 c4 10             	add    $0x10,%esp
f010a135:	e9 a9 00 00 00       	jmp    f010a1e3 <pf_add_empty_env_page+0xd7>

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010a13a:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010a141:	76 19                	jbe    f010a15c <pf_add_empty_env_page+0x50>
f010a143:	68 ec 1e 11 f0       	push   $0xf0111eec
f010a148:	68 12 1f 11 f0       	push   $0xf0111f12
f010a14d:	68 d3 00 00 00       	push   $0xd3
f010a152:	68 a7 1e 11 f0       	push   $0xf0111ea7
f010a157:	e8 00 60 ff ff       	call   f010015c <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010a15c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a15f:	83 c0 64             	add    $0x64,%eax
f010a162:	83 ec 08             	sub    $0x8,%esp
f010a165:	50                   	push   %eax
f010a166:	ff 75 08             	pushl  0x8(%ebp)
f010a169:	e8 96 04 00 00       	call   f010a604 <get_disk_page_directory>
f010a16e:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, (void*) virtual_address, 1, &ptr_disk_page_table) ;
f010a171:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a174:	8b 45 08             	mov    0x8(%ebp),%eax
f010a177:	8b 40 64             	mov    0x64(%eax),%eax
f010a17a:	8d 4d f4             	lea    -0xc(%ebp),%ecx
f010a17d:	51                   	push   %ecx
f010a17e:	6a 01                	push   $0x1
f010a180:	52                   	push   %edx
f010a181:	50                   	push   %eax
f010a182:	e8 68 fe ff ff       	call   f0109fef <get_disk_page_table>
f010a187:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010a18a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a18d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a190:	c1 ea 0c             	shr    $0xc,%edx
f010a193:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a199:	c1 e2 02             	shl    $0x2,%edx
f010a19c:	01 d0                	add    %edx,%eax
f010a19e:	8b 00                	mov    (%eax),%eax
f010a1a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f010a1a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1a6:	85 c0                	test   %eax,%eax
f010a1a8:	75 34                	jne    f010a1de <pf_add_empty_env_page+0xd2>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010a1aa:	83 ec 0c             	sub    $0xc,%esp
f010a1ad:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a1b0:	50                   	push   %eax
f010a1b1:	e8 df fc ff ff       	call   f0109e95 <allocate_disk_frame>
f010a1b6:	83 c4 10             	add    $0x10,%esp
f010a1b9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a1bc:	75 07                	jne    f010a1c5 <pf_add_empty_env_page+0xb9>
f010a1be:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010a1c3:	eb 1e                	jmp    f010a1e3 <pf_add_empty_env_page+0xd7>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f010a1c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a1c8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a1cb:	c1 ea 0c             	shr    $0xc,%edx
f010a1ce:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a1d4:	c1 e2 02             	shl    $0x2,%edx
f010a1d7:	01 c2                	add    %eax,%edx
f010a1d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1dc:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010a1de:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010a1e3:	c9                   	leave  
f010a1e4:	c3                   	ret    

f010a1e5 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f010a1e5:	55                   	push   %ebp
f010a1e6:	89 e5                	mov    %esp,%ebp
f010a1e8:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010a1eb:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010a1f2:	76 19                	jbe    f010a20d <pf_add_env_page+0x28>
f010a1f4:	68 ec 1e 11 f0       	push   $0xf0111eec
f010a1f9:	68 12 1f 11 f0       	push   $0xf0111f12
f010a1fe:	68 e8 00 00 00       	push   $0xe8
f010a203:	68 a7 1e 11 f0       	push   $0xf0111ea7
f010a208:	e8 4f 5f ff ff       	call   f010015c <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010a20d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a210:	83 c0 64             	add    $0x64,%eax
f010a213:	83 ec 08             	sub    $0x8,%esp
f010a216:	50                   	push   %eax
f010a217:	ff 75 08             	pushl  0x8(%ebp)
f010a21a:	e8 e5 03 00 00       	call   f010a604 <get_disk_page_directory>
f010a21f:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, (void*) virtual_address, 1, &ptr_disk_page_table) ;
f010a222:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a225:	8b 45 08             	mov    0x8(%ebp),%eax
f010a228:	8b 40 64             	mov    0x64(%eax),%eax
f010a22b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
f010a22e:	51                   	push   %ecx
f010a22f:	6a 01                	push   $0x1
f010a231:	52                   	push   %edx
f010a232:	50                   	push   %eax
f010a233:	e8 b7 fd ff ff       	call   f0109fef <get_disk_page_table>
f010a238:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010a23b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a23e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a241:	c1 ea 0c             	shr    $0xc,%edx
f010a244:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a24a:	c1 e2 02             	shl    $0x2,%edx
f010a24d:	01 d0                	add    %edx,%eax
f010a24f:	8b 00                	mov    (%eax),%eax
f010a251:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f010a254:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a257:	85 c0                	test   %eax,%eax
f010a259:	75 34                	jne    f010a28f <pf_add_env_page+0xaa>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010a25b:	83 ec 0c             	sub    $0xc,%esp
f010a25e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010a261:	50                   	push   %eax
f010a262:	e8 2e fc ff ff       	call   f0109e95 <allocate_disk_frame>
f010a267:	83 c4 10             	add    $0x10,%esp
f010a26a:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a26d:	75 07                	jne    f010a276 <pf_add_env_page+0x91>
f010a26f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010a274:	eb 31                	jmp    f010a2a7 <pf_add_env_page+0xc2>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f010a276:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a279:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a27c:	c1 ea 0c             	shr    $0xc,%edx
f010a27f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a285:	c1 e2 02             	shl    $0x2,%edx
f010a288:	01 c2                	add    %eax,%edx
f010a28a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a28d:	89 02                	mov    %eax,(%edx)
//	uint32 oldDir = rcr3();
//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
//	int ret = write_disk_page(dfn, (void*)dataSrc);
//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f010a28f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a292:	83 ec 08             	sub    $0x8,%esp
f010a295:	ff 75 10             	pushl  0x10(%ebp)
f010a298:	50                   	push   %eax
f010a299:	e8 76 fa ff ff       	call   f0109d14 <write_disk_page>
f010a29e:	83 c4 10             	add    $0x10,%esp
f010a2a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f010a2a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010a2a7:	c9                   	leave  
f010a2a8:	c3                   	ret    

f010a2a9 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, void *virtual_address, struct Frame_Info* modified_page_frame_info)
{
f010a2a9:	55                   	push   %ebp
f010a2aa:	89 e5                	mov    %esp,%ebp
f010a2ac:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f010a2af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a2b2:	3d ff ff ff ef       	cmp    $0xefffffff,%eax
f010a2b7:	76 19                	jbe    f010a2d2 <pf_update_env_page+0x29>
f010a2b9:	68 ec 1e 11 f0       	push   $0xf0111eec
f010a2be:	68 12 1f 11 f0       	push   $0xf0111f12
f010a2c3:	68 09 01 00 00       	push   $0x109
f010a2c8:	68 a7 1e 11 f0       	push   $0xf0111ea7
f010a2cd:	e8 8a 5e ff ff       	call   f010015c <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010a2d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2d5:	83 c0 64             	add    $0x64,%eax
f010a2d8:	83 ec 08             	sub    $0x8,%esp
f010a2db:	50                   	push   %eax
f010a2dc:	ff 75 08             	pushl  0x8(%ebp)
f010a2df:	e8 20 03 00 00       	call   f010a604 <get_disk_page_directory>
f010a2e4:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010a2e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2ea:	8b 40 64             	mov    0x64(%eax),%eax
f010a2ed:	8d 55 e8             	lea    -0x18(%ebp),%edx
f010a2f0:	52                   	push   %edx
f010a2f1:	6a 00                	push   $0x0
f010a2f3:	ff 75 0c             	pushl  0xc(%ebp)
f010a2f6:	50                   	push   %eax
f010a2f7:	e8 f3 fc ff ff       	call   f0109fef <get_disk_page_table>
f010a2fc:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010a2ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a302:	85 c0                	test   %eax,%eax
f010a304:	75 0a                	jne    f010a310 <pf_update_env_page+0x67>
f010a306:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010a30b:	e9 96 00 00 00       	jmp    f010a3a6 <pf_update_env_page+0xfd>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010a310:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a313:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a316:	c1 ea 0c             	shr    $0xc,%edx
f010a319:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a31f:	c1 e2 02             	shl    $0x2,%edx
f010a322:	01 d0                	add    %edx,%eax
f010a324:	8b 00                	mov    (%eax),%eax
f010a326:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010a329:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a32d:	75 07                	jne    f010a336 <pf_update_env_page+0x8d>
f010a32f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010a334:	eb 70                	jmp    f010a3a6 <pf_update_env_page+0xfd>
	if(USE_KHEAP)
	{
		//FIX: we should implement a better solution for this, but for now
			//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
			//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (void*)USER_LIMIT, 0);
f010a336:	8b 45 08             	mov    0x8(%ebp),%eax
f010a339:	8b 40 5c             	mov    0x5c(%eax),%eax
f010a33c:	6a 00                	push   $0x0
f010a33e:	68 00 00 80 ef       	push   $0xef800000
f010a343:	ff 75 10             	pushl  0x10(%ebp)
f010a346:	50                   	push   %eax
f010a347:	e8 4f 8c ff ff       	call   f0102f9b <map_frame>
f010a34c:	83 c4 10             	add    $0x10,%esp
		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f010a34f:	c7 45 f0 00 00 80 ef 	movl   $0xef800000,-0x10(%ebp)
f010a356:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a359:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a35e:	83 ec 08             	sub    $0x8,%esp
f010a361:	50                   	push   %eax
f010a362:	ff 75 f4             	pushl  -0xc(%ebp)
f010a365:	e8 aa f9 ff ff       	call   f0109d14 <write_disk_page>
f010a36a:	83 c4 10             	add    $0x10,%esp
f010a36d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f010a370:	8b 45 10             	mov    0x10(%ebp),%eax
f010a373:	8b 40 08             	mov    0x8(%eax),%eax
f010a376:	40                   	inc    %eax
f010a377:	8b 55 10             	mov    0x10(%ebp),%edx
f010a37a:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (void*)USER_LIMIT);
f010a37e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a381:	8b 40 5c             	mov    0x5c(%eax),%eax
f010a384:	83 ec 08             	sub    $0x8,%esp
f010a387:	68 00 00 80 ef       	push   $0xef800000
f010a38c:	50                   	push   %eax
f010a38d:	e8 38 8d ff ff       	call   f01030ca <unmap_frame>
f010a392:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f010a395:	8b 45 10             	mov    0x10(%ebp),%eax
f010a398:	8b 40 08             	mov    0x8(%eax),%eax
f010a39b:	48                   	dec    %eax
f010a39c:	8b 55 10             	mov    0x10(%ebp),%edx
f010a39f:	66 89 42 08          	mov    %ax,0x8(%edx)
	else
	{
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
	return ret;
f010a3a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010a3a6:	c9                   	leave  
f010a3a7:	c3                   	ret    

f010a3a8 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
*/
int pf_read_env_page(struct Env* ptr_env, void *virtual_address)
{
f010a3a8:	55                   	push   %ebp
f010a3a9:	89 e5                	mov    %esp,%ebp
f010a3ab:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = (void*) ROUNDDOWN((uint32)virtual_address, PAGE_SIZE);
f010a3ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a3b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a3b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a3b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3bc:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010a3bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3c2:	8b 40 64             	mov    0x64(%eax),%eax
f010a3c5:	85 c0                	test   %eax,%eax
f010a3c7:	75 07                	jne    f010a3d0 <pf_read_env_page+0x28>
f010a3c9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010a3ce:	eb 79                	jmp    f010a449 <pf_read_env_page+0xa1>

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010a3d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3d3:	8b 40 64             	mov    0x64(%eax),%eax
f010a3d6:	8d 55 e8             	lea    -0x18(%ebp),%edx
f010a3d9:	52                   	push   %edx
f010a3da:	6a 00                	push   $0x0
f010a3dc:	ff 75 0c             	pushl  0xc(%ebp)
f010a3df:	50                   	push   %eax
f010a3e0:	e8 0a fc ff ff       	call   f0109fef <get_disk_page_table>
f010a3e5:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010a3e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a3eb:	85 c0                	test   %eax,%eax
f010a3ed:	75 07                	jne    f010a3f6 <pf_read_env_page+0x4e>
f010a3ef:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010a3f4:	eb 53                	jmp    f010a449 <pf_read_env_page+0xa1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010a3f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a3f9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a3fc:	c1 ea 0c             	shr    $0xc,%edx
f010a3ff:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a405:	c1 e2 02             	shl    $0x2,%edx
f010a408:	01 d0                	add    %edx,%eax
f010a40a:	8b 00                	mov    (%eax),%eax
f010a40c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010a40f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a413:	75 07                	jne    f010a41c <pf_read_env_page+0x74>
f010a415:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010a41a:	eb 2d                	jmp    f010a449 <pf_read_env_page+0xa1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010a41c:	83 ec 08             	sub    $0x8,%esp
f010a41f:	ff 75 0c             	pushl  0xc(%ebp)
f010a422:	ff 75 f0             	pushl  -0x10(%ebp)
f010a425:	e8 bb f8 ff ff       	call   f0109ce5 <read_disk_page>
f010a42a:	83 c4 10             	add    $0x10,%esp
f010a42d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(curenv, (uint32)virtual_address, 0, PERM_MODIFIED);
f010a430:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a433:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010a438:	6a 40                	push   $0x40
f010a43a:	6a 00                	push   $0x0
f010a43c:	52                   	push   %edx
f010a43d:	50                   	push   %eax
f010a43e:	e8 74 9b ff ff       	call   f0103fb7 <pt_set_page_permissions>
f010a443:	83 c4 10             	add    $0x10,%esp

	return disk_read_error;
f010a446:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010a449:	c9                   	leave  
f010a44a:	c3                   	ret    

f010a44b <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f010a44b:	55                   	push   %ebp
f010a44c:	89 e5                	mov    %esp,%ebp
f010a44e:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010a451:	8b 45 08             	mov    0x8(%ebp),%eax
f010a454:	8b 40 64             	mov    0x64(%eax),%eax
f010a457:	85 c0                	test   %eax,%eax
f010a459:	74 63                	je     f010a4be <pf_remove_env_page+0x73>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, (void*)virtual_address, 0, &ptr_disk_page_table);
f010a45b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a45e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a461:	8b 40 64             	mov    0x64(%eax),%eax
f010a464:	8d 4d f0             	lea    -0x10(%ebp),%ecx
f010a467:	51                   	push   %ecx
f010a468:	6a 00                	push   $0x0
f010a46a:	52                   	push   %edx
f010a46b:	50                   	push   %eax
f010a46c:	e8 7e fb ff ff       	call   f0109fef <get_disk_page_table>
f010a471:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f010a474:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a477:	85 c0                	test   %eax,%eax
f010a479:	74 46                	je     f010a4c1 <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010a47b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a47e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a481:	c1 ea 0c             	shr    $0xc,%edx
f010a484:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a48a:	c1 e2 02             	shl    $0x2,%edx
f010a48d:	01 d0                	add    %edx,%eax
f010a48f:	8b 00                	mov    (%eax),%eax
f010a491:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f010a494:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a497:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a49a:	c1 ea 0c             	shr    $0xc,%edx
f010a49d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a4a3:	c1 e2 02             	shl    $0x2,%edx
f010a4a6:	01 d0                	add    %edx,%eax
f010a4a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010a4ae:	83 ec 0c             	sub    $0xc,%esp
f010a4b1:	ff 75 f4             	pushl  -0xc(%ebp)
f010a4b4:	e8 89 fa ff ff       	call   f0109f42 <free_disk_frame>
f010a4b9:	83 c4 10             	add    $0x10,%esp
f010a4bc:	eb 04                	jmp    f010a4c2 <pf_remove_env_page+0x77>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010a4be:	90                   	nop
f010a4bf:	eb 01                	jmp    f010a4c2 <pf_remove_env_page+0x77>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, (void*)virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010a4c1:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f010a4c2:	c9                   	leave  
f010a4c3:	c3                   	ret    

f010a4c4 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f010a4c4:	55                   	push   %ebp
f010a4c5:	89 e5                	mov    %esp,%ebp
f010a4c7:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010a4ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a4d1:	e9 b8 00 00 00       	jmp    f010a58e <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f010a4d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4d9:	8b 40 64             	mov    0x64(%eax),%eax
f010a4dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a4df:	c1 e2 02             	shl    $0x2,%edx
f010a4e2:	01 d0                	add    %edx,%eax
f010a4e4:	8b 00                	mov    (%eax),%eax
f010a4e6:	83 e0 01             	and    $0x1,%eax
f010a4e9:	85 c0                	test   %eax,%eax
f010a4eb:	0f 84 99 00 00 00    	je     f010a58a <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f010a4f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4f4:	8b 40 64             	mov    0x64(%eax),%eax
f010a4f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a4fa:	c1 e2 02             	shl    $0x2,%edx
f010a4fd:	01 d0                	add    %edx,%eax
f010a4ff:	8b 00                	mov    (%eax),%eax
f010a501:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a506:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
		if(USE_KHEAP)
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010a509:	83 ec 0c             	sub    $0xc,%esp
f010a50c:	ff 75 ec             	pushl  -0x14(%ebp)
f010a50f:	e8 8f 0c 00 00       	call   f010b1a3 <kheap_virtual_address>
f010a514:	83 c4 10             	add    $0x10,%esp
f010a517:	89 45 e8             	mov    %eax,-0x18(%ebp)
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010a51a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010a521:	eb 3a                	jmp    f010a55d <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f010a523:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a526:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a52d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a530:	01 d0                	add    %edx,%eax
f010a532:	8b 00                	mov    (%eax),%eax
f010a534:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010a537:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a53a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a541:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a544:	01 d0                	add    %edx,%eax
f010a546:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f010a54c:	83 ec 0c             	sub    $0xc,%esp
f010a54f:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a552:	e8 eb f9 ff ff       	call   f0109f42 <free_disk_frame>
f010a557:	83 c4 10             	add    $0x10,%esp
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010a55a:	ff 45 f0             	incl   -0x10(%ebp)
f010a55d:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f010a564:	76 bd                	jbe    f010a523 <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f010a566:	8b 45 08             	mov    0x8(%ebp),%eax
f010a569:	8b 40 64             	mov    0x64(%eax),%eax
f010a56c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a56f:	c1 e2 02             	shl    $0x2,%edx
f010a572:	01 d0                	add    %edx,%eax
f010a574:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if(USE_KHEAP)
		{
			kfree(pt);
f010a57a:	83 ec 0c             	sub    $0xc,%esp
f010a57d:	ff 75 e8             	pushl  -0x18(%ebp)
f010a580:	e8 19 0b 00 00       	call   f010b09e <kfree>
f010a585:	83 c4 10             	add    $0x10,%esp
f010a588:	eb 01                	jmp    f010a58b <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f010a58a:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010a58b:	ff 45 f4             	incl   -0xc(%ebp)
f010a58e:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010a595:	0f 86 3b ff ff ff    	jbe    f010a4d6 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
	if(USE_KHEAP)
	{
		kfree(ptr_env->disk_env_pgdir);
f010a59b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a59e:	8b 40 64             	mov    0x64(%eax),%eax
f010a5a1:	83 ec 0c             	sub    $0xc,%esp
f010a5a4:	50                   	push   %eax
f010a5a5:	e8 f4 0a 00 00       	call   f010b09e <kfree>
f010a5aa:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
	ptr_env->disk_env_pgdir = 0;
f010a5ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5b0:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f010a5b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5ba:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f010a5c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5c4:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a5c7:	85 c0                	test   %eax,%eax
f010a5c9:	74 36                	je     f010a601 <pf_free_env+0x13d>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010a5cb:	83 ec 0c             	sub    $0xc,%esp
f010a5ce:	ff 75 08             	pushl  0x8(%ebp)
f010a5d1:	e8 05 03 00 00       	call   f010a8db <__pf_remove_env_all_tables>
f010a5d6:	83 c4 10             	add    $0x10,%esp


	if(USE_KHEAP)
	{
		kfree(ptr_env->disk_env_tabledir);
f010a5d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5dc:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a5df:	83 ec 0c             	sub    $0xc,%esp
f010a5e2:	50                   	push   %eax
f010a5e3:	e8 b6 0a 00 00       	call   f010b09e <kfree>
f010a5e8:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
	ptr_env->disk_env_tabledir = 0;
f010a5eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5ee:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f010a5f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5f8:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
f010a5ff:	eb 01                	jmp    f010a602 <pf_free_env+0x13e>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010a601:	90                   	nop
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010a602:	c9                   	leave  
f010a603:	c3                   	ret    

f010a604 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f010a604:	55                   	push   %ebp
f010a605:	89 e5                	mov    %esp,%ebp
f010a607:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f010a60a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a60d:	8b 50 64             	mov    0x64(%eax),%edx
f010a610:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a613:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f010a615:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a618:	8b 00                	mov    (%eax),%eax
f010a61a:	85 c0                	test   %eax,%eax
f010a61c:	75 58                	jne    f010a676 <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
		if(USE_KHEAP)
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010a61e:	83 ec 0c             	sub    $0xc,%esp
f010a621:	68 00 10 00 00       	push   $0x1000
f010a626:	e8 fa 06 00 00       	call   f010ad25 <kmalloc>
f010a62b:	83 c4 10             	add    $0x10,%esp
f010a62e:	89 c2                	mov    %eax,%edx
f010a630:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a633:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f010a635:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a638:	8b 00                	mov    (%eax),%eax
f010a63a:	85 c0                	test   %eax,%eax
f010a63c:	75 07                	jne    f010a645 <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f010a63e:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010a643:	eb 36                	jmp    f010a67b <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f010a645:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a648:	8b 00                	mov    (%eax),%eax
f010a64a:	83 ec 0c             	sub    $0xc,%esp
f010a64d:	50                   	push   %eax
f010a64e:	e8 6f 0b 00 00       	call   f010b1c2 <kheap_physical_address>
f010a653:	83 c4 10             	add    $0x10,%esp
f010a656:	89 c2                	mov    %eax,%edx
f010a658:	8b 45 08             	mov    0x8(%ebp),%eax
f010a65b:	89 50 68             	mov    %edx,0x68(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}

		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f010a65e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a661:	8b 00                	mov    (%eax),%eax
f010a663:	83 ec 04             	sub    $0x4,%esp
f010a666:	68 00 10 00 00       	push   $0x1000
f010a66b:	6a 00                	push   $0x0
f010a66d:	50                   	push   %eax
f010a66e:	e8 2b 46 00 00       	call   f010ec9e <memset>
f010a673:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010a676:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a67b:	c9                   	leave  
f010a67c:	c3                   	ret    

f010a67d <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f010a67d:	55                   	push   %ebp
f010a67e:	89 e5                	mov    %esp,%ebp
f010a680:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f010a683:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010a68a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a691:	eb 78                	jmp    f010a70b <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f010a693:	8b 45 08             	mov    0x8(%ebp),%eax
f010a696:	8b 40 64             	mov    0x64(%eax),%eax
f010a699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a69c:	c1 e2 02             	shl    $0x2,%edx
f010a69f:	01 d0                	add    %edx,%eax
f010a6a1:	8b 00                	mov    (%eax),%eax
f010a6a3:	83 e0 01             	and    $0x1,%eax
f010a6a6:	85 c0                	test   %eax,%eax
f010a6a8:	74 5d                	je     f010a707 <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010a6aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6ad:	8b 40 64             	mov    0x64(%eax),%eax
f010a6b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a6b3:	c1 e2 02             	shl    $0x2,%edx
f010a6b6:	01 d0                	add    %edx,%eax
f010a6b8:	8b 00                	mov    (%eax),%eax
f010a6ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a6bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if(USE_KHEAP)
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010a6c2:	83 ec 0c             	sub    $0xc,%esp
f010a6c5:	ff 75 e8             	pushl  -0x18(%ebp)
f010a6c8:	e8 d6 0a 00 00       	call   f010b1a3 <kheap_virtual_address>
f010a6cd:	83 c4 10             	add    $0x10,%esp
f010a6d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}


		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010a6d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010a6da:	eb 20                	jmp    f010a6fc <pf_calculate_allocated_pages+0x7f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f010a6dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a6e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a6e9:	01 d0                	add    %edx,%eax
f010a6eb:	8b 00                	mov    (%eax),%eax
f010a6ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f010a6f0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a6f4:	74 03                	je     f010a6f9 <pf_calculate_allocated_pages+0x7c>
				counter ++;
f010a6f6:	ff 45 f0             	incl   -0x10(%ebp)
		}


		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010a6f9:	ff 45 ec             	incl   -0x14(%ebp)
f010a6fc:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010a703:	76 d7                	jbe    f010a6dc <pf_calculate_allocated_pages+0x5f>
f010a705:	eb 01                	jmp    f010a708 <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010a707:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010a708:	ff 45 f4             	incl   -0xc(%ebp)
f010a70b:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010a712:	0f 86 7b ff ff ff    	jbe    f010a693 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f010a718:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010a71b:	c9                   	leave  
f010a71c:	c3                   	ret    

f010a71d <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f010a71d:	55                   	push   %ebp
f010a71e:	89 e5                	mov    %esp,%ebp
f010a720:	83 ec 10             	sub    $0x10,%esp
	struct Frame_Info *ptr;
	uint32 totalFreeDiskFrames = 0 ;
f010a723:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	LIST_FOREACH(ptr, &disk_free_frame_list)
f010a72a:	a1 94 67 4c f0       	mov    0xf04c6794,%eax
f010a72f:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010a732:	eb 0b                	jmp    f010a73f <pf_calculate_free_frames+0x22>
	{
		totalFreeDiskFrames++ ;
f010a734:	ff 45 f8             	incl   -0x8(%ebp)
int pf_calculate_free_frames()
{
	struct Frame_Info *ptr;
	uint32 totalFreeDiskFrames = 0 ;

	LIST_FOREACH(ptr, &disk_free_frame_list)
f010a737:	a1 9c 67 4c f0       	mov    0xf04c679c,%eax
f010a73c:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010a73f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010a743:	74 07                	je     f010a74c <pf_calculate_free_frames+0x2f>
f010a745:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a748:	8b 00                	mov    (%eax),%eax
f010a74a:	eb 05                	jmp    f010a751 <pf_calculate_free_frames+0x34>
f010a74c:	b8 00 00 00 00       	mov    $0x0,%eax
f010a751:	a3 9c 67 4c f0       	mov    %eax,0xf04c679c
f010a756:	a1 9c 67 4c f0       	mov    0xf04c679c,%eax
f010a75b:	85 c0                	test   %eax,%eax
f010a75d:	75 d5                	jne    f010a734 <pf_calculate_free_frames+0x17>
f010a75f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010a763:	75 cf                	jne    f010a734 <pf_calculate_free_frames+0x17>
	{
		totalFreeDiskFrames++ ;
	}
	return totalFreeDiskFrames;
f010a765:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a768:	c9                   	leave  
f010a769:	c3                   	ret    

f010a76a <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f010a76a:	55                   	push   %ebp
f010a76b:	89 e5                	mov    %esp,%ebp
f010a76d:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f010a770:	8b 45 08             	mov    0x8(%ebp),%eax
f010a773:	8b 50 6c             	mov    0x6c(%eax),%edx
f010a776:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a779:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f010a77b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a77e:	8b 00                	mov    (%eax),%eax
f010a780:	85 c0                	test   %eax,%eax
f010a782:	75 58                	jne    f010a7dc <get_disk_table_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
		if(USE_KHEAP)
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f010a784:	83 ec 0c             	sub    $0xc,%esp
f010a787:	68 00 10 00 00       	push   $0x1000
f010a78c:	e8 94 05 00 00       	call   f010ad25 <kmalloc>
f010a791:	83 c4 10             	add    $0x10,%esp
f010a794:	89 c2                	mov    %eax,%edx
f010a796:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a799:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010a79b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a79e:	8b 00                	mov    (%eax),%eax
f010a7a0:	85 c0                	test   %eax,%eax
f010a7a2:	75 07                	jne    f010a7ab <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f010a7a4:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010a7a9:	eb 36                	jmp    f010a7e1 <get_disk_table_directory+0x77>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010a7ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a7ae:	8b 00                	mov    (%eax),%eax
f010a7b0:	83 ec 0c             	sub    $0xc,%esp
f010a7b3:	50                   	push   %eax
f010a7b4:	e8 09 0a 00 00       	call   f010b1c2 <kheap_physical_address>
f010a7b9:	83 c4 10             	add    $0x10,%esp
f010a7bc:	89 c2                	mov    %eax,%edx
f010a7be:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7c1:	89 50 70             	mov    %edx,0x70(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}

		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f010a7c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a7c7:	8b 00                	mov    (%eax),%eax
f010a7c9:	83 ec 04             	sub    $0x4,%esp
f010a7cc:	68 00 10 00 00       	push   $0x1000
f010a7d1:	6a 00                	push   $0x0
f010a7d3:	50                   	push   %eax
f010a7d4:	e8 c5 44 00 00       	call   f010ec9e <memset>
f010a7d9:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010a7dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a7e1:	c9                   	leave  
f010a7e2:	c3                   	ret    

f010a7e3 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f010a7e3:	55                   	push   %ebp
f010a7e4:	89 e5                	mov    %esp,%ebp
f010a7e6:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010a7e9:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010a7f0:	76 19                	jbe    f010a80b <__pf_write_env_table+0x28>
f010a7f2:	68 ec 1e 11 f0       	push   $0xf0111eec
f010a7f7:	68 12 1f 11 f0       	push   $0xf0111f12
f010a7fc:	68 3d 02 00 00       	push   $0x23d
f010a801:	68 a7 1e 11 f0       	push   $0xf0111ea7
f010a806:	e8 51 59 ff ff       	call   f010015c <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010a80b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a80e:	83 c0 6c             	add    $0x6c,%eax
f010a811:	83 ec 08             	sub    $0x8,%esp
f010a814:	50                   	push   %eax
f010a815:	ff 75 08             	pushl  0x8(%ebp)
f010a818:	e8 4d ff ff ff       	call   f010a76a <get_disk_table_directory>
f010a81d:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f010a820:	8b 45 08             	mov    0x8(%ebp),%eax
f010a823:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a826:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a829:	c1 ea 16             	shr    $0x16,%edx
f010a82c:	c1 e2 02             	shl    $0x2,%edx
f010a82f:	01 d0                	add    %edx,%eax
f010a831:	8b 00                	mov    (%eax),%eax
f010a833:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f010a836:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a839:	85 c0                	test   %eax,%eax
f010a83b:	75 31                	jne    f010a86e <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010a83d:	83 ec 0c             	sub    $0xc,%esp
f010a840:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a843:	50                   	push   %eax
f010a844:	e8 4c f6 ff ff       	call   f0109e95 <allocate_disk_frame>
f010a849:	83 c4 10             	add    $0x10,%esp
f010a84c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a84f:	75 07                	jne    f010a858 <__pf_write_env_table+0x75>
f010a851:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010a856:	eb 2e                	jmp    f010a886 <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f010a858:	8b 45 08             	mov    0x8(%ebp),%eax
f010a85b:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a85e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a861:	c1 ea 16             	shr    $0x16,%edx
f010a864:	c1 e2 02             	shl    $0x2,%edx
f010a867:	01 c2                	add    %eax,%edx
f010a869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a86c:	89 02                	mov    %eax,(%edx)
//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f010a86e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a871:	83 ec 08             	sub    $0x8,%esp
f010a874:	ff 75 10             	pushl  0x10(%ebp)
f010a877:	50                   	push   %eax
f010a878:	e8 97 f4 ff ff       	call   f0109d14 <write_disk_page>
f010a87d:	83 c4 10             	add    $0x10,%esp
f010a880:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f010a883:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010a886:	c9                   	leave  
f010a887:	c3                   	ret    

f010a888 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f010a888:	55                   	push   %ebp
f010a889:	89 e5                	mov    %esp,%ebp
f010a88b:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f010a88e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a891:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a894:	85 c0                	test   %eax,%eax
f010a896:	75 07                	jne    f010a89f <__pf_read_env_table+0x17>
f010a898:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f010a89d:	eb 3a                	jmp    f010a8d9 <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f010a89f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8a2:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a8a5:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a8a8:	c1 ea 16             	shr    $0x16,%edx
f010a8ab:	c1 e2 02             	shl    $0x2,%edx
f010a8ae:	01 d0                	add    %edx,%eax
f010a8b0:	8b 00                	mov    (%eax),%eax
f010a8b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f010a8b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a8b9:	75 07                	jne    f010a8c2 <__pf_read_env_table+0x3a>
f010a8bb:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f010a8c0:	eb 17                	jmp    f010a8d9 <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f010a8c2:	83 ec 08             	sub    $0x8,%esp
f010a8c5:	ff 75 10             	pushl  0x10(%ebp)
f010a8c8:	ff 75 f4             	pushl  -0xc(%ebp)
f010a8cb:	e8 15 f4 ff ff       	call   f0109ce5 <read_disk_page>
f010a8d0:	83 c4 10             	add    $0x10,%esp
f010a8d3:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f010a8d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010a8d9:	c9                   	leave  
f010a8da:	c3                   	ret    

f010a8db <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f010a8db:	55                   	push   %ebp
f010a8dc:	89 e5                	mov    %esp,%ebp
f010a8de:	83 ec 10             	sub    $0x10,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f010a8e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8e4:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a8e7:	85 c0                	test   %eax,%eax
f010a8e9:	74 49                	je     f010a934 <__pf_remove_env_all_tables+0x59>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010a8eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a8f2:	eb 35                	jmp    f010a929 <__pf_remove_env_all_tables+0x4e>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f010a8f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8f7:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a8fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a8fd:	c1 e2 02             	shl    $0x2,%edx
f010a900:	01 d0                	add    %edx,%eax
f010a902:	8b 00                	mov    (%eax),%eax
f010a904:	89 45 f8             	mov    %eax,-0x8(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f010a907:	8b 45 08             	mov    0x8(%ebp),%eax
f010a90a:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a90d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a910:	c1 e2 02             	shl    $0x2,%edx
f010a913:	01 d0                	add    %edx,%eax
f010a915:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f010a91b:	ff 75 f8             	pushl  -0x8(%ebp)
f010a91e:	e8 1f f6 ff ff       	call   f0109f42 <free_disk_frame>
f010a923:	83 c4 04             	add    $0x4,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010a926:	ff 45 fc             	incl   -0x4(%ebp)
f010a929:	81 7d fc ba 03 00 00 	cmpl   $0x3ba,-0x4(%ebp)
f010a930:	76 c2                	jbe    f010a8f4 <__pf_remove_env_all_tables+0x19>
f010a932:	eb 01                	jmp    f010a935 <__pf_remove_env_all_tables+0x5a>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f010a934:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f010a935:	c9                   	leave  
f010a936:	c3                   	ret    

f010a937 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f010a937:	55                   	push   %ebp
f010a938:	89 e5                	mov    %esp,%ebp
f010a93a:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f010a93d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010a941:	75 10                	jne    f010a953 <__pf_remove_env_table+0x1c>
			cprintf("REMOVING table 0 from page file\n");
f010a943:	83 ec 0c             	sub    $0xc,%esp
f010a946:	68 28 1f 11 f0       	push   $0xf0111f28
f010a94b:	e8 0b b7 ff ff       	call   f010605b <cprintf>
f010a950:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f010a953:	8b 45 08             	mov    0x8(%ebp),%eax
f010a956:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a959:	85 c0                	test   %eax,%eax
f010a95b:	74 3d                	je     f010a99a <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f010a95d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a960:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a963:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a966:	c1 ea 16             	shr    $0x16,%edx
f010a969:	c1 e2 02             	shl    $0x2,%edx
f010a96c:	01 d0                	add    %edx,%eax
f010a96e:	8b 00                	mov    (%eax),%eax
f010a970:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f010a973:	8b 45 08             	mov    0x8(%ebp),%eax
f010a976:	8b 40 6c             	mov    0x6c(%eax),%eax
f010a979:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a97c:	c1 ea 16             	shr    $0x16,%edx
f010a97f:	c1 e2 02             	shl    $0x2,%edx
f010a982:	01 d0                	add    %edx,%eax
f010a984:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010a98a:	83 ec 0c             	sub    $0xc,%esp
f010a98d:	ff 75 f4             	pushl  -0xc(%ebp)
f010a990:	e8 ad f5 ff ff       	call   f0109f42 <free_disk_frame>
f010a995:	83 c4 10             	add    $0x10,%esp
f010a998:	eb 01                	jmp    f010a99b <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
			cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f010a99a:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f010a99b:	c9                   	leave  
f010a99c:	c3                   	ret    

f010a99d <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f010a99d:	55                   	push   %ebp
f010a99e:	89 e5                	mov    %esp,%ebp
f010a9a0:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f010a9a3:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f010a9aa:	eb 1f                	jmp    f010a9cb <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f010a9ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9af:	83 ec 04             	sub    $0x4,%esp
f010a9b2:	6a 08                	push   $0x8
f010a9b4:	ff 75 08             	pushl  0x8(%ebp)
f010a9b7:	50                   	push   %eax
f010a9b8:	e8 86 49 00 00       	call   f010f343 <ide_write>
f010a9bd:	83 c4 10             	add    $0x10,%esp
f010a9c0:	85 c0                	test   %eax,%eax
f010a9c2:	75 12                	jne    f010a9d6 <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f010a9c4:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f010a9cb:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f010a9d2:	7e d8                	jle    f010a9ac <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f010a9d4:	eb 01                	jmp    f010a9d7 <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f010a9d6:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f010a9d7:	90                   	nop
f010a9d8:	c9                   	leave  
f010a9d9:	c3                   	ret    

f010a9da <getSemaphoreNumber>:

void enqueue(struct Env_Queue* queue, struct Env* env);
struct Env* dequeue(struct Env_Queue* queue);

int getSemaphoreNumber(char* name)
{
f010a9da:	55                   	push   %ebp
f010a9db:	89 e5                	mov    %esp,%ebp
f010a9dd:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a9e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(; i< nSemaphores; ++i)
f010a9e7:	eb 48                	jmp    f010aa31 <getSemaphoreNumber+0x57>
	{
		if(strcmp(name, semaphores[i].name)==0)
f010a9e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a9ec:	89 d0                	mov    %edx,%eax
f010a9ee:	c1 e0 02             	shl    $0x2,%eax
f010a9f1:	01 d0                	add    %edx,%eax
f010a9f3:	01 c0                	add    %eax,%eax
f010a9f5:	01 d0                	add    %edx,%eax
f010a9f7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010a9fe:	01 c8                	add    %ecx,%eax
f010aa00:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010aa07:	01 c8                	add    %ecx,%eax
f010aa09:	01 d0                	add    %edx,%eax
f010aa0b:	83 c0 10             	add    $0x10,%eax
f010aa0e:	05 c0 fb 4b f0       	add    $0xf04bfbc0,%eax
f010aa13:	83 c0 04             	add    $0x4,%eax
f010aa16:	83 ec 08             	sub    $0x8,%esp
f010aa19:	50                   	push   %eax
f010aa1a:	ff 75 08             	pushl  0x8(%ebp)
f010aa1d:	e8 9a 41 00 00       	call   f010ebbc <strcmp>
f010aa22:	83 c4 10             	add    $0x10,%esp
f010aa25:	85 c0                	test   %eax,%eax
f010aa27:	75 05                	jne    f010aa2e <getSemaphoreNumber+0x54>
		{
			return i;
f010aa29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa2c:	eb 12                	jmp    f010aa40 <getSemaphoreNumber+0x66>
struct Env* dequeue(struct Env_Queue* queue);

int getSemaphoreNumber(char* name)
{
	int i=0;
	for(; i< nSemaphores; ++i)
f010aa2e:	ff 45 f4             	incl   -0xc(%ebp)
f010aa31:	a1 e4 52 45 f0       	mov    0xf04552e4,%eax
f010aa36:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010aa39:	7c ae                	jl     f010a9e9 <getSemaphoreNumber+0xf>
		if(strcmp(name, semaphores[i].name)==0)
		{
			return i;
		}
	}
	return -1;
f010aa3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f010aa40:	c9                   	leave  
f010aa41:	c3                   	ret    

f010aa42 <createSemaphore>:

int createSemaphore(char* semaphoreName, uint32 initialValue)
{
f010aa42:	55                   	push   %ebp
f010aa43:	89 e5                	mov    %esp,%ebp
f010aa45:	83 ec 08             	sub    $0x8,%esp
	panic("This function is not required\n");
f010aa48:	83 ec 04             	sub    $0x4,%esp
f010aa4b:	68 4c 1f 11 f0       	push   $0xf0111f4c
f010aa50:	6a 1d                	push   $0x1d
f010aa52:	68 6b 1f 11 f0       	push   $0xf0111f6b
f010aa57:	e8 00 57 ff ff       	call   f010015c <_panic>

f010aa5c <waitSemaphore>:
	return 0;
}

void waitSemaphore(char* semaphoreName)
{
f010aa5c:	55                   	push   %ebp
f010aa5d:	89 e5                	mov    %esp,%ebp
f010aa5f:	83 ec 08             	sub    $0x8,%esp
	panic("This function is not required\n");
f010aa62:	83 ec 04             	sub    $0x4,%esp
f010aa65:	68 4c 1f 11 f0       	push   $0xf0111f4c
f010aa6a:	6a 23                	push   $0x23
f010aa6c:	68 6b 1f 11 f0       	push   $0xf0111f6b
f010aa71:	e8 e6 56 ff ff       	call   f010015c <_panic>

f010aa76 <signalSemaphore>:
}

void signalSemaphore(char* semaphoreName)
{
f010aa76:	55                   	push   %ebp
f010aa77:	89 e5                	mov    %esp,%ebp
f010aa79:	83 ec 08             	sub    $0x8,%esp
	panic("This function is not required\n");
f010aa7c:	83 ec 04             	sub    $0x4,%esp
f010aa7f:	68 4c 1f 11 f0       	push   $0xf0111f4c
f010aa84:	6a 28                	push   $0x28
f010aa86:	68 6b 1f 11 f0       	push   $0xf0111f6b
f010aa8b:	e8 cc 56 ff ff       	call   f010015c <_panic>

f010aa90 <enqueue>:
}

///// Helper Functions
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f010aa90:	55                   	push   %ebp
f010aa91:	89 e5                	mov    %esp,%ebp
	LIST_INSERT_HEAD(queue, env);
f010aa93:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa96:	8b 10                	mov    (%eax),%edx
f010aa98:	8b 45 0c             	mov    0xc(%ebp),%eax
f010aa9b:	89 50 44             	mov    %edx,0x44(%eax)
f010aa9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010aaa1:	8b 40 44             	mov    0x44(%eax),%eax
f010aaa4:	85 c0                	test   %eax,%eax
f010aaa6:	74 0d                	je     f010aab5 <enqueue+0x25>
f010aaa8:	8b 45 08             	mov    0x8(%ebp),%eax
f010aaab:	8b 00                	mov    (%eax),%eax
f010aaad:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aab0:	89 50 48             	mov    %edx,0x48(%eax)
f010aab3:	eb 09                	jmp    f010aabe <enqueue+0x2e>
f010aab5:	8b 45 08             	mov    0x8(%ebp),%eax
f010aab8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aabb:	89 50 04             	mov    %edx,0x4(%eax)
f010aabe:	8b 45 08             	mov    0x8(%ebp),%eax
f010aac1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aac4:	89 10                	mov    %edx,(%eax)
f010aac6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010aac9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f010aad0:	8b 45 08             	mov    0x8(%ebp),%eax
f010aad3:	8b 40 0c             	mov    0xc(%eax),%eax
f010aad6:	8d 50 01             	lea    0x1(%eax),%edx
f010aad9:	8b 45 08             	mov    0x8(%ebp),%eax
f010aadc:	89 50 0c             	mov    %edx,0xc(%eax)
}
f010aadf:	90                   	nop
f010aae0:	5d                   	pop    %ebp
f010aae1:	c3                   	ret    

f010aae2 <dequeue>:

struct Env* dequeue(struct Env_Queue* queue)
{
f010aae2:	55                   	push   %ebp
f010aae3:	89 e5                	mov    %esp,%ebp
f010aae5:	83 ec 10             	sub    $0x10,%esp
	struct Env* envItem = LIST_LAST(queue);
f010aae8:	8b 45 08             	mov    0x8(%ebp),%eax
f010aaeb:	8b 40 04             	mov    0x4(%eax),%eax
f010aaee:	89 45 fc             	mov    %eax,-0x4(%ebp)
	LIST_REMOVE(queue, envItem);
f010aaf1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010aaf4:	8b 40 44             	mov    0x44(%eax),%eax
f010aaf7:	85 c0                	test   %eax,%eax
f010aaf9:	74 11                	je     f010ab0c <dequeue+0x2a>
f010aafb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010aafe:	8b 40 44             	mov    0x44(%eax),%eax
f010ab01:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ab04:	8b 52 48             	mov    0x48(%edx),%edx
f010ab07:	89 50 48             	mov    %edx,0x48(%eax)
f010ab0a:	eb 0c                	jmp    f010ab18 <dequeue+0x36>
f010ab0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ab0f:	8b 50 48             	mov    0x48(%eax),%edx
f010ab12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab15:	89 50 04             	mov    %edx,0x4(%eax)
f010ab18:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ab1b:	8b 40 48             	mov    0x48(%eax),%eax
f010ab1e:	85 c0                	test   %eax,%eax
f010ab20:	74 11                	je     f010ab33 <dequeue+0x51>
f010ab22:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ab25:	8b 40 48             	mov    0x48(%eax),%eax
f010ab28:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ab2b:	8b 52 44             	mov    0x44(%edx),%edx
f010ab2e:	89 50 44             	mov    %edx,0x44(%eax)
f010ab31:	eb 0b                	jmp    f010ab3e <dequeue+0x5c>
f010ab33:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ab36:	8b 50 44             	mov    0x44(%eax),%edx
f010ab39:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab3c:	89 10                	mov    %edx,(%eax)
f010ab3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ab41:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
f010ab48:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ab4b:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
f010ab52:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab55:	8b 40 0c             	mov    0xc(%eax),%eax
f010ab58:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ab5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab5e:	89 50 0c             	mov    %edx,0xc(%eax)
	return envItem;
f010ab61:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f010ab64:	c9                   	leave  
f010ab65:	c3                   	ret    

f010ab66 <getShareNumber>:
#include <kern/shared_memory_manager.h>
#include <kern/memory_manager.h>
#include <kern/syscall.h>

int getShareNumber(char* name)
{
f010ab66:	55                   	push   %ebp
f010ab67:	89 e5                	mov    %esp,%ebp
f010ab69:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010ab6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(; i< nShares; ++i)
f010ab73:	eb 4a                	jmp    f010abbf <getShareNumber+0x59>
	{
		if(strcmp(name, shares[i].name)==0)
f010ab75:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ab78:	89 d0                	mov    %edx,%eax
f010ab7a:	01 c0                	add    %eax,%eax
f010ab7c:	01 d0                	add    %edx,%eax
f010ab7e:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010ab85:	01 c8                	add    %ecx,%eax
f010ab87:	c1 e0 02             	shl    $0x2,%eax
f010ab8a:	01 d0                	add    %edx,%eax
f010ab8c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ab93:	01 c8                	add    %ecx,%eax
f010ab95:	01 c0                	add    %eax,%eax
f010ab97:	01 d0                	add    %edx,%eax
f010ab99:	c1 e0 02             	shl    $0x2,%eax
f010ab9c:	05 00 53 45 f0       	add    $0xf0455300,%eax
f010aba1:	83 c0 04             	add    $0x4,%eax
f010aba4:	83 ec 08             	sub    $0x8,%esp
f010aba7:	50                   	push   %eax
f010aba8:	ff 75 08             	pushl  0x8(%ebp)
f010abab:	e8 0c 40 00 00       	call   f010ebbc <strcmp>
f010abb0:	83 c4 10             	add    $0x10,%esp
f010abb3:	85 c0                	test   %eax,%eax
f010abb5:	75 05                	jne    f010abbc <getShareNumber+0x56>
		{
			return i;
f010abb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abba:	eb 12                	jmp    f010abce <getShareNumber+0x68>
#include <kern/syscall.h>

int getShareNumber(char* name)
{
	int i=0;
	for(; i< nShares; ++i)
f010abbc:	ff 45 f4             	incl   -0xc(%ebp)
f010abbf:	a1 b0 fb 4b f0       	mov    0xf04bfbb0,%eax
f010abc4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010abc7:	7c ac                	jl     f010ab75 <getShareNumber+0xf>
		if(strcmp(name, shares[i].name)==0)
		{
			return i;
		}
	}
	return -1;
f010abc9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f010abce:	c9                   	leave  
f010abcf:	c3                   	ret    

f010abd0 <createSharedObject>:

int createSharedObject(char* shareName, uint32 size, uint8 isWritable, void** returned_shared_address)
{
f010abd0:	55                   	push   %ebp
f010abd1:	89 e5                	mov    %esp,%ebp
f010abd3:	83 ec 28             	sub    $0x28,%esp
f010abd6:	8b 45 10             	mov    0x10(%ebp),%eax
f010abd9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	// your code is here, remove the panic and write your code
	//panic("createSharedObject() is not implemented yet...!!");
	struct Env* myenv = curenv; //The calling environment
f010abdc:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010abe1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	5) Add the shared object to the end of the "shares" array (use "nShares"), remember to:
	//		a) Set the data members of the object with suitable values (name, size, ...)
	//		b) Set references to 1 (as there's 1 user environment that use the object now - OWNER)
	//		c) Store the object's isWritable flag (0:ReadOnly, 1:Writable) for later use by getSharedObject()
	// 	6) Return the start address of the object by setting the "*returned_shared_address"
	panic("This function is not required\n");
f010abe4:	83 ec 04             	sub    $0x4,%esp
f010abe7:	68 84 1f 11 f0       	push   $0xf0111f84
f010abec:	6a 32                	push   $0x32
f010abee:	68 a3 1f 11 f0       	push   $0xf0111fa3
f010abf3:	e8 64 55 ff ff       	call   f010015c <_panic>

f010abf8 <getSharedObject>:
	return 0;
}

int getSharedObject(char* shareName, void** returned_shared_address)
{
f010abf8:	55                   	push   %ebp
f010abf9:	89 e5                	mov    %esp,%ebp
f010abfb:	83 ec 18             	sub    $0x18,%esp
	// your code is here, remove the panic and write your code
	//panic("getSharedObject() is not implemented yet...!!");

	struct Env* myenv = curenv; //The calling environment
f010abfe:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010ac03:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	3) Share these frames with the current environment "curenv" starting from its "shared_free_address"
	//  4) make sure that read-only object must be shared "read only", use the flag isWritable to make it either read-only or writable
	//	5) Update the "shared_free_address" of the current environment to be aligned on a PAGE boundary
	//	6) Update references
	// 	7) Return the start address of the shared object by setting the "*returned_shared_address"
	panic("This function is not required\n");
f010ac06:	83 ec 04             	sub    $0x4,%esp
f010ac09:	68 84 1f 11 f0       	push   $0xf0111f84
f010ac0e:	6a 4e                	push   $0x4e
f010ac10:	68 a3 1f 11 f0       	push   $0xf0111fa3
f010ac15:	e8 42 55 ff ff       	call   f010015c <_panic>

f010ac1a <freeSharedObject>:

//========================== BONUS ============================
// Free Shared Object

int freeSharedObject(char* shareName)
{
f010ac1a:	55                   	push   %ebp
f010ac1b:	89 e5                	mov    %esp,%ebp
f010ac1d:	83 ec 18             	sub    $0x18,%esp
	struct Env* myenv = curenv; //The calling environment
f010ac20:	a1 38 a1 42 f0       	mov    0xf042a138,%eax
f010ac25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	4) Update references
	//	5) If this is the last share:
	//		a) clear the frames_storage of this shared object (use: clear_frames_storage())
	//		b) clear all other data members of this object (name, size, ...)
	//	6) Flush the cache "tlbflush()"
	panic("This function is not required\n");
f010ac28:	83 ec 04             	sub    $0x4,%esp
f010ac2b:	68 84 1f 11 f0       	push   $0xf0111f84
f010ac30:	6a 6c                	push   $0x6c
f010ac32:	68 a3 1f 11 f0       	push   $0xf0111fa3
f010ac37:	e8 20 55 ff ff       	call   f010015c <_panic>

f010ac3c <to_frame_number>:
struct Frame_Info *get_frame_info(uint32 *ptr_page_directory, void *virtual_address, uint32 **ptr_page_table);
void decrement_references(struct Frame_Info* ptr_frame_info);
void initialize_frame_info(struct Frame_Info *ptr_frame_info);

static inline uint32 to_frame_number(struct Frame_Info *ptr_frame_info)
{
f010ac3c:	55                   	push   %ebp
f010ac3d:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010ac3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac42:	8b 15 84 52 45 f0    	mov    0xf0455284,%edx
f010ac48:	29 d0                	sub    %edx,%eax
f010ac4a:	c1 f8 03             	sar    $0x3,%eax
f010ac4d:	89 c2                	mov    %eax,%edx
f010ac4f:	89 d0                	mov    %edx,%eax
f010ac51:	c1 e0 02             	shl    $0x2,%eax
f010ac54:	01 d0                	add    %edx,%eax
f010ac56:	c1 e0 02             	shl    $0x2,%eax
f010ac59:	01 d0                	add    %edx,%eax
f010ac5b:	c1 e0 02             	shl    $0x2,%eax
f010ac5e:	01 d0                	add    %edx,%eax
f010ac60:	89 c1                	mov    %eax,%ecx
f010ac62:	c1 e1 08             	shl    $0x8,%ecx
f010ac65:	01 c8                	add    %ecx,%eax
f010ac67:	89 c1                	mov    %eax,%ecx
f010ac69:	c1 e1 10             	shl    $0x10,%ecx
f010ac6c:	01 c8                	add    %ecx,%eax
f010ac6e:	01 c0                	add    %eax,%eax
f010ac70:	01 d0                	add    %edx,%eax
}
f010ac72:	5d                   	pop    %ebp
f010ac73:	c3                   	ret    

f010ac74 <to_physical_address>:

static inline uint32 to_physical_address(struct Frame_Info *ptr_frame_info)
{
f010ac74:	55                   	push   %ebp
f010ac75:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010ac77:	ff 75 08             	pushl  0x8(%ebp)
f010ac7a:	e8 bd ff ff ff       	call   f010ac3c <to_frame_number>
f010ac7f:	83 c4 04             	add    $0x4,%esp
f010ac82:	c1 e0 0c             	shl    $0xc,%eax
}
f010ac85:	c9                   	leave  
f010ac86:	c3                   	ret    

f010ac87 <to_frame_info>:

static inline struct Frame_Info* to_frame_info(uint32 physical_address)
{
f010ac87:	55                   	push   %ebp
f010ac88:	89 e5                	mov    %esp,%ebp
f010ac8a:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f010ac8d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac90:	c1 e8 0c             	shr    $0xc,%eax
f010ac93:	89 c2                	mov    %eax,%edx
f010ac95:	a1 28 2a 45 f0       	mov    0xf0452a28,%eax
f010ac9a:	39 c2                	cmp    %eax,%edx
f010ac9c:	72 14                	jb     f010acb2 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010ac9e:	83 ec 04             	sub    $0x4,%esp
f010aca1:	68 c0 1f 11 f0       	push   $0xf0111fc0
f010aca6:	6a 60                	push   $0x60
f010aca8:	68 e5 1f 11 f0       	push   $0xf0111fe5
f010acad:	e8 aa 54 ff ff       	call   f010015c <_panic>
	return &frames_info[PPN(physical_address)];
f010acb2:	8b 15 84 52 45 f0    	mov    0xf0455284,%edx
f010acb8:	8b 45 08             	mov    0x8(%ebp),%eax
f010acbb:	c1 e8 0c             	shr    $0xc,%eax
f010acbe:	89 c1                	mov    %eax,%ecx
f010acc0:	89 c8                	mov    %ecx,%eax
f010acc2:	01 c0                	add    %eax,%eax
f010acc4:	01 c8                	add    %ecx,%eax
f010acc6:	c1 e0 03             	shl    $0x3,%eax
f010acc9:	01 d0                	add    %edx,%eax
}
f010accb:	c9                   	leave  
f010accc:	c3                   	ret    

f010accd <alloc_kmem>:
int sz_kmem[max_sz] = { 0 };
int check = 0;

//func to allocate in kernal
void alloc_kmem(uint32 size,uint32 vir)
{
f010accd:	55                   	push   %ebp
f010acce:	89 e5                	mov    %esp,%ebp
f010acd0:	83 ec 18             	sub    $0x18,%esp

	int i=0;
f010acd3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<size;i+=PAGE_SIZE)
f010acda:	eb 3e                	jmp    f010ad1a <alloc_kmem+0x4d>
	{
		struct Frame_Info* ptr_frame_info;
		 allocate_frame(&ptr_frame_info);
f010acdc:	83 ec 0c             	sub    $0xc,%esp
f010acdf:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010ace2:	50                   	push   %eax
f010ace3:	e8 b0 7e ff ff       	call   f0102b98 <allocate_frame>
f010ace8:	83 c4 10             	add    $0x10,%esp
		map_frame(ptr_page_directory, ptr_frame_info,
f010aceb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010acee:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010acf1:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010acf6:	6a 02                	push   $0x2
f010acf8:	51                   	push   %ecx
f010acf9:	52                   	push   %edx
f010acfa:	50                   	push   %eax
f010acfb:	e8 9b 82 ff ff       	call   f0102f9b <map_frame>
f010ad00:	83 c4 10             	add    $0x10,%esp
						(int *) vir, PERM_WRITEABLE & (~PERM_USED));
				ptr_frame_info->va = vir;
f010ad03:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ad06:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad09:	89 50 0c             	mov    %edx,0xc(%eax)
				vir +=(unsigned int) PAGE_SIZE;
f010ad0c:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
//func to allocate in kernal
void alloc_kmem(uint32 size,uint32 vir)
{

	int i=0;
	for(;i<size;i+=PAGE_SIZE)
f010ad13:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010ad1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad1d:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ad20:	72 ba                	jb     f010acdc <alloc_kmem+0xf>
						(int *) vir, PERM_WRITEABLE & (~PERM_USED));
				ptr_frame_info->va = vir;
				vir +=(unsigned int) PAGE_SIZE;
	}

}
f010ad22:	90                   	nop
f010ad23:	c9                   	leave  
f010ad24:	c3                   	ret    

f010ad25 <kmalloc>:


void* kmalloc(unsigned int size)
{//TODO: [PROJECT 2016 - Kernel Dynamic Allocation/Deallocation] kmalloc()
f010ad25:	55                   	push   %ebp
f010ad26:	89 e5                	mov    %esp,%ebp
f010ad28:	83 ec 48             	sub    $0x48,%esp

	//NOTE: Allocation is continuous increasing virtual address
	//NOTE: All kernel heap allocations are multiples of PAGE_SIZE (4KB)
	//refer to the project documentation for the detailed steps

	size = ROUNDUP(size, PAGE_SIZE);
f010ad2b:	c7 45 c8 00 10 00 00 	movl   $0x1000,-0x38(%ebp)
f010ad32:	8b 55 08             	mov    0x8(%ebp),%edx
f010ad35:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010ad38:	01 d0                	add    %edx,%eax
f010ad3a:	48                   	dec    %eax
f010ad3b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010ad3e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ad41:	ba 00 00 00 00       	mov    $0x0,%edx
f010ad46:	f7 75 c8             	divl   -0x38(%ebp)
f010ad49:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ad4c:	29 d0                	sub    %edx,%eax
f010ad4e:	89 45 08             	mov    %eax,0x8(%ebp)

	if (size == 0 || size > (KERNEL_HEAP_MAX - KERNEL_HEAP_START)||(size >((unsigned int)KERNEL_HEAP_MAX - firstFreeVAInKHeap)&&!check)) {
f010ad51:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ad55:	74 25                	je     f010ad7c <kmalloc+0x57>
f010ad57:	81 7d 08 00 f0 ff 09 	cmpl   $0x9fff000,0x8(%ebp)
f010ad5e:	77 1c                	ja     f010ad7c <kmalloc+0x57>
f010ad60:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010ad65:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
f010ad6a:	29 c2                	sub    %eax,%edx
f010ad6c:	89 d0                	mov    %edx,%eax
f010ad6e:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ad71:	73 13                	jae    f010ad86 <kmalloc+0x61>
f010ad73:	a1 1c 2a 45 f0       	mov    0xf0452a1c,%eax
f010ad78:	85 c0                	test   %eax,%eax
f010ad7a:	75 0a                	jne    f010ad86 <kmalloc+0x61>
		return NULL;
f010ad7c:	b8 00 00 00 00       	mov    $0x0,%eax
f010ad81:	e9 16 03 00 00       	jmp    f010b09c <kmalloc+0x377>
	}



	// first we can allocate by " Strategy Continues "
	if (firstFreeVAInKHeap + size <= (uint32) KERNEL_HEAP_MAX && !check) {
f010ad86:	8b 15 70 a9 13 f0    	mov    0xf013a970,%edx
f010ad8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad8f:	01 d0                	add    %edx,%eax
f010ad91:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f010ad96:	0f 87 9c 00 00 00    	ja     f010ae38 <kmalloc+0x113>
f010ad9c:	a1 1c 2a 45 f0       	mov    0xf0452a1c,%eax
f010ada1:	85 c0                	test   %eax,%eax
f010ada3:	0f 85 8f 00 00 00    	jne    f010ae38 <kmalloc+0x113>

		void* ret = (void *) firstFreeVAInKHeap;
f010ada9:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010adae:	89 45 c0             	mov    %eax,-0x40(%ebp)
		all_kmem[cnt].size_vi = size;
f010adb1:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010adb6:	8b 55 08             	mov    0x8(%ebp),%edx
f010adb9:	89 14 c5 c0 67 4c f0 	mov    %edx,-0xfb39840(,%eax,8)
		all_kmem[cnt].vi = (void*) firstFreeVAInKHeap;
f010adc0:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010adc5:	8b 15 70 a9 13 f0    	mov    0xf013a970,%edx
f010adcb:	89 14 c5 c4 67 4c f0 	mov    %edx,-0xfb3983c(,%eax,8)
		cnt++;
f010add2:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010add7:	40                   	inc    %eax
f010add8:	a3 00 aa 42 f0       	mov    %eax,0xf042aa00

		alloc_kmem(size, firstFreeVAInKHeap);
f010addd:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010ade2:	83 ec 08             	sub    $0x8,%esp
f010ade5:	50                   	push   %eax
f010ade6:	ff 75 08             	pushl  0x8(%ebp)
f010ade9:	e8 df fe ff ff       	call   f010accd <alloc_kmem>
f010adee:	83 c4 10             	add    $0x10,%esp

		int i = 0;
f010adf1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		// init my array with 1 to make sure this frame is busy
		for (; i < size; i += PAGE_SIZE)
f010adf8:	eb 2e                	jmp    f010ae28 <kmalloc+0x103>
		{

			sz_kmem[(int) ((firstFreeVAInKHeap - (uint32) KERNEL_HEAP_START)
f010adfa:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010adff:	05 00 00 00 0a       	add    $0xa000000,%eax
					/ (uint32) PAGE_SIZE)] = 1;
f010ae04:	c1 e8 0c             	shr    $0xc,%eax
f010ae07:	c7 04 85 20 aa 42 f0 	movl   $0x1,-0xfbd55e0(,%eax,4)
f010ae0e:	01 00 00 00 

			firstFreeVAInKHeap += (uint32) PAGE_SIZE;
f010ae12:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010ae17:	05 00 10 00 00       	add    $0x1000,%eax
f010ae1c:	a3 70 a9 13 f0       	mov    %eax,0xf013a970
		alloc_kmem(size, firstFreeVAInKHeap);

		int i = 0;

		// init my array with 1 to make sure this frame is busy
		for (; i < size; i += PAGE_SIZE)
f010ae21:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010ae28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae2b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ae2e:	72 ca                	jb     f010adfa <kmalloc+0xd5>
					/ (uint32) PAGE_SIZE)] = 1;

			firstFreeVAInKHeap += (uint32) PAGE_SIZE;
		}

		return ret;
f010ae30:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010ae33:	e9 64 02 00 00       	jmp    f010b09c <kmalloc+0x377>
	} else {


	   // second we can allocate by " Strategy NEXTFIT "

		void* temp_end = NULL;
f010ae38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

		int check_start = 0;
f010ae3f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		// check first that we used " Strategy Continues " before and not do it again and turn to NEXTFIT
		if (!check) {
f010ae46:	a1 1c 2a 45 f0       	mov    0xf0452a1c,%eax
f010ae4b:	85 c0                	test   %eax,%eax
f010ae4d:	75 1d                	jne    f010ae6c <kmalloc+0x147>
			firstFreeVAInKHeap = (uint32) KERNEL_HEAP_START;
f010ae4f:	c7 05 70 a9 13 f0 00 	movl   $0xf6000000,0xf013a970
f010ae56:	00 00 f6 
			check = 1;
f010ae59:	c7 05 1c 2a 45 f0 01 	movl   $0x1,0xf0452a1c
f010ae60:	00 00 00 
			check_start = 1; // to dont use second loop CZ firstFreeVAInKHeap start from USER_HEAP_START
f010ae63:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
f010ae6a:	eb 08                	jmp    f010ae74 <kmalloc+0x14f>
		} else {
			temp_end = (void*) firstFreeVAInKHeap;
f010ae6c:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010ae71:	89 45 f0             	mov    %eax,-0x10(%ebp)

		}

		uint32 sz = 0;
f010ae74:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		int f = 0;
f010ae7b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		uint32 ptr = firstFreeVAInKHeap;
f010ae82:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010ae87:	89 45 e0             	mov    %eax,-0x20(%ebp)
		// check if there are enough size in memory to allocate there
		while (ptr < (uint32) KERNEL_HEAP_MAX) {
f010ae8a:	eb 4d                	jmp    f010aed9 <kmalloc+0x1b4>
			if (sz == size) {
f010ae8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ae8f:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ae92:	75 09                	jne    f010ae9d <kmalloc+0x178>
				f = 1;
f010ae94:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				break;
f010ae9b:	eb 45                	jmp    f010aee2 <kmalloc+0x1bd>
			}
			if (sz_kmem[(int) ((ptr - (uint32) KERNEL_HEAP_START)
f010ae9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010aea0:	05 00 00 00 0a       	add    $0xa000000,%eax
					/ (uint32) PAGE_SIZE)] == 0) {
f010aea5:	c1 e8 0c             	shr    $0xc,%eax
		while (ptr < (uint32) KERNEL_HEAP_MAX) {
			if (sz == size) {
				f = 1;
				break;
			}
			if (sz_kmem[(int) ((ptr - (uint32) KERNEL_HEAP_START)
f010aea8:	8b 04 85 20 aa 42 f0 	mov    -0xfbd55e0(,%eax,4),%eax
f010aeaf:	85 c0                	test   %eax,%eax
f010aeb1:	75 10                	jne    f010aec3 <kmalloc+0x19e>
					/ (uint32) PAGE_SIZE)] == 0) {

				sz += PAGE_SIZE;
f010aeb3:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
				ptr += PAGE_SIZE;
f010aeba:	81 45 e0 00 10 00 00 	addl   $0x1000,-0x20(%ebp)
f010aec1:	eb 16                	jmp    f010aed9 <kmalloc+0x1b4>
			} else {
				sz = 0;
f010aec3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				ptr += PAGE_SIZE;
f010aeca:	81 45 e0 00 10 00 00 	addl   $0x1000,-0x20(%ebp)
				firstFreeVAInKHeap = ptr;
f010aed1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010aed4:	a3 70 a9 13 f0       	mov    %eax,0xf013a970

		uint32 sz = 0;
		int f = 0;
		uint32 ptr = firstFreeVAInKHeap;
		// check if there are enough size in memory to allocate there
		while (ptr < (uint32) KERNEL_HEAP_MAX) {
f010aed9:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f010aee0:	76 aa                	jbe    f010ae8c <kmalloc+0x167>
				firstFreeVAInKHeap = ptr;
			}

		}

		if (f) {
f010aee2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010aee6:	0f 84 8f 00 00 00    	je     f010af7b <kmalloc+0x256>

			void* ret = (void *) firstFreeVAInKHeap;
f010aeec:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010aef1:	89 45 bc             	mov    %eax,-0x44(%ebp)
			all_kmem[cnt].size_vi = size;
f010aef4:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010aef9:	8b 55 08             	mov    0x8(%ebp),%edx
f010aefc:	89 14 c5 c0 67 4c f0 	mov    %edx,-0xfb39840(,%eax,8)
			all_kmem[cnt].vi = (void*) firstFreeVAInKHeap;
f010af03:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010af08:	8b 15 70 a9 13 f0    	mov    0xf013a970,%edx
f010af0e:	89 14 c5 c4 67 4c f0 	mov    %edx,-0xfb3983c(,%eax,8)
			cnt++;
f010af15:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010af1a:	40                   	inc    %eax
f010af1b:	a3 00 aa 42 f0       	mov    %eax,0xf042aa00

			alloc_kmem(size, firstFreeVAInKHeap);
f010af20:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010af25:	83 ec 08             	sub    $0x8,%esp
f010af28:	50                   	push   %eax
f010af29:	ff 75 08             	pushl  0x8(%ebp)
f010af2c:	e8 9c fd ff ff       	call   f010accd <alloc_kmem>
f010af31:	83 c4 10             	add    $0x10,%esp

			int i = 0;
f010af34:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			// init my array with 1 to make sure this frame is busy
			for (; i < size; i += PAGE_SIZE)
f010af3b:	eb 2e                	jmp    f010af6b <kmalloc+0x246>
			{

				sz_kmem[(int) ((firstFreeVAInKHeap - (uint32) KERNEL_HEAP_START)
f010af3d:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010af42:	05 00 00 00 0a       	add    $0xa000000,%eax
						/ (uint32) PAGE_SIZE)] = 1;
f010af47:	c1 e8 0c             	shr    $0xc,%eax
f010af4a:	c7 04 85 20 aa 42 f0 	movl   $0x1,-0xfbd55e0(,%eax,4)
f010af51:	01 00 00 00 

				firstFreeVAInKHeap += (uint32) PAGE_SIZE;
f010af55:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010af5a:	05 00 10 00 00       	add    $0x1000,%eax
f010af5f:	a3 70 a9 13 f0       	mov    %eax,0xf013a970

			alloc_kmem(size, firstFreeVAInKHeap);

			int i = 0;
			// init my array with 1 to make sure this frame is busy
			for (; i < size; i += PAGE_SIZE)
f010af64:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010af6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010af6e:	3b 45 08             	cmp    0x8(%ebp),%eax
f010af71:	72 ca                	jb     f010af3d <kmalloc+0x218>
						/ (uint32) PAGE_SIZE)] = 1;

				firstFreeVAInKHeap += (uint32) PAGE_SIZE;
			}

			return ret;
f010af73:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010af76:	e9 21 01 00 00       	jmp    f010b09c <kmalloc+0x377>

		} else {

			if (check_start) {
f010af7b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010af7f:	74 0a                	je     f010af8b <kmalloc+0x266>

				return NULL;
f010af81:	b8 00 00 00 00       	mov    $0x0,%eax
f010af86:	e9 11 01 00 00       	jmp    f010b09c <kmalloc+0x377>
			}

			/////////////back loop////////////////

			uint32 sz = 0;
f010af8b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
			int f = 0;
f010af92:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			uint32 ptr = KERNEL_HEAP_START;
f010af99:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
			firstFreeVAInKHeap = KERNEL_HEAP_START;
f010afa0:	c7 05 70 a9 13 f0 00 	movl   $0xf6000000,0xf013a970
f010afa7:	00 00 f6 
			while (ptr < (uint32) temp_end) {
f010afaa:	eb 4d                	jmp    f010aff9 <kmalloc+0x2d4>
				if (sz == size) {
f010afac:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010afaf:	3b 45 08             	cmp    0x8(%ebp),%eax
f010afb2:	75 09                	jne    f010afbd <kmalloc+0x298>
					f = 1;
f010afb4:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f010afbb:	eb 44                	jmp    f010b001 <kmalloc+0x2dc>
				}
				if (sz_kmem[(int) ((ptr - (uint32) KERNEL_HEAP_START)
f010afbd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010afc0:	05 00 00 00 0a       	add    $0xa000000,%eax
						/ (uint32) PAGE_SIZE)] == 0) {
f010afc5:	c1 e8 0c             	shr    $0xc,%eax
			while (ptr < (uint32) temp_end) {
				if (sz == size) {
					f = 1;
					break;
				}
				if (sz_kmem[(int) ((ptr - (uint32) KERNEL_HEAP_START)
f010afc8:	8b 04 85 20 aa 42 f0 	mov    -0xfbd55e0(,%eax,4),%eax
f010afcf:	85 c0                	test   %eax,%eax
f010afd1:	75 10                	jne    f010afe3 <kmalloc+0x2be>
						/ (uint32) PAGE_SIZE)] == 0) {

					sz += PAGE_SIZE;
f010afd3:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
					ptr += PAGE_SIZE;
f010afda:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
f010afe1:	eb 16                	jmp    f010aff9 <kmalloc+0x2d4>
				} else {
					sz = 0;
f010afe3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
					ptr += PAGE_SIZE;
f010afea:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
					firstFreeVAInKHeap = ptr;
f010aff1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010aff4:	a3 70 a9 13 f0       	mov    %eax,0xf013a970

			uint32 sz = 0;
			int f = 0;
			uint32 ptr = KERNEL_HEAP_START;
			firstFreeVAInKHeap = KERNEL_HEAP_START;
			while (ptr < (uint32) temp_end) {
f010aff9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010affc:	39 45 d0             	cmp    %eax,-0x30(%ebp)
f010afff:	72 ab                	jb     f010afac <kmalloc+0x287>
					firstFreeVAInKHeap = ptr;
				}

			}

			if (f) {
f010b001:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b005:	0f 84 8c 00 00 00    	je     f010b097 <kmalloc+0x372>

				void* ret = (void *) firstFreeVAInKHeap;
f010b00b:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010b010:	89 45 b8             	mov    %eax,-0x48(%ebp)
				all_kmem[cnt].size_vi = size;
f010b013:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010b018:	8b 55 08             	mov    0x8(%ebp),%edx
f010b01b:	89 14 c5 c0 67 4c f0 	mov    %edx,-0xfb39840(,%eax,8)
				all_kmem[cnt].vi = (void*) firstFreeVAInKHeap;
f010b022:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010b027:	8b 15 70 a9 13 f0    	mov    0xf013a970,%edx
f010b02d:	89 14 c5 c4 67 4c f0 	mov    %edx,-0xfb3983c(,%eax,8)
				cnt++;
f010b034:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010b039:	40                   	inc    %eax
f010b03a:	a3 00 aa 42 f0       	mov    %eax,0xf042aa00

				alloc_kmem(size, firstFreeVAInKHeap);
f010b03f:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010b044:	83 ec 08             	sub    $0x8,%esp
f010b047:	50                   	push   %eax
f010b048:	ff 75 08             	pushl  0x8(%ebp)
f010b04b:	e8 7d fc ff ff       	call   f010accd <alloc_kmem>
f010b050:	83 c4 10             	add    $0x10,%esp

				int i = 0;
f010b053:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)

				for (; i < size; i += PAGE_SIZE)
f010b05a:	eb 2e                	jmp    f010b08a <kmalloc+0x365>
				{

					sz_kmem[(int) ((firstFreeVAInKHeap
							- (uint32) KERNEL_HEAP_START) / (uint32) PAGE_SIZE)] =
f010b05c:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010b061:	05 00 00 00 0a       	add    $0xa000000,%eax
f010b066:	c1 e8 0c             	shr    $0xc,%eax
f010b069:	c7 04 85 20 aa 42 f0 	movl   $0x1,-0xfbd55e0(,%eax,4)
f010b070:	01 00 00 00 
							1;

					firstFreeVAInKHeap += (uint32) PAGE_SIZE;
f010b074:	a1 70 a9 13 f0       	mov    0xf013a970,%eax
f010b079:	05 00 10 00 00       	add    $0x1000,%eax
f010b07e:	a3 70 a9 13 f0       	mov    %eax,0xf013a970

				alloc_kmem(size, firstFreeVAInKHeap);

				int i = 0;

				for (; i < size; i += PAGE_SIZE)
f010b083:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010b08a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b08d:	3b 45 08             	cmp    0x8(%ebp),%eax
f010b090:	72 ca                	jb     f010b05c <kmalloc+0x337>
							1;

					firstFreeVAInKHeap += (uint32) PAGE_SIZE;
				}

				return ret;
f010b092:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b095:	eb 05                	jmp    f010b09c <kmalloc+0x377>

			} else {

				return NULL;
f010b097:	b8 00 00 00 00       	mov    $0x0,%eax

		}

	}

}
f010b09c:	c9                   	leave  
f010b09d:	c3                   	ret    

f010b09e <kfree>:

void kfree(void* virtual_address)
{//TODO: [PROJECT 2016 - Kernel Dynamic Allocation/Deallocation] kfree()
f010b09e:	55                   	push   %ebp
f010b09f:	89 e5                	mov    %esp,%ebp
f010b0a1:	83 ec 18             	sub    $0x18,%esp
	//refer to the project documentation for the detailed steps


	//virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
	int i;
	for (i=0; i <cnt; i++) {
f010b0a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b0ab:	e9 e3 00 00 00       	jmp    f010b193 <kfree+0xf5>

		if (all_kmem[i].vi == virtual_address) {
f010b0b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b0b3:	8b 04 c5 c4 67 4c f0 	mov    -0xfb3983c(,%eax,8),%eax
f010b0ba:	3b 45 08             	cmp    0x8(%ebp),%eax
f010b0bd:	0f 85 cd 00 00 00    	jne    f010b190 <kfree+0xf2>

			if (all_kmem[i].size_vi == 0) {
f010b0c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b0c6:	8b 04 c5 c0 67 4c f0 	mov    -0xfb39840(,%eax,8),%eax
f010b0cd:	85 c0                	test   %eax,%eax
f010b0cf:	75 21                	jne    f010b0f2 <kfree+0x54>
				all_kmem[i].size_vi = 0;
f010b0d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b0d4:	c7 04 c5 c0 67 4c f0 	movl   $0x0,-0xfb39840(,%eax,8)
f010b0db:	00 00 00 00 
				all_kmem[i].vi = NULL;
f010b0df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b0e2:	c7 04 c5 c4 67 4c f0 	movl   $0x0,-0xfb3983c(,%eax,8)
f010b0e9:	00 00 00 00 
				return;
f010b0ed:	e9 af 00 00 00       	jmp    f010b1a1 <kfree+0x103>
			}

			//virtual_address=all_kmem[i].vi;
			uint32 va = (uint32) virtual_address;
f010b0f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
			int j;
			for (j=0; j < all_kmem[i].size_vi; j += PAGE_SIZE) {
f010b0f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010b0ff:	eb 22                	jmp    f010b123 <kfree+0x85>

				unmap_frame(ptr_page_directory, virtual_address);
f010b101:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010b106:	83 ec 08             	sub    $0x8,%esp
f010b109:	ff 75 08             	pushl  0x8(%ebp)
f010b10c:	50                   	push   %eax
f010b10d:	e8 b8 7f ff ff       	call   f01030ca <unmap_frame>
f010b112:	83 c4 10             	add    $0x10,%esp

				virtual_address += PAGE_SIZE;
f010b115:	81 45 08 00 10 00 00 	addl   $0x1000,0x8(%ebp)
			}

			//virtual_address=all_kmem[i].vi;
			uint32 va = (uint32) virtual_address;
			int j;
			for (j=0; j < all_kmem[i].size_vi; j += PAGE_SIZE) {
f010b11c:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f010b123:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b126:	8b 14 c5 c0 67 4c f0 	mov    -0xfb39840(,%eax,8),%edx
f010b12d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b130:	39 c2                	cmp    %eax,%edx
f010b132:	77 cd                	ja     f010b101 <kfree+0x63>
				virtual_address += PAGE_SIZE;
				//tlbflush();
			}


			int k = 0;
f010b134:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
			// init my array with 0 to make sure this frame is free for me
			for (; k <all_kmem[i].size_vi; k += PAGE_SIZE)
f010b13b:	eb 24                	jmp    f010b161 <kfree+0xc3>
			{
				sz_kmem[(int) ((va - (uint32) KERNEL_HEAP_START)
f010b13d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b140:	05 00 00 00 0a       	add    $0xa000000,%eax
						/ (uint32) PAGE_SIZE)] = 0;
f010b145:	c1 e8 0c             	shr    $0xc,%eax
f010b148:	c7 04 85 20 aa 42 f0 	movl   $0x0,-0xfbd55e0(,%eax,4)
f010b14f:	00 00 00 00 

				va += (uint32) PAGE_SIZE;
f010b153:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
			}


			int k = 0;
			// init my array with 0 to make sure this frame is free for me
			for (; k <all_kmem[i].size_vi; k += PAGE_SIZE)
f010b15a:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
f010b161:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b164:	8b 14 c5 c0 67 4c f0 	mov    -0xfb39840(,%eax,8),%edx
f010b16b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b16e:	39 c2                	cmp    %eax,%edx
f010b170:	77 cb                	ja     f010b13d <kfree+0x9f>
						/ (uint32) PAGE_SIZE)] = 0;

				va += (uint32) PAGE_SIZE;
			}

			all_kmem[i].vi=NULL;
f010b172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b175:	c7 04 c5 c4 67 4c f0 	movl   $0x0,-0xfb3983c(,%eax,8)
f010b17c:	00 00 00 00 
			all_kmem[i].size_vi=0;
f010b180:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b183:	c7 04 c5 c0 67 4c f0 	movl   $0x0,-0xfb39840(,%eax,8)
f010b18a:	00 00 00 00 
			return;
f010b18e:	eb 11                	jmp    f010b1a1 <kfree+0x103>
	//refer to the project documentation for the detailed steps


	//virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
	int i;
	for (i=0; i <cnt; i++) {
f010b190:	ff 45 f4             	incl   -0xc(%ebp)
f010b193:	a1 00 aa 42 f0       	mov    0xf042aa00,%eax
f010b198:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010b19b:	0f 8c 0f ff ff ff    	jl     f010b0b0 <kfree+0x12>

	//TODO: [PROJECT 2016 - BONUS1] Implement a Kernel allocation strategy
	// Instead of the continuous allocation/deallocation, implement one of
	// the strategies NEXT FIT, BEST FIT, .. etc

}
f010b1a1:	c9                   	leave  
f010b1a2:	c3                   	ret    

f010b1a3 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{//TODO: [PROJECT 2016 - Kernel Dynamic Allocation/Deallocation] kheap_virtual_address()
f010b1a3:	55                   	push   %ebp
f010b1a4:	89 e5                	mov    %esp,%ebp
f010b1a6:	83 ec 18             	sub    $0x18,%esp
	//return the virtual address corresponding to given physical_address
	//refer to the project documentation for the detailed steps


	struct Frame_Info* ptr_fram_info;
	ptr_fram_info=to_frame_info(physical_address);
f010b1a9:	83 ec 0c             	sub    $0xc,%esp
f010b1ac:	ff 75 08             	pushl  0x8(%ebp)
f010b1af:	e8 d3 fa ff ff       	call   f010ac87 <to_frame_info>
f010b1b4:	83 c4 10             	add    $0x10,%esp
f010b1b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ptr_fram_info->va;
f010b1ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1bd:	8b 40 0c             	mov    0xc(%eax),%eax



	//change this "return" according to your answer
	//return 0;
}
f010b1c0:	c9                   	leave  
f010b1c1:	c3                   	ret    

f010b1c2 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f010b1c2:	55                   	push   %ebp
f010b1c3:	89 e5                	mov    %esp,%ebp
f010b1c5:	83 ec 18             	sub    $0x18,%esp

		//return the physical address corresponding to given virtual_address
		//refer to the project documentation for the detailed steps
	//////////////

		uint32 *ptr_table = NULL;
f010b1c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		struct Frame_Info* ptr_frame_info = get_frame_info(ptr_page_directory, (void*)virtual_address, &ptr_table);
f010b1cf:	8b 55 08             	mov    0x8(%ebp),%edx
f010b1d2:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010b1d7:	83 ec 04             	sub    $0x4,%esp
f010b1da:	8d 4d ec             	lea    -0x14(%ebp),%ecx
f010b1dd:	51                   	push   %ecx
f010b1de:	52                   	push   %edx
f010b1df:	50                   	push   %eax
f010b1e0:	e8 75 7e ff ff       	call   f010305a <get_frame_info>
f010b1e5:	83 c4 10             	add    $0x10,%esp
f010b1e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(ptr_frame_info==NULL)
f010b1eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b1ef:	75 07                	jne    f010b1f8 <kheap_physical_address+0x36>
			return 0;
f010b1f1:	b8 00 00 00 00       	mov    $0x0,%eax
f010b1f6:	eb 14                	jmp    f010b20c <kheap_physical_address+0x4a>
		uint32 physical_address = to_physical_address(ptr_frame_info);
f010b1f8:	83 ec 0c             	sub    $0xc,%esp
f010b1fb:	ff 75 f4             	pushl  -0xc(%ebp)
f010b1fe:	e8 71 fa ff ff       	call   f010ac74 <to_physical_address>
f010b203:	83 c4 10             	add    $0x10,%esp
f010b206:	89 45 f0             	mov    %eax,-0x10(%ebp)

		return physical_address;
f010b209:	8b 45 f0             	mov    -0x10(%ebp),%eax
		//change this "return" according to your answer


	}
f010b20c:	c9                   	leave  
f010b20d:	c3                   	ret    

f010b20e <test_kmalloc>:
	int c;
};


int test_kmalloc()
{
f010b20e:	55                   	push   %ebp
f010b20f:	89 e5                	mov    %esp,%ebp
f010b211:	57                   	push   %edi
f010b212:	53                   	push   %ebx
f010b213:	81 ec c0 00 00 00    	sub    $0xc0,%esp
	char minByte = 1<<7;
f010b219:	c6 45 f3 80          	movb   $0x80,-0xd(%ebp)
	char maxByte = 0x7F;
f010b21d:	c6 45 f2 7f          	movb   $0x7f,-0xe(%ebp)
	short minShort = 1<<15 ;
f010b221:	66 c7 45 f0 00 80    	movw   $0x8000,-0x10(%ebp)
	short maxShort = 0x7FFF;
f010b227:	66 c7 45 ee ff 7f    	movw   $0x7fff,-0x12(%ebp)
	int minInt = 1<<31 ;
f010b22d:	c7 45 e8 00 00 00 80 	movl   $0x80000000,-0x18(%ebp)
	int maxInt = 0x7FFFFFFF;
f010b234:	c7 45 e4 ff ff ff 7f 	movl   $0x7fffffff,-0x1c(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f010b23b:	e8 91 de ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b240:	89 45 e0             	mov    %eax,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f010b243:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
f010b249:	b9 14 00 00 00       	mov    $0x14,%ecx
f010b24e:	b8 00 00 00 00       	mov    $0x0,%eax
f010b253:	89 d7                	mov    %edx,%edi
f010b255:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//Insufficient space
		int freeFrames = sys_calculate_free_frames() ;
f010b257:	e8 75 de ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b25c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f010b25f:	e8 b9 f4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b264:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32 sizeOfKHeap = (KERNEL_HEAP_MAX - KERNEL_HEAP_START + 1) ;
f010b267:	c7 45 d4 01 f0 ff 09 	movl   $0x9fff001,-0x2c(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f010b26e:	83 ec 0c             	sub    $0xc,%esp
f010b271:	ff 75 d4             	pushl  -0x2c(%ebp)
f010b274:	e8 ac fa ff ff       	call   f010ad25 <kmalloc>
f010b279:	83 c4 10             	add    $0x10,%esp
f010b27c:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if (ptr_allocations[0] != NULL) panic("Allocating insufficient space: should return NULL");
f010b282:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f010b288:	85 c0                	test   %eax,%eax
f010b28a:	74 14                	je     f010b2a0 <test_kmalloc+0x92>
f010b28c:	83 ec 04             	sub    $0x4,%esp
f010b28f:	68 00 20 11 f0       	push   $0xf0112000
f010b294:	6a 32                	push   $0x32
f010b296:	68 32 20 11 f0       	push   $0xf0112032
f010b29b:	e8 bc 4e ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b2a0:	e8 78 f4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b2a5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b2a8:	74 14                	je     f010b2be <test_kmalloc+0xb0>
f010b2aa:	83 ec 04             	sub    $0x4,%esp
f010b2ad:	68 44 20 11 f0       	push   $0xf0112044
f010b2b2:	6a 33                	push   $0x33
f010b2b4:	68 32 20 11 f0       	push   $0xf0112032
f010b2b9:	e8 9e 4e ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b2be:	e8 0e de ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b2c3:	89 c2                	mov    %eax,%edx
f010b2c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b2c8:	39 c2                	cmp    %eax,%edx
f010b2ca:	74 14                	je     f010b2e0 <test_kmalloc+0xd2>
f010b2cc:	83 ec 04             	sub    $0x4,%esp
f010b2cf:	68 ac 20 11 f0       	push   $0xf01120ac
f010b2d4:	6a 34                	push   $0x34
f010b2d6:	68 32 20 11 f0       	push   $0xf0112032
f010b2db:	e8 7c 4e ff ff       	call   f010015c <_panic>

		cprintf("kmalloc: current evaluation = 10%");
f010b2e0:	83 ec 0c             	sub    $0xc,%esp
f010b2e3:	68 ec 20 11 f0       	push   $0xf01120ec
f010b2e8:	e8 6e ad ff ff       	call   f010605b <cprintf>
f010b2ed:	83 c4 10             	add    $0x10,%esp
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010b2f0:	e8 dc dd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b2f5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b2f8:	e8 20 f4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b2fd:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f010b300:	83 ec 0c             	sub    $0xc,%esp
f010b303:	68 00 fc 1f 00       	push   $0x1ffc00
f010b308:	e8 18 fa ff ff       	call   f010ad25 <kmalloc>
f010b30d:	83 c4 10             	add    $0x10,%esp
f010b310:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (KERNEL_HEAP_START)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b316:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f010b31c:	3d 00 00 00 f6       	cmp    $0xf6000000,%eax
f010b321:	74 14                	je     f010b337 <test_kmalloc+0x129>
f010b323:	83 ec 04             	sub    $0x4,%esp
f010b326:	68 10 21 11 f0       	push   $0xf0112110
f010b32b:	6a 3b                	push   $0x3b
f010b32d:	68 32 20 11 f0       	push   $0xf0112032
f010b332:	e8 25 4e ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b337:	e8 e1 f3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b33c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b33f:	74 14                	je     f010b355 <test_kmalloc+0x147>
f010b341:	83 ec 04             	sub    $0x4,%esp
f010b344:	68 44 20 11 f0       	push   $0xf0112044
f010b349:	6a 3c                	push   $0x3c
f010b34b:	68 32 20 11 f0       	push   $0xf0112032
f010b350:	e8 07 4e ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b355:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b358:	e8 74 dd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b35d:	29 c3                	sub    %eax,%ebx
f010b35f:	89 d8                	mov    %ebx,%eax
f010b361:	3d 00 02 00 00       	cmp    $0x200,%eax
f010b366:	74 14                	je     f010b37c <test_kmalloc+0x16e>
f010b368:	83 ec 04             	sub    $0x4,%esp
f010b36b:	68 ac 20 11 f0       	push   $0xf01120ac
f010b370:	6a 3d                	push   $0x3d
f010b372:	68 32 20 11 f0       	push   $0xf0112032
f010b377:	e8 e0 4d ff ff       	call   f010015c <_panic>

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010b37c:	e8 50 dd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b381:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b384:	e8 94 f3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b389:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f010b38c:	83 ec 0c             	sub    $0xc,%esp
f010b38f:	68 00 fc 1f 00       	push   $0x1ffc00
f010b394:	e8 8c f9 ff ff       	call   f010ad25 <kmalloc>
f010b399:	83 c4 10             	add    $0x10,%esp
f010b39c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[1] != (KERNEL_HEAP_START + 2*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b3a2:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f010b3a8:	3d 00 00 20 f6       	cmp    $0xf6200000,%eax
f010b3ad:	74 14                	je     f010b3c3 <test_kmalloc+0x1b5>
f010b3af:	83 ec 04             	sub    $0x4,%esp
f010b3b2:	68 10 21 11 f0       	push   $0xf0112110
f010b3b7:	6a 43                	push   $0x43
f010b3b9:	68 32 20 11 f0       	push   $0xf0112032
f010b3be:	e8 99 4d ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b3c3:	e8 55 f3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b3c8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b3cb:	74 14                	je     f010b3e1 <test_kmalloc+0x1d3>
f010b3cd:	83 ec 04             	sub    $0x4,%esp
f010b3d0:	68 44 20 11 f0       	push   $0xf0112044
f010b3d5:	6a 44                	push   $0x44
f010b3d7:	68 32 20 11 f0       	push   $0xf0112032
f010b3dc:	e8 7b 4d ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b3e1:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b3e4:	e8 e8 dc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b3e9:	29 c3                	sub    %eax,%ebx
f010b3eb:	89 d8                	mov    %ebx,%eax
f010b3ed:	3d 00 02 00 00       	cmp    $0x200,%eax
f010b3f2:	74 14                	je     f010b408 <test_kmalloc+0x1fa>
f010b3f4:	83 ec 04             	sub    $0x4,%esp
f010b3f7:	68 ac 20 11 f0       	push   $0xf01120ac
f010b3fc:	6a 45                	push   $0x45
f010b3fe:	68 32 20 11 f0       	push   $0xf0112032
f010b403:	e8 54 4d ff ff       	call   f010015c <_panic>

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010b408:	e8 c4 dc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b40d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b410:	e8 08 f3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b415:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo);
f010b418:	83 ec 0c             	sub    $0xc,%esp
f010b41b:	68 00 08 00 00       	push   $0x800
f010b420:	e8 00 f9 ff ff       	call   f010ad25 <kmalloc>
f010b425:	83 c4 10             	add    $0x10,%esp
f010b428:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[2] != (KERNEL_HEAP_START + 4*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b42e:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f010b434:	3d 00 00 40 f6       	cmp    $0xf6400000,%eax
f010b439:	74 14                	je     f010b44f <test_kmalloc+0x241>
f010b43b:	83 ec 04             	sub    $0x4,%esp
f010b43e:	68 10 21 11 f0       	push   $0xf0112110
f010b443:	6a 4b                	push   $0x4b
f010b445:	68 32 20 11 f0       	push   $0xf0112032
f010b44a:	e8 0d 4d ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b44f:	e8 c9 f2 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b454:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b457:	74 14                	je     f010b46d <test_kmalloc+0x25f>
f010b459:	83 ec 04             	sub    $0x4,%esp
f010b45c:	68 44 20 11 f0       	push   $0xf0112044
f010b461:	6a 4c                	push   $0x4c
f010b463:	68 32 20 11 f0       	push   $0xf0112032
f010b468:	e8 ef 4c ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b46d:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b470:	e8 5c dc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b475:	29 c3                	sub    %eax,%ebx
f010b477:	89 d8                	mov    %ebx,%eax
f010b479:	83 f8 01             	cmp    $0x1,%eax
f010b47c:	74 14                	je     f010b492 <test_kmalloc+0x284>
f010b47e:	83 ec 04             	sub    $0x4,%esp
f010b481:	68 ac 20 11 f0       	push   $0xf01120ac
f010b486:	6a 4d                	push   $0x4d
f010b488:	68 32 20 11 f0       	push   $0xf0112032
f010b48d:	e8 ca 4c ff ff       	call   f010015c <_panic>

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010b492:	e8 3a dc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b497:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b49a:	e8 7e f2 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b49f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f010b4a2:	83 ec 0c             	sub    $0xc,%esp
f010b4a5:	68 00 08 00 00       	push   $0x800
f010b4aa:	e8 76 f8 ff ff       	call   f010ad25 <kmalloc>
f010b4af:	83 c4 10             	add    $0x10,%esp
f010b4b2:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[3] != (KERNEL_HEAP_START + 4*Mega + 4*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b4b8:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f010b4be:	3d 00 10 40 f6       	cmp    $0xf6401000,%eax
f010b4c3:	74 14                	je     f010b4d9 <test_kmalloc+0x2cb>
f010b4c5:	83 ec 04             	sub    $0x4,%esp
f010b4c8:	68 10 21 11 f0       	push   $0xf0112110
f010b4cd:	6a 53                	push   $0x53
f010b4cf:	68 32 20 11 f0       	push   $0xf0112032
f010b4d4:	e8 83 4c ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b4d9:	e8 3f f2 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b4de:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b4e1:	74 14                	je     f010b4f7 <test_kmalloc+0x2e9>
f010b4e3:	83 ec 04             	sub    $0x4,%esp
f010b4e6:	68 44 20 11 f0       	push   $0xf0112044
f010b4eb:	6a 54                	push   $0x54
f010b4ed:	68 32 20 11 f0       	push   $0xf0112032
f010b4f2:	e8 65 4c ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b4f7:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b4fa:	e8 d2 db ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b4ff:	29 c3                	sub    %eax,%ebx
f010b501:	89 d8                	mov    %ebx,%eax
f010b503:	83 f8 01             	cmp    $0x1,%eax
f010b506:	74 14                	je     f010b51c <test_kmalloc+0x30e>
f010b508:	83 ec 04             	sub    $0x4,%esp
f010b50b:	68 ac 20 11 f0       	push   $0xf01120ac
f010b510:	6a 55                	push   $0x55
f010b512:	68 32 20 11 f0       	push   $0xf0112032
f010b517:	e8 40 4c ff ff       	call   f010015c <_panic>

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f010b51c:	e8 b0 db ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b521:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b524:	e8 f4 f1 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b529:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f010b52c:	83 ec 0c             	sub    $0xc,%esp
f010b52f:	68 00 1c 00 00       	push   $0x1c00
f010b534:	e8 ec f7 ff ff       	call   f010ad25 <kmalloc>
f010b539:	83 c4 10             	add    $0x10,%esp
f010b53c:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if ((uint32) ptr_allocations[4] != (KERNEL_HEAP_START + 4*Mega + 8*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b542:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b548:	3d 00 20 40 f6       	cmp    $0xf6402000,%eax
f010b54d:	74 14                	je     f010b563 <test_kmalloc+0x355>
f010b54f:	83 ec 04             	sub    $0x4,%esp
f010b552:	68 10 21 11 f0       	push   $0xf0112110
f010b557:	6a 5b                	push   $0x5b
f010b559:	68 32 20 11 f0       	push   $0xf0112032
f010b55e:	e8 f9 4b ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b563:	e8 b5 f1 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b568:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b56b:	74 14                	je     f010b581 <test_kmalloc+0x373>
f010b56d:	83 ec 04             	sub    $0x4,%esp
f010b570:	68 44 20 11 f0       	push   $0xf0112044
f010b575:	6a 5c                	push   $0x5c
f010b577:	68 32 20 11 f0       	push   $0xf0112032
f010b57c:	e8 db 4b ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 2) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b581:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b584:	e8 48 db ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b589:	29 c3                	sub    %eax,%ebx
f010b58b:	89 d8                	mov    %ebx,%eax
f010b58d:	83 f8 02             	cmp    $0x2,%eax
f010b590:	74 14                	je     f010b5a6 <test_kmalloc+0x398>
f010b592:	83 ec 04             	sub    $0x4,%esp
f010b595:	68 ac 20 11 f0       	push   $0xf01120ac
f010b59a:	6a 5d                	push   $0x5d
f010b59c:	68 32 20 11 f0       	push   $0xf0112032
f010b5a1:	e8 b6 4b ff ff       	call   f010015c <_panic>

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f010b5a6:	e8 26 db ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b5ab:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b5ae:	e8 6a f1 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b5b3:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f010b5b6:	83 ec 0c             	sub    $0xc,%esp
f010b5b9:	68 00 fc 2f 00       	push   $0x2ffc00
f010b5be:	e8 62 f7 ff ff       	call   f010ad25 <kmalloc>
f010b5c3:	83 c4 10             	add    $0x10,%esp
f010b5c6:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
		if ((uint32) ptr_allocations[5] != (KERNEL_HEAP_START + 4*Mega + 16*kilo) ) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b5cc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5d2:	3d 00 40 40 f6       	cmp    $0xf6404000,%eax
f010b5d7:	74 14                	je     f010b5ed <test_kmalloc+0x3df>
f010b5d9:	83 ec 04             	sub    $0x4,%esp
f010b5dc:	68 10 21 11 f0       	push   $0xf0112110
f010b5e1:	6a 63                	push   $0x63
f010b5e3:	68 32 20 11 f0       	push   $0xf0112032
f010b5e8:	e8 6f 4b ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b5ed:	e8 2b f1 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b5f2:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b5f5:	74 14                	je     f010b60b <test_kmalloc+0x3fd>
f010b5f7:	83 ec 04             	sub    $0x4,%esp
f010b5fa:	68 44 20 11 f0       	push   $0xf0112044
f010b5ff:	6a 64                	push   $0x64
f010b601:	68 32 20 11 f0       	push   $0xf0112032
f010b606:	e8 51 4b ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 768) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b60b:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b60e:	e8 be da ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b613:	29 c3                	sub    %eax,%ebx
f010b615:	89 d8                	mov    %ebx,%eax
f010b617:	3d 00 03 00 00       	cmp    $0x300,%eax
f010b61c:	74 14                	je     f010b632 <test_kmalloc+0x424>
f010b61e:	83 ec 04             	sub    $0x4,%esp
f010b621:	68 ac 20 11 f0       	push   $0xf01120ac
f010b626:	6a 65                	push   $0x65
f010b628:	68 32 20 11 f0       	push   $0xf0112032
f010b62d:	e8 2a 4b ff ff       	call   f010015c <_panic>

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f010b632:	e8 9a da ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b637:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b63a:	e8 de f0 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b63f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f010b642:	83 ec 0c             	sub    $0xc,%esp
f010b645:	68 00 fc 5f 00       	push   $0x5ffc00
f010b64a:	e8 d6 f6 ff ff       	call   f010ad25 <kmalloc>
f010b64f:	83 c4 10             	add    $0x10,%esp
f010b652:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
		if ((uint32) ptr_allocations[6] != (KERNEL_HEAP_START + 7*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b658:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b65e:	3d 00 40 70 f6       	cmp    $0xf6704000,%eax
f010b663:	74 14                	je     f010b679 <test_kmalloc+0x46b>
f010b665:	83 ec 04             	sub    $0x4,%esp
f010b668:	68 10 21 11 f0       	push   $0xf0112110
f010b66d:	6a 6b                	push   $0x6b
f010b66f:	68 32 20 11 f0       	push   $0xf0112032
f010b674:	e8 e3 4a ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b679:	e8 9f f0 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b67e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b681:	74 14                	je     f010b697 <test_kmalloc+0x489>
f010b683:	83 ec 04             	sub    $0x4,%esp
f010b686:	68 44 20 11 f0       	push   $0xf0112044
f010b68b:	6a 6c                	push   $0x6c
f010b68d:	68 32 20 11 f0       	push   $0xf0112032
f010b692:	e8 c5 4a ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1536) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b697:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b69a:	e8 32 da ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b69f:	29 c3                	sub    %eax,%ebx
f010b6a1:	89 d8                	mov    %ebx,%eax
f010b6a3:	3d 00 06 00 00       	cmp    $0x600,%eax
f010b6a8:	74 14                	je     f010b6be <test_kmalloc+0x4b0>
f010b6aa:	83 ec 04             	sub    $0x4,%esp
f010b6ad:	68 ac 20 11 f0       	push   $0xf01120ac
f010b6b2:	6a 6d                	push   $0x6d
f010b6b4:	68 32 20 11 f0       	push   $0xf0112032
f010b6b9:	e8 9e 4a ff ff       	call   f010015c <_panic>

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f010b6be:	e8 0e da ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b6c3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010b6c6:	e8 52 f0 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b6cb:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f010b6ce:	83 ec 0c             	sub    $0xc,%esp
f010b6d1:	68 00 38 00 00       	push   $0x3800
f010b6d6:	e8 4a f6 ff ff       	call   f010ad25 <kmalloc>
f010b6db:	83 c4 10             	add    $0x10,%esp
f010b6de:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
		if ((uint32) ptr_allocations[7] != (KERNEL_HEAP_START + 13*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010b6e4:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b6ea:	3d 00 40 d0 f6       	cmp    $0xf6d04000,%eax
f010b6ef:	74 14                	je     f010b705 <test_kmalloc+0x4f7>
f010b6f1:	83 ec 04             	sub    $0x4,%esp
f010b6f4:	68 10 21 11 f0       	push   $0xf0112110
f010b6f9:	6a 73                	push   $0x73
f010b6fb:	68 32 20 11 f0       	push   $0xf0112032
f010b700:	e8 57 4a ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010b705:	e8 13 f0 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b70a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010b70d:	74 14                	je     f010b723 <test_kmalloc+0x515>
f010b70f:	83 ec 04             	sub    $0x4,%esp
f010b712:	68 44 20 11 f0       	push   $0xf0112044
f010b717:	6a 74                	push   $0x74
f010b719:	68 32 20 11 f0       	push   $0xf0112032
f010b71e:	e8 39 4a ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 4) panic("Wrong allocation: pages are not loaded successfully into memory");
f010b723:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f010b726:	e8 a6 d9 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b72b:	29 c3                	sub    %eax,%ebx
f010b72d:	89 d8                	mov    %ebx,%eax
f010b72f:	83 f8 04             	cmp    $0x4,%eax
f010b732:	74 14                	je     f010b748 <test_kmalloc+0x53a>
f010b734:	83 ec 04             	sub    $0x4,%esp
f010b737:	68 ac 20 11 f0       	push   $0xf01120ac
f010b73c:	6a 75                	push   $0x75
f010b73e:	68 32 20 11 f0       	push   $0xf0112032
f010b743:	e8 14 4a ff ff       	call   f010015c <_panic>

		cprintf("\b\b\b50%");
f010b748:	83 ec 0c             	sub    $0xc,%esp
f010b74b:	68 76 21 11 f0       	push   $0xf0112176
f010b750:	e8 06 a9 ff ff       	call   f010605b <cprintf>
f010b755:	83 c4 10             	add    $0x10,%esp
		//Checking read/write on the allocated spaces
		{
			freeFrames = sys_calculate_free_frames() ;
f010b758:	e8 74 d9 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010b75d:	89 45 dc             	mov    %eax,-0x24(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f010b760:	e8 b8 ef ff ff       	call   f010a71d <pf_calculate_free_frames>
f010b765:	89 45 d8             	mov    %eax,-0x28(%ebp)

			//Write values
			//In 1st 2 MB
			lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f010b768:	c7 45 d0 ff fb 1f 00 	movl   $0x1ffbff,-0x30(%ebp)
			byteArr = (char *) ptr_allocations[0];
f010b76f:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f010b775:	89 45 cc             	mov    %eax,-0x34(%ebp)
			byteArr[0] = minByte ;
f010b778:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b77b:	8a 55 f3             	mov    -0xd(%ebp),%dl
f010b77e:	88 10                	mov    %dl,(%eax)
			byteArr[lastIndexOfByte] = maxByte ;
f010b780:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010b783:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b786:	01 c2                	add    %eax,%edx
f010b788:	8a 45 f2             	mov    -0xe(%ebp),%al
f010b78b:	88 02                	mov    %al,(%edx)

			//In 2nd 2 MB
			shortArr = (short *) ptr_allocations[1];
f010b78d:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f010b793:	89 45 c8             	mov    %eax,-0x38(%ebp)
			lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f010b796:	c7 45 c4 ff fd 0f 00 	movl   $0xffdff,-0x3c(%ebp)
			shortArr[0] = minShort;
f010b79d:	8b 55 c8             	mov    -0x38(%ebp),%edx
f010b7a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b7a3:	66 89 02             	mov    %ax,(%edx)
			shortArr[lastIndexOfShort] = maxShort;
f010b7a6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b7a9:	01 c0                	add    %eax,%eax
f010b7ab:	89 c2                	mov    %eax,%edx
f010b7ad:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b7b0:	01 c2                	add    %eax,%edx
f010b7b2:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
f010b7b6:	66 89 02             	mov    %ax,(%edx)

			//In next 2 KB
			intArr = (int *) ptr_allocations[2];
f010b7b9:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f010b7bf:	89 45 c0             	mov    %eax,-0x40(%ebp)
			lastIndexOfInt = (2*kilo)/sizeof(int) - 1;
f010b7c2:	c7 45 bc ff 01 00 00 	movl   $0x1ff,-0x44(%ebp)
			intArr[0] = minInt;
f010b7c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b7cc:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010b7cf:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f010b7d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010b7d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b7db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b7de:	01 c2                	add    %eax,%edx
f010b7e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b7e3:	89 02                	mov    %eax,(%edx)

			//In 7 KB
			structArr = (struct MyStruct *) ptr_allocations[4];
f010b7e5:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b7eb:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f010b7ee:	c7 45 b4 7f 03 00 00 	movl   $0x37f,-0x4c(%ebp)
			structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f010b7f5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b7f8:	8a 55 f3             	mov    -0xd(%ebp),%dl
f010b7fb:	88 10                	mov    %dl,(%eax)
f010b7fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f010b800:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b803:	66 89 42 02          	mov    %ax,0x2(%edx)
f010b807:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b80a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010b80d:	89 50 04             	mov    %edx,0x4(%eax)
			structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f010b810:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b813:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b81a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b81d:	01 c2                	add    %eax,%edx
f010b81f:	8a 45 f2             	mov    -0xe(%ebp),%al
f010b822:	88 02                	mov    %al,(%edx)
f010b824:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b827:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b82e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b831:	01 c2                	add    %eax,%edx
f010b833:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
f010b837:	66 89 42 02          	mov    %ax,0x2(%edx)
f010b83b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b83e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b845:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b848:	01 c2                	add    %eax,%edx
f010b84a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b84d:	89 42 04             	mov    %eax,0x4(%edx)

			//In 6 MB
			lastIndexOfByte2 = (6*Mega-kilo)/sizeof(char) - 1;
f010b850:	c7 45 b0 ff fb 5f 00 	movl   $0x5ffbff,-0x50(%ebp)
			byteArr2 = (char *) ptr_allocations[6];
f010b857:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b85d:	89 45 ac             	mov    %eax,-0x54(%ebp)
			byteArr2[0] = minByte ;
f010b860:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b863:	8a 55 f3             	mov    -0xd(%ebp),%dl
f010b866:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2 / 2] = maxByte / 2;
f010b868:	8b 45 b0             	mov    -0x50(%ebp),%eax
f010b86b:	89 c2                	mov    %eax,%edx
f010b86d:	c1 ea 1f             	shr    $0x1f,%edx
f010b870:	01 d0                	add    %edx,%eax
f010b872:	d1 f8                	sar    %eax
f010b874:	89 c2                	mov    %eax,%edx
f010b876:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b879:	01 c2                	add    %eax,%edx
f010b87b:	8a 45 f2             	mov    -0xe(%ebp),%al
f010b87e:	88 c1                	mov    %al,%cl
f010b880:	c0 e9 07             	shr    $0x7,%cl
f010b883:	01 c8                	add    %ecx,%eax
f010b885:	d0 f8                	sar    %al
f010b887:	88 02                	mov    %al,(%edx)
			byteArr2[lastIndexOfByte2] = maxByte ;
f010b889:	8b 55 b0             	mov    -0x50(%ebp),%edx
f010b88c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b88f:	01 c2                	add    %eax,%edx
f010b891:	8a 45 f2             	mov    -0xe(%ebp),%al
f010b894:	88 02                	mov    %al,(%edx)

			//In 14 KB
			shortArr2 = (short *) ptr_allocations[7];
f010b896:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b89c:	89 45 a8             	mov    %eax,-0x58(%ebp)
			lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f010b89f:	c7 45 a4 ff 1b 00 00 	movl   $0x1bff,-0x5c(%ebp)
			shortArr2[0] = minShort;
f010b8a6:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b8a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8ac:	66 89 02             	mov    %ax,(%edx)
			shortArr2[lastIndexOfShort2] = maxShort;
f010b8af:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b8b2:	01 c0                	add    %eax,%eax
f010b8b4:	89 c2                	mov    %eax,%edx
f010b8b6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b8b9:	01 c2                	add    %eax,%edx
f010b8bb:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
f010b8bf:	66 89 02             	mov    %ax,(%edx)

			//Read values: check that the values are successfully written
			if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) panic("Wrong allocation: stored values are wrongly changed!");
f010b8c2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b8c5:	8a 00                	mov    (%eax),%al
f010b8c7:	3a 45 f3             	cmp    -0xd(%ebp),%al
f010b8ca:	75 0f                	jne    f010b8db <test_kmalloc+0x6cd>
f010b8cc:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010b8cf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b8d2:	01 d0                	add    %edx,%eax
f010b8d4:	8a 00                	mov    (%eax),%al
f010b8d6:	3a 45 f2             	cmp    -0xe(%ebp),%al
f010b8d9:	74 17                	je     f010b8f2 <test_kmalloc+0x6e4>
f010b8db:	83 ec 04             	sub    $0x4,%esp
f010b8de:	68 80 21 11 f0       	push   $0xf0112180
f010b8e3:	68 a4 00 00 00       	push   $0xa4
f010b8e8:	68 32 20 11 f0       	push   $0xf0112032
f010b8ed:	e8 6a 48 ff ff       	call   f010015c <_panic>
			if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) panic("Wrong allocation: stored values are wrongly changed!");
f010b8f2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b8f5:	66 8b 00             	mov    (%eax),%ax
f010b8f8:	66 3b 45 f0          	cmp    -0x10(%ebp),%ax
f010b8fc:	75 15                	jne    f010b913 <test_kmalloc+0x705>
f010b8fe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b901:	01 c0                	add    %eax,%eax
f010b903:	89 c2                	mov    %eax,%edx
f010b905:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b908:	01 d0                	add    %edx,%eax
f010b90a:	66 8b 00             	mov    (%eax),%ax
f010b90d:	66 3b 45 ee          	cmp    -0x12(%ebp),%ax
f010b911:	74 17                	je     f010b92a <test_kmalloc+0x71c>
f010b913:	83 ec 04             	sub    $0x4,%esp
f010b916:	68 80 21 11 f0       	push   $0xf0112180
f010b91b:	68 a5 00 00 00       	push   $0xa5
f010b920:	68 32 20 11 f0       	push   $0xf0112032
f010b925:	e8 32 48 ff ff       	call   f010015c <_panic>
			if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) panic("Wrong allocation: stored values are wrongly changed!");
f010b92a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b92d:	8b 00                	mov    (%eax),%eax
f010b92f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010b932:	75 16                	jne    f010b94a <test_kmalloc+0x73c>
f010b934:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010b937:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b93e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b941:	01 d0                	add    %edx,%eax
f010b943:	8b 00                	mov    (%eax),%eax
f010b945:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010b948:	74 17                	je     f010b961 <test_kmalloc+0x753>
f010b94a:	83 ec 04             	sub    $0x4,%esp
f010b94d:	68 80 21 11 f0       	push   $0xf0112180
f010b952:	68 a6 00 00 00       	push   $0xa6
f010b957:	68 32 20 11 f0       	push   $0xf0112032
f010b95c:	e8 fb 47 ff ff       	call   f010015c <_panic>

			if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	panic("Wrong allocation: stored values are wrongly changed!");
f010b961:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b964:	8a 00                	mov    (%eax),%al
f010b966:	3a 45 f3             	cmp    -0xd(%ebp),%al
f010b969:	75 16                	jne    f010b981 <test_kmalloc+0x773>
f010b96b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b96e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b975:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b978:	01 d0                	add    %edx,%eax
f010b97a:	8a 00                	mov    (%eax),%al
f010b97c:	3a 45 f2             	cmp    -0xe(%ebp),%al
f010b97f:	74 17                	je     f010b998 <test_kmalloc+0x78a>
f010b981:	83 ec 04             	sub    $0x4,%esp
f010b984:	68 80 21 11 f0       	push   $0xf0112180
f010b989:	68 a8 00 00 00       	push   $0xa8
f010b98e:	68 32 20 11 f0       	push   $0xf0112032
f010b993:	e8 c4 47 ff ff       	call   f010015c <_panic>
			if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	panic("Wrong allocation: stored values are wrongly changed!");
f010b998:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b99b:	66 8b 40 02          	mov    0x2(%eax),%ax
f010b99f:	66 3b 45 f0          	cmp    -0x10(%ebp),%ax
f010b9a3:	75 19                	jne    f010b9be <test_kmalloc+0x7b0>
f010b9a5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b9a8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b9af:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b9b2:	01 d0                	add    %edx,%eax
f010b9b4:	66 8b 40 02          	mov    0x2(%eax),%ax
f010b9b8:	66 3b 45 ee          	cmp    -0x12(%ebp),%ax
f010b9bc:	74 17                	je     f010b9d5 <test_kmalloc+0x7c7>
f010b9be:	83 ec 04             	sub    $0x4,%esp
f010b9c1:	68 80 21 11 f0       	push   $0xf0112180
f010b9c6:	68 a9 00 00 00       	push   $0xa9
f010b9cb:	68 32 20 11 f0       	push   $0xf0112032
f010b9d0:	e8 87 47 ff ff       	call   f010015c <_panic>
			if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	panic("Wrong allocation: stored values are wrongly changed!");
f010b9d5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b9d8:	8b 40 04             	mov    0x4(%eax),%eax
f010b9db:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010b9de:	75 17                	jne    f010b9f7 <test_kmalloc+0x7e9>
f010b9e0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b9e3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b9ea:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b9ed:	01 d0                	add    %edx,%eax
f010b9ef:	8b 40 04             	mov    0x4(%eax),%eax
f010b9f2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010b9f5:	74 17                	je     f010ba0e <test_kmalloc+0x800>
f010b9f7:	83 ec 04             	sub    $0x4,%esp
f010b9fa:	68 80 21 11 f0       	push   $0xf0112180
f010b9ff:	68 aa 00 00 00       	push   $0xaa
f010ba04:	68 32 20 11 f0       	push   $0xf0112032
f010ba09:	e8 4e 47 ff ff       	call   f010015c <_panic>

			if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2/2] != maxByte/2 || byteArr2[lastIndexOfByte2] != maxByte) panic("Wrong allocation: stored values are wrongly changed!");
f010ba0e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010ba11:	8a 00                	mov    (%eax),%al
f010ba13:	3a 45 f3             	cmp    -0xd(%ebp),%al
f010ba16:	75 34                	jne    f010ba4c <test_kmalloc+0x83e>
f010ba18:	8b 45 b0             	mov    -0x50(%ebp),%eax
f010ba1b:	89 c2                	mov    %eax,%edx
f010ba1d:	c1 ea 1f             	shr    $0x1f,%edx
f010ba20:	01 d0                	add    %edx,%eax
f010ba22:	d1 f8                	sar    %eax
f010ba24:	89 c2                	mov    %eax,%edx
f010ba26:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010ba29:	01 d0                	add    %edx,%eax
f010ba2b:	8a 10                	mov    (%eax),%dl
f010ba2d:	8a 45 f2             	mov    -0xe(%ebp),%al
f010ba30:	88 c1                	mov    %al,%cl
f010ba32:	c0 e9 07             	shr    $0x7,%cl
f010ba35:	01 c8                	add    %ecx,%eax
f010ba37:	d0 f8                	sar    %al
f010ba39:	38 c2                	cmp    %al,%dl
f010ba3b:	75 0f                	jne    f010ba4c <test_kmalloc+0x83e>
f010ba3d:	8b 55 b0             	mov    -0x50(%ebp),%edx
f010ba40:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010ba43:	01 d0                	add    %edx,%eax
f010ba45:	8a 00                	mov    (%eax),%al
f010ba47:	3a 45 f2             	cmp    -0xe(%ebp),%al
f010ba4a:	74 17                	je     f010ba63 <test_kmalloc+0x855>
f010ba4c:	83 ec 04             	sub    $0x4,%esp
f010ba4f:	68 80 21 11 f0       	push   $0xf0112180
f010ba54:	68 ac 00 00 00       	push   $0xac
f010ba59:	68 32 20 11 f0       	push   $0xf0112032
f010ba5e:	e8 f9 46 ff ff       	call   f010015c <_panic>
			if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) panic("Wrong allocation: stored values are wrongly changed!");
f010ba63:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ba66:	66 8b 00             	mov    (%eax),%ax
f010ba69:	66 3b 45 f0          	cmp    -0x10(%ebp),%ax
f010ba6d:	75 15                	jne    f010ba84 <test_kmalloc+0x876>
f010ba6f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010ba72:	01 c0                	add    %eax,%eax
f010ba74:	89 c2                	mov    %eax,%edx
f010ba76:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ba79:	01 d0                	add    %edx,%eax
f010ba7b:	66 8b 00             	mov    (%eax),%ax
f010ba7e:	66 3b 45 ee          	cmp    -0x12(%ebp),%ax
f010ba82:	74 17                	je     f010ba9b <test_kmalloc+0x88d>
f010ba84:	83 ec 04             	sub    $0x4,%esp
f010ba87:	68 80 21 11 f0       	push   $0xf0112180
f010ba8c:	68 ad 00 00 00       	push   $0xad
f010ba91:	68 32 20 11 f0       	push   $0xf0112032
f010ba96:	e8 c1 46 ff ff       	call   f010015c <_panic>

			if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Wrong allocation: pages are not loaded successfully into memory");
f010ba9b:	e8 31 d6 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010baa0:	89 c2                	mov    %eax,%edx
f010baa2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010baa5:	39 c2                	cmp    %eax,%edx
f010baa7:	74 17                	je     f010bac0 <test_kmalloc+0x8b2>
f010baa9:	83 ec 04             	sub    $0x4,%esp
f010baac:	68 ac 20 11 f0       	push   $0xf01120ac
f010bab1:	68 af 00 00 00       	push   $0xaf
f010bab6:	68 32 20 11 f0       	push   $0xf0112032
f010babb:	e8 9c 46 ff ff       	call   f010015c <_panic>
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010bac0:	e8 58 ec ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bac5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010bac8:	74 17                	je     f010bae1 <test_kmalloc+0x8d3>
f010baca:	83 ec 04             	sub    $0x4,%esp
f010bacd:	68 44 20 11 f0       	push   $0xf0112044
f010bad2:	68 b0 00 00 00       	push   $0xb0
f010bad7:	68 32 20 11 f0       	push   $0xf0112032
f010badc:	e8 7b 46 ff ff       	call   f010015c <_panic>
		}

		cprintf("\b\b\b80%");
f010bae1:	83 ec 0c             	sub    $0xc,%esp
f010bae4:	68 b5 21 11 f0       	push   $0xf01121b5
f010bae9:	e8 6d a5 ff ff       	call   f010605b <cprintf>
f010baee:	83 c4 10             	add    $0x10,%esp

		//Insufficient space again
		freeFrames = sys_calculate_free_frames() ;
f010baf1:	e8 db d5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010baf6:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010baf9:	e8 1f ec ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bafe:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - KERNEL_HEAP_START + 2*PAGE_SIZE) - (2*Mega+2*Mega+4*kilo+4*kilo+8*kilo+3*Mega+6*Mega+16*kilo) ;
f010bb01:	c7 45 a0 00 90 2f 09 	movl   $0x92f9000,-0x60(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap);
f010bb08:	83 ec 0c             	sub    $0xc,%esp
f010bb0b:	ff 75 a0             	pushl  -0x60(%ebp)
f010bb0e:	e8 12 f2 ff ff       	call   f010ad25 <kmalloc>
f010bb13:	83 c4 10             	add    $0x10,%esp
f010bb16:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		if (ptr_allocations[8] != NULL) panic("Allocating insufficient space: should return NULL");
f010bb1c:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f010bb22:	85 c0                	test   %eax,%eax
f010bb24:	74 17                	je     f010bb3d <test_kmalloc+0x92f>
f010bb26:	83 ec 04             	sub    $0x4,%esp
f010bb29:	68 00 20 11 f0       	push   $0xf0112000
f010bb2e:	68 ba 00 00 00       	push   $0xba
f010bb33:	68 32 20 11 f0       	push   $0xf0112032
f010bb38:	e8 1f 46 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010bb3d:	e8 db eb ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bb42:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010bb45:	74 17                	je     f010bb5e <test_kmalloc+0x950>
f010bb47:	83 ec 04             	sub    $0x4,%esp
f010bb4a:	68 44 20 11 f0       	push   $0xf0112044
f010bb4f:	68 bb 00 00 00       	push   $0xbb
f010bb54:	68 32 20 11 f0       	push   $0xf0112032
f010bb59:	e8 fe 45 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Wrong allocation: pages are not loaded successfully into memory");
f010bb5e:	e8 6e d5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bb63:	89 c2                	mov    %eax,%edx
f010bb65:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bb68:	39 c2                	cmp    %eax,%edx
f010bb6a:	74 17                	je     f010bb83 <test_kmalloc+0x975>
f010bb6c:	83 ec 04             	sub    $0x4,%esp
f010bb6f:	68 ac 20 11 f0       	push   $0xf01120ac
f010bb74:	68 bc 00 00 00       	push   $0xbc
f010bb79:	68 32 20 11 f0       	push   $0xf0112032
f010bb7e:	e8 d9 45 ff ff       	call   f010015c <_panic>

		cprintf("\b\b\b90%");
f010bb83:	83 ec 0c             	sub    $0xc,%esp
f010bb86:	68 bc 21 11 f0       	push   $0xf01121bc
f010bb8b:	e8 cb a4 ff ff       	call   f010605b <cprintf>
f010bb90:	83 c4 10             	add    $0x10,%esp

		//permissions
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f010bb93:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010bb99:	05 00 40 00 00       	add    $0x4000,%eax
f010bb9e:	89 45 9c             	mov    %eax,-0x64(%ebp)
		uint32 va;
		for (va = KERNEL_HEAP_START; va < lastAllocAddress; va+=PAGE_SIZE)
f010bba1:	c7 45 f4 00 00 00 f6 	movl   $0xf6000000,-0xc(%ebp)
f010bba8:	eb 65                	jmp    f010bc0f <test_kmalloc+0xa01>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, (void*)va, &table);
f010bbaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bbad:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010bbb2:	83 ec 04             	sub    $0x4,%esp
f010bbb5:	8d 8d 44 ff ff ff    	lea    -0xbc(%ebp),%ecx
f010bbbb:	51                   	push   %ecx
f010bbbc:	52                   	push   %edx
f010bbbd:	50                   	push   %eax
f010bbbe:	e8 4d 71 ff ff       	call   f0102d10 <get_page_table>
f010bbc3:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f010bbc6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010bbcc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bbcf:	c1 ea 0c             	shr    $0xc,%edx
f010bbd2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010bbd8:	c1 e2 02             	shl    $0x2,%edx
f010bbdb:	01 d0                	add    %edx,%eax
f010bbdd:	8b 00                	mov    (%eax),%eax
f010bbdf:	25 ff 0f 00 00       	and    $0xfff,%eax
f010bbe4:	89 45 98             	mov    %eax,-0x68(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f010bbe7:	8b 45 98             	mov    -0x68(%ebp),%eax
f010bbea:	83 e0 04             	and    $0x4,%eax
f010bbed:	85 c0                	test   %eax,%eax
f010bbef:	74 17                	je     f010bc08 <test_kmalloc+0x9fa>
				panic("Wrong permissions: pages should be mapped with Supervisor permission only");
f010bbf1:	83 ec 04             	sub    $0x4,%esp
f010bbf4:	68 c4 21 11 f0       	push   $0xf01121c4
f010bbf9:	68 c9 00 00 00       	push   $0xc9
f010bbfe:	68 32 20 11 f0       	push   $0xf0112032
f010bc03:	e8 54 45 ff ff       	call   f010015c <_panic>
		cprintf("\b\b\b90%");

		//permissions
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = KERNEL_HEAP_START; va < lastAllocAddress; va+=PAGE_SIZE)
f010bc08:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010bc0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc12:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f010bc15:	72 93                	jb     f010bbaa <test_kmalloc+0x99c>
			uint32 perm = table[PTX(va)] & 0xFFF;
			if ((perm & PERM_USER) == PERM_USER)
				panic("Wrong permissions: pages should be mapped with Supervisor permission only");
		}

		cprintf("\b\b\b100%\n");
f010bc17:	83 ec 0c             	sub    $0xc,%esp
f010bc1a:	68 0e 22 11 f0       	push   $0xf011220e
f010bc1f:	e8 37 a4 ff ff       	call   f010605b <cprintf>
f010bc24:	83 c4 10             	add    $0x10,%esp

	}

	cprintf("Congratulations!! test kmalloc completed successfully.\n");
f010bc27:	83 ec 0c             	sub    $0xc,%esp
f010bc2a:	68 18 22 11 f0       	push   $0xf0112218
f010bc2f:	e8 27 a4 ff ff       	call   f010605b <cprintf>
f010bc34:	83 c4 10             	add    $0x10,%esp

	return 1;
f010bc37:	b8 01 00 00 00       	mov    $0x1,%eax

}
f010bc3c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010bc3f:	5b                   	pop    %ebx
f010bc40:	5f                   	pop    %edi
f010bc41:	5d                   	pop    %ebp
f010bc42:	c3                   	ret    

f010bc43 <test_kfree>:

int test_kfree()
{
f010bc43:	55                   	push   %ebp
f010bc44:	89 e5                	mov    %esp,%ebp
f010bc46:	57                   	push   %edi
f010bc47:	53                   	push   %ebx
f010bc48:	81 ec 30 01 00 00    	sub    $0x130,%esp
	char minByte = 1<<7;
f010bc4e:	c6 45 e7 80          	movb   $0x80,-0x19(%ebp)
	char maxByte = 0x7F;
f010bc52:	c6 45 e6 7f          	movb   $0x7f,-0x1a(%ebp)
	short minShort = 1<<15 ;
f010bc56:	66 c7 45 e4 00 80    	movw   $0x8000,-0x1c(%ebp)
	short maxShort = 0x7FFF;
f010bc5c:	66 c7 45 e2 ff 7f    	movw   $0x7fff,-0x1e(%ebp)
	int minInt = 1<<31 ;
f010bc62:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
	int maxInt = 0x7FFFFFFF;
f010bc69:	c7 45 d8 ff ff ff 7f 	movl   $0x7fffffff,-0x28(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f010bc70:	e8 5c d4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bc75:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f010bc78:	8d 95 70 ff ff ff    	lea    -0x90(%ebp),%edx
f010bc7e:	b9 14 00 00 00       	mov    $0x14,%ecx
f010bc83:	b8 00 00 00 00       	mov    $0x0,%eax
f010bc88:	89 d7                	mov    %edx,%edi
f010bc8a:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f010bc8c:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
f010bc92:	b9 14 00 00 00       	mov    $0x14,%ecx
f010bc97:	b8 00 00 00 00       	mov    $0x0,%eax
f010bc9c:	89 d7                	mov    %edx,%edi
f010bc9e:	f3 ab                	rep stos %eax,%es:(%edi)
	void* ptr_allocations[20] = {0};
f010bca0:	8d 95 d0 fe ff ff    	lea    -0x130(%ebp),%edx
f010bca6:	b9 14 00 00 00       	mov    $0x14,%ecx
f010bcab:	b8 00 00 00 00       	mov    $0x0,%eax
f010bcb0:	89 d7                	mov    %edx,%edi
f010bcb2:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010bcb4:	e8 18 d4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bcb9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010bcbc:	e8 5c ea ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bcc1:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f010bcc4:	83 ec 0c             	sub    $0xc,%esp
f010bcc7:	68 00 fc 1f 00       	push   $0x1ffc00
f010bccc:	e8 54 f0 ff ff       	call   f010ad25 <kmalloc>
f010bcd1:	83 c4 10             	add    $0x10,%esp
f010bcd4:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
		if ((uint32) ptr_allocations[0] !=  (KERNEL_HEAP_START)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010bcda:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f010bce0:	3d 00 00 00 f6       	cmp    $0xf6000000,%eax
f010bce5:	74 17                	je     f010bcfe <test_kfree+0xbb>
f010bce7:	83 ec 04             	sub    $0x4,%esp
f010bcea:	68 10 21 11 f0       	push   $0xf0112110
f010bcef:	68 f1 00 00 00       	push   $0xf1
f010bcf4:	68 32 20 11 f0       	push   $0xf0112032
f010bcf9:	e8 5e 44 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010bcfe:	e8 1a ea ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bd03:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010bd06:	74 17                	je     f010bd1f <test_kfree+0xdc>
f010bd08:	83 ec 04             	sub    $0x4,%esp
f010bd0b:	68 44 20 11 f0       	push   $0xf0112044
f010bd10:	68 f2 00 00 00       	push   $0xf2
f010bd15:	68 32 20 11 f0       	push   $0xf0112032
f010bd1a:	e8 3d 44 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010bd1f:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010bd22:	e8 aa d3 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bd27:	29 c3                	sub    %eax,%ebx
f010bd29:	89 d8                	mov    %ebx,%eax
f010bd2b:	3d 00 02 00 00       	cmp    $0x200,%eax
f010bd30:	74 17                	je     f010bd49 <test_kfree+0x106>
f010bd32:	83 ec 04             	sub    $0x4,%esp
f010bd35:	68 ac 20 11 f0       	push   $0xf01120ac
f010bd3a:	68 f3 00 00 00       	push   $0xf3
f010bd3f:	68 32 20 11 f0       	push   $0xf0112032
f010bd44:	e8 13 44 ff ff       	call   f010015c <_panic>
		lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f010bd49:	c7 85 70 ff ff ff ff 	movl   $0x1ffbff,-0x90(%ebp)
f010bd50:	fb 1f 00 

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010bd53:	e8 79 d3 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bd58:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010bd5b:	e8 bd e9 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bd60:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f010bd63:	83 ec 0c             	sub    $0xc,%esp
f010bd66:	68 00 fc 1f 00       	push   $0x1ffc00
f010bd6b:	e8 b5 ef ff ff       	call   f010ad25 <kmalloc>
f010bd70:	83 c4 10             	add    $0x10,%esp
f010bd73:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
		if ((uint32) ptr_allocations[1] != (KERNEL_HEAP_START + 2*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010bd79:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f010bd7f:	3d 00 00 20 f6       	cmp    $0xf6200000,%eax
f010bd84:	74 17                	je     f010bd9d <test_kfree+0x15a>
f010bd86:	83 ec 04             	sub    $0x4,%esp
f010bd89:	68 10 21 11 f0       	push   $0xf0112110
f010bd8e:	68 fa 00 00 00       	push   $0xfa
f010bd93:	68 32 20 11 f0       	push   $0xf0112032
f010bd98:	e8 bf 43 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010bd9d:	e8 7b e9 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bda2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010bda5:	74 17                	je     f010bdbe <test_kfree+0x17b>
f010bda7:	83 ec 04             	sub    $0x4,%esp
f010bdaa:	68 44 20 11 f0       	push   $0xf0112044
f010bdaf:	68 fb 00 00 00       	push   $0xfb
f010bdb4:	68 32 20 11 f0       	push   $0xf0112032
f010bdb9:	e8 9e 43 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010bdbe:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010bdc1:	e8 0b d3 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bdc6:	29 c3                	sub    %eax,%ebx
f010bdc8:	89 d8                	mov    %ebx,%eax
f010bdca:	3d 00 02 00 00       	cmp    $0x200,%eax
f010bdcf:	74 17                	je     f010bde8 <test_kfree+0x1a5>
f010bdd1:	83 ec 04             	sub    $0x4,%esp
f010bdd4:	68 ac 20 11 f0       	push   $0xf01120ac
f010bdd9:	68 fc 00 00 00       	push   $0xfc
f010bdde:	68 32 20 11 f0       	push   $0xf0112032
f010bde3:	e8 74 43 ff ff       	call   f010015c <_panic>
		lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f010bde8:	c7 85 74 ff ff ff ff 	movl   $0x1ffbff,-0x8c(%ebp)
f010bdef:	fb 1f 00 

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010bdf2:	e8 da d2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bdf7:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010bdfa:	e8 1e e9 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bdff:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo);
f010be02:	83 ec 0c             	sub    $0xc,%esp
f010be05:	68 00 08 00 00       	push   $0x800
f010be0a:	e8 16 ef ff ff       	call   f010ad25 <kmalloc>
f010be0f:	83 c4 10             	add    $0x10,%esp
f010be12:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
		if ((uint32) ptr_allocations[2] != (KERNEL_HEAP_START + 4*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010be18:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f010be1e:	3d 00 00 40 f6       	cmp    $0xf6400000,%eax
f010be23:	74 17                	je     f010be3c <test_kfree+0x1f9>
f010be25:	83 ec 04             	sub    $0x4,%esp
f010be28:	68 10 21 11 f0       	push   $0xf0112110
f010be2d:	68 03 01 00 00       	push   $0x103
f010be32:	68 32 20 11 f0       	push   $0xf0112032
f010be37:	e8 20 43 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010be3c:	e8 dc e8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010be41:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010be44:	74 17                	je     f010be5d <test_kfree+0x21a>
f010be46:	83 ec 04             	sub    $0x4,%esp
f010be49:	68 44 20 11 f0       	push   $0xf0112044
f010be4e:	68 04 01 00 00       	push   $0x104
f010be53:	68 32 20 11 f0       	push   $0xf0112032
f010be58:	e8 ff 42 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010be5d:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010be60:	e8 6c d2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010be65:	29 c3                	sub    %eax,%ebx
f010be67:	89 d8                	mov    %ebx,%eax
f010be69:	83 f8 01             	cmp    $0x1,%eax
f010be6c:	74 17                	je     f010be85 <test_kfree+0x242>
f010be6e:	83 ec 04             	sub    $0x4,%esp
f010be71:	68 ac 20 11 f0       	push   $0xf01120ac
f010be76:	68 05 01 00 00       	push   $0x105
f010be7b:	68 32 20 11 f0       	push   $0xf0112032
f010be80:	e8 d7 42 ff ff       	call   f010015c <_panic>
		lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f010be85:	c7 85 78 ff ff ff ff 	movl   $0x7ff,-0x88(%ebp)
f010be8c:	07 00 00 
		ptr = (char*)ptr_allocations[2];
f010be8f:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f010be95:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[2]; ++i)
f010be98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010be9f:	eb 0e                	jmp    f010beaf <test_kfree+0x26c>
		{
			ptr[i] = 2 ;
f010bea1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bea4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010bea7:	01 d0                	add    %edx,%eax
f010bea9:	c6 00 02             	movb   $0x2,(%eax)
		if ((uint32) ptr_allocations[2] != (KERNEL_HEAP_START + 4*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
		lastIndices[2] = (2*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[2];
		for (i = 0; i < lastIndices[2]; ++i)
f010beac:	ff 45 f4             	incl   -0xc(%ebp)
f010beaf:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010beb5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010beb8:	7f e7                	jg     f010bea1 <test_kfree+0x25e>
		{
			ptr[i] = 2 ;
		}

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010beba:	e8 12 d2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bebf:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010bec2:	e8 56 e8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bec7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f010beca:	83 ec 0c             	sub    $0xc,%esp
f010becd:	68 00 08 00 00       	push   $0x800
f010bed2:	e8 4e ee ff ff       	call   f010ad25 <kmalloc>
f010bed7:	83 c4 10             	add    $0x10,%esp
f010beda:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
		if ((uint32) ptr_allocations[3] != (KERNEL_HEAP_START + 4*Mega + 4*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010bee0:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f010bee6:	3d 00 10 40 f6       	cmp    $0xf6401000,%eax
f010beeb:	74 17                	je     f010bf04 <test_kfree+0x2c1>
f010beed:	83 ec 04             	sub    $0x4,%esp
f010bef0:	68 10 21 11 f0       	push   $0xf0112110
f010bef5:	68 11 01 00 00       	push   $0x111
f010befa:	68 32 20 11 f0       	push   $0xf0112032
f010beff:	e8 58 42 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010bf04:	e8 14 e8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bf09:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010bf0c:	74 17                	je     f010bf25 <test_kfree+0x2e2>
f010bf0e:	83 ec 04             	sub    $0x4,%esp
f010bf11:	68 44 20 11 f0       	push   $0xf0112044
f010bf16:	68 12 01 00 00       	push   $0x112
f010bf1b:	68 32 20 11 f0       	push   $0xf0112032
f010bf20:	e8 37 42 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010bf25:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010bf28:	e8 a4 d1 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bf2d:	29 c3                	sub    %eax,%ebx
f010bf2f:	89 d8                	mov    %ebx,%eax
f010bf31:	83 f8 01             	cmp    $0x1,%eax
f010bf34:	74 17                	je     f010bf4d <test_kfree+0x30a>
f010bf36:	83 ec 04             	sub    $0x4,%esp
f010bf39:	68 ac 20 11 f0       	push   $0xf01120ac
f010bf3e:	68 13 01 00 00       	push   $0x113
f010bf43:	68 32 20 11 f0       	push   $0xf0112032
f010bf48:	e8 0f 42 ff ff       	call   f010015c <_panic>
		lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f010bf4d:	c7 85 7c ff ff ff ff 	movl   $0x7ff,-0x84(%ebp)
f010bf54:	07 00 00 
		ptr = (char*)ptr_allocations[3];
f010bf57:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f010bf5d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f010bf60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bf67:	eb 0e                	jmp    f010bf77 <test_kfree+0x334>
		{
			ptr[i] = 3 ;
f010bf69:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf6c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010bf6f:	01 d0                	add    %edx,%eax
f010bf71:	c6 00 03             	movb   $0x3,(%eax)
		if ((uint32) ptr_allocations[3] != (KERNEL_HEAP_START + 4*Mega + 4*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
		lastIndices[3] = (2*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f010bf74:	ff 45 f4             	incl   -0xc(%ebp)
f010bf77:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010bf7d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010bf80:	7f e7                	jg     f010bf69 <test_kfree+0x326>
		{
			ptr[i] = 3 ;
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f010bf82:	e8 4a d1 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bf87:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010bf8a:	e8 8e e7 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bf8f:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f010bf92:	83 ec 0c             	sub    $0xc,%esp
f010bf95:	68 00 1c 00 00       	push   $0x1c00
f010bf9a:	e8 86 ed ff ff       	call   f010ad25 <kmalloc>
f010bf9f:	83 c4 10             	add    $0x10,%esp
f010bfa2:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
		if ((uint32) ptr_allocations[4] != (KERNEL_HEAP_START + 4*Mega + 8*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010bfa8:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f010bfae:	3d 00 20 40 f6       	cmp    $0xf6402000,%eax
f010bfb3:	74 17                	je     f010bfcc <test_kfree+0x389>
f010bfb5:	83 ec 04             	sub    $0x4,%esp
f010bfb8:	68 10 21 11 f0       	push   $0xf0112110
f010bfbd:	68 1f 01 00 00       	push   $0x11f
f010bfc2:	68 32 20 11 f0       	push   $0xf0112032
f010bfc7:	e8 90 41 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010bfcc:	e8 4c e7 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010bfd1:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010bfd4:	74 17                	je     f010bfed <test_kfree+0x3aa>
f010bfd6:	83 ec 04             	sub    $0x4,%esp
f010bfd9:	68 44 20 11 f0       	push   $0xf0112044
f010bfde:	68 20 01 00 00       	push   $0x120
f010bfe3:	68 32 20 11 f0       	push   $0xf0112032
f010bfe8:	e8 6f 41 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 2) panic("Wrong allocation: pages are not loaded successfully into memory");
f010bfed:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010bff0:	e8 dc d0 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010bff5:	29 c3                	sub    %eax,%ebx
f010bff7:	89 d8                	mov    %ebx,%eax
f010bff9:	83 f8 02             	cmp    $0x2,%eax
f010bffc:	74 17                	je     f010c015 <test_kfree+0x3d2>
f010bffe:	83 ec 04             	sub    $0x4,%esp
f010c001:	68 ac 20 11 f0       	push   $0xf01120ac
f010c006:	68 21 01 00 00       	push   $0x121
f010c00b:	68 32 20 11 f0       	push   $0xf0112032
f010c010:	e8 47 41 ff ff       	call   f010015c <_panic>
		lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f010c015:	c7 45 80 ff 1b 00 00 	movl   $0x1bff,-0x80(%ebp)
		ptr = (char*)ptr_allocations[4];
f010c01c:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f010c022:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f010c025:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c02c:	eb 0e                	jmp    f010c03c <test_kfree+0x3f9>
		{
			ptr[i] = 4 ;
f010c02e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c031:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c034:	01 d0                	add    %edx,%eax
f010c036:	c6 00 04             	movb   $0x4,(%eax)
		if ((uint32) ptr_allocations[4] != (KERNEL_HEAP_START + 4*Mega + 8*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
		if ((freeFrames - sys_calculate_free_frames()) != 2) panic("Wrong allocation: pages are not loaded successfully into memory");
		lastIndices[4] = (7*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f010c039:	ff 45 f4             	incl   -0xc(%ebp)
f010c03c:	8b 45 80             	mov    -0x80(%ebp),%eax
f010c03f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c042:	7f ea                	jg     f010c02e <test_kfree+0x3eb>
		{
			ptr[i] = 4 ;
		}

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f010c044:	e8 88 d0 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c049:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c04c:	e8 cc e6 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c051:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f010c054:	83 ec 0c             	sub    $0xc,%esp
f010c057:	68 00 fc 2f 00       	push   $0x2ffc00
f010c05c:	e8 c4 ec ff ff       	call   f010ad25 <kmalloc>
f010c061:	83 c4 10             	add    $0x10,%esp
f010c064:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[5] != (KERNEL_HEAP_START + 4*Mega + 16*kilo) ) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010c06a:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f010c070:	3d 00 40 40 f6       	cmp    $0xf6404000,%eax
f010c075:	74 17                	je     f010c08e <test_kfree+0x44b>
f010c077:	83 ec 04             	sub    $0x4,%esp
f010c07a:	68 10 21 11 f0       	push   $0xf0112110
f010c07f:	68 2d 01 00 00       	push   $0x12d
f010c084:	68 32 20 11 f0       	push   $0xf0112032
f010c089:	e8 ce 40 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c08e:	e8 8a e6 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c093:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c096:	74 17                	je     f010c0af <test_kfree+0x46c>
f010c098:	83 ec 04             	sub    $0x4,%esp
f010c09b:	68 44 20 11 f0       	push   $0xf0112044
f010c0a0:	68 2e 01 00 00       	push   $0x12e
f010c0a5:	68 32 20 11 f0       	push   $0xf0112032
f010c0aa:	e8 ad 40 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 768) panic("Wrong allocation: pages are not loaded successfully into memory");
f010c0af:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010c0b2:	e8 1a d0 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c0b7:	29 c3                	sub    %eax,%ebx
f010c0b9:	89 d8                	mov    %ebx,%eax
f010c0bb:	3d 00 03 00 00       	cmp    $0x300,%eax
f010c0c0:	74 17                	je     f010c0d9 <test_kfree+0x496>
f010c0c2:	83 ec 04             	sub    $0x4,%esp
f010c0c5:	68 ac 20 11 f0       	push   $0xf01120ac
f010c0ca:	68 2f 01 00 00       	push   $0x12f
f010c0cf:	68 32 20 11 f0       	push   $0xf0112032
f010c0d4:	e8 83 40 ff ff       	call   f010015c <_panic>
		lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f010c0d9:	c7 45 84 ff fb 2f 00 	movl   $0x2ffbff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[5];
f010c0e0:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f010c0e6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f010c0e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c0f0:	eb 0e                	jmp    f010c100 <test_kfree+0x4bd>
		{
			ptr[i] = 5 ;
f010c0f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c0f5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c0f8:	01 d0                	add    %edx,%eax
f010c0fa:	c6 00 05             	movb   $0x5,(%eax)
		if ((uint32) ptr_allocations[5] != (KERNEL_HEAP_START + 4*Mega + 16*kilo) ) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
		if ((freeFrames - sys_calculate_free_frames()) != 768) panic("Wrong allocation: pages are not loaded successfully into memory");
		lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f010c0fd:	ff 45 f4             	incl   -0xc(%ebp)
f010c100:	8b 45 84             	mov    -0x7c(%ebp),%eax
f010c103:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c106:	7f ea                	jg     f010c0f2 <test_kfree+0x4af>
		{
			ptr[i] = 5 ;
		}

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f010c108:	e8 c4 cf ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c10d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c110:	e8 08 e6 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c115:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f010c118:	83 ec 0c             	sub    $0xc,%esp
f010c11b:	68 00 fc 5f 00       	push   $0x5ffc00
f010c120:	e8 00 ec ff ff       	call   f010ad25 <kmalloc>
f010c125:	83 c4 10             	add    $0x10,%esp
f010c128:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if ((uint32) ptr_allocations[6] != (KERNEL_HEAP_START + 7*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010c12e:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f010c134:	3d 00 40 70 f6       	cmp    $0xf6704000,%eax
f010c139:	74 17                	je     f010c152 <test_kfree+0x50f>
f010c13b:	83 ec 04             	sub    $0x4,%esp
f010c13e:	68 10 21 11 f0       	push   $0xf0112110
f010c143:	68 3b 01 00 00       	push   $0x13b
f010c148:	68 32 20 11 f0       	push   $0xf0112032
f010c14d:	e8 0a 40 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c152:	e8 c6 e5 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c157:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c15a:	74 17                	je     f010c173 <test_kfree+0x530>
f010c15c:	83 ec 04             	sub    $0x4,%esp
f010c15f:	68 44 20 11 f0       	push   $0xf0112044
f010c164:	68 3c 01 00 00       	push   $0x13c
f010c169:	68 32 20 11 f0       	push   $0xf0112032
f010c16e:	e8 e9 3f ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1536) panic("Wrong allocation: pages are not loaded successfully into memory");
f010c173:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010c176:	e8 56 cf ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c17b:	29 c3                	sub    %eax,%ebx
f010c17d:	89 d8                	mov    %ebx,%eax
f010c17f:	3d 00 06 00 00       	cmp    $0x600,%eax
f010c184:	74 17                	je     f010c19d <test_kfree+0x55a>
f010c186:	83 ec 04             	sub    $0x4,%esp
f010c189:	68 ac 20 11 f0       	push   $0xf01120ac
f010c18e:	68 3d 01 00 00       	push   $0x13d
f010c193:	68 32 20 11 f0       	push   $0xf0112032
f010c198:	e8 bf 3f ff ff       	call   f010015c <_panic>
		lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f010c19d:	c7 45 88 ff fb 5f 00 	movl   $0x5ffbff,-0x78(%ebp)

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f010c1a4:	e8 28 cf ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c1a9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c1ac:	e8 6c e5 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c1b1:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f010c1b4:	83 ec 0c             	sub    $0xc,%esp
f010c1b7:	68 00 38 00 00       	push   $0x3800
f010c1bc:	e8 64 eb ff ff       	call   f010ad25 <kmalloc>
f010c1c1:	83 c4 10             	add    $0x10,%esp
f010c1c4:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[7] != (KERNEL_HEAP_START + 13*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010c1ca:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f010c1d0:	3d 00 40 d0 f6       	cmp    $0xf6d04000,%eax
f010c1d5:	74 17                	je     f010c1ee <test_kfree+0x5ab>
f010c1d7:	83 ec 04             	sub    $0x4,%esp
f010c1da:	68 10 21 11 f0       	push   $0xf0112110
f010c1df:	68 44 01 00 00       	push   $0x144
f010c1e4:	68 32 20 11 f0       	push   $0xf0112032
f010c1e9:	e8 6e 3f ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c1ee:	e8 2a e5 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c1f3:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c1f6:	74 17                	je     f010c20f <test_kfree+0x5cc>
f010c1f8:	83 ec 04             	sub    $0x4,%esp
f010c1fb:	68 44 20 11 f0       	push   $0xf0112044
f010c200:	68 45 01 00 00       	push   $0x145
f010c205:	68 32 20 11 f0       	push   $0xf0112032
f010c20a:	e8 4d 3f ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 4) panic("Wrong allocation: pages are not loaded successfully into memory");
f010c20f:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010c212:	e8 ba ce ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c217:	29 c3                	sub    %eax,%ebx
f010c219:	89 d8                	mov    %ebx,%eax
f010c21b:	83 f8 04             	cmp    $0x4,%eax
f010c21e:	74 17                	je     f010c237 <test_kfree+0x5f4>
f010c220:	83 ec 04             	sub    $0x4,%esp
f010c223:	68 ac 20 11 f0       	push   $0xf01120ac
f010c228:	68 46 01 00 00       	push   $0x146
f010c22d:	68 32 20 11 f0       	push   $0xf0112032
f010c232:	e8 25 3f ff ff       	call   f010015c <_panic>
		lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f010c237:	c7 45 8c ff 37 00 00 	movl   $0x37ff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[7];
f010c23e:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f010c244:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f010c247:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c24e:	eb 0e                	jmp    f010c25e <test_kfree+0x61b>
		{
			ptr[i] = 7 ;
f010c250:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c253:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c256:	01 d0                	add    %edx,%eax
f010c258:	c6 00 07             	movb   $0x7,(%eax)
		if ((uint32) ptr_allocations[7] != (KERNEL_HEAP_START + 13*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
		if ((freeFrames - sys_calculate_free_frames()) != 4) panic("Wrong allocation: pages are not loaded successfully into memory");
		lastIndices[7] = (14*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f010c25b:	ff 45 f4             	incl   -0xc(%ebp)
f010c25e:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010c261:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c264:	7f ea                	jg     f010c250 <test_kfree+0x60d>
	}

	//kfree some of the allocated spaces [15%]
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f010c266:	e8 66 ce ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c26b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f010c26e:	e8 aa e4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c273:	89 45 c0             	mov    %eax,-0x40(%ebp)
		kfree(ptr_allocations[0]);
f010c276:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f010c27c:	83 ec 0c             	sub    $0xc,%esp
f010c27f:	50                   	push   %eax
f010c280:	e8 19 ee ff ff       	call   f010b09e <kfree>
f010c285:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c288:	e8 90 e4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c28d:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010c290:	74 17                	je     f010c2a9 <test_kfree+0x666>
f010c292:	83 ec 04             	sub    $0x4,%esp
f010c295:	68 44 20 11 f0       	push   $0xf0112044
f010c29a:	68 55 01 00 00       	push   $0x155
f010c29f:	68 32 20 11 f0       	push   $0xf0112032
f010c2a4:	e8 b3 3e ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 512 ) panic("Wrong kfree: pages in memory are not freed correctly");
f010c2a9:	e8 23 ce ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c2ae:	89 c2                	mov    %eax,%edx
f010c2b0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c2b3:	29 c2                	sub    %eax,%edx
f010c2b5:	89 d0                	mov    %edx,%eax
f010c2b7:	3d 00 02 00 00       	cmp    $0x200,%eax
f010c2bc:	74 17                	je     f010c2d5 <test_kfree+0x692>
f010c2be:	83 ec 04             	sub    $0x4,%esp
f010c2c1:	68 50 22 11 f0       	push   $0xf0112250
f010c2c6:	68 56 01 00 00       	push   $0x156
f010c2cb:	68 32 20 11 f0       	push   $0xf0112032
f010c2d0:	e8 87 3e ff ff       	call   f010015c <_panic>

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f010c2d5:	e8 f7 cd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c2da:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c2dd:	e8 3b e4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c2e2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		kfree(ptr_allocations[1]);
f010c2e5:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f010c2eb:	83 ec 0c             	sub    $0xc,%esp
f010c2ee:	50                   	push   %eax
f010c2ef:	e8 aa ed ff ff       	call   f010b09e <kfree>
f010c2f4:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c2f7:	e8 21 e4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c2fc:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010c2ff:	74 17                	je     f010c318 <test_kfree+0x6d5>
f010c301:	83 ec 04             	sub    $0x4,%esp
f010c304:	68 44 20 11 f0       	push   $0xf0112044
f010c309:	68 5c 01 00 00       	push   $0x15c
f010c30e:	68 32 20 11 f0       	push   $0xf0112032
f010c313:	e8 44 3e ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 512) panic("Wrong kfree: pages in memory are not freed correctly");
f010c318:	e8 b4 cd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c31d:	89 c2                	mov    %eax,%edx
f010c31f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c322:	29 c2                	sub    %eax,%edx
f010c324:	89 d0                	mov    %edx,%eax
f010c326:	3d 00 02 00 00       	cmp    $0x200,%eax
f010c32b:	74 17                	je     f010c344 <test_kfree+0x701>
f010c32d:	83 ec 04             	sub    $0x4,%esp
f010c330:	68 50 22 11 f0       	push   $0xf0112250
f010c335:	68 5d 01 00 00       	push   $0x15d
f010c33a:	68 32 20 11 f0       	push   $0xf0112032
f010c33f:	e8 18 3e ff ff       	call   f010015c <_panic>

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f010c344:	e8 88 cd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c349:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c34c:	e8 cc e3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c351:	89 45 c0             	mov    %eax,-0x40(%ebp)
		kfree(ptr_allocations[6]);
f010c354:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f010c35a:	83 ec 0c             	sub    $0xc,%esp
f010c35d:	50                   	push   %eax
f010c35e:	e8 3b ed ff ff       	call   f010b09e <kfree>
f010c363:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c366:	e8 b2 e3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c36b:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010c36e:	74 17                	je     f010c387 <test_kfree+0x744>
f010c370:	83 ec 04             	sub    $0x4,%esp
f010c373:	68 44 20 11 f0       	push   $0xf0112044
f010c378:	68 63 01 00 00       	push   $0x163
f010c37d:	68 32 20 11 f0       	push   $0xf0112032
f010c382:	e8 d5 3d ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 6*Mega/4096) panic("Wrong kfree: pages in memory are not freed correctly");
f010c387:	e8 45 cd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c38c:	89 c2                	mov    %eax,%edx
f010c38e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c391:	29 c2                	sub    %eax,%edx
f010c393:	89 d0                	mov    %edx,%eax
f010c395:	3d 00 06 00 00       	cmp    $0x600,%eax
f010c39a:	74 17                	je     f010c3b3 <test_kfree+0x770>
f010c39c:	83 ec 04             	sub    $0x4,%esp
f010c39f:	68 50 22 11 f0       	push   $0xf0112250
f010c3a4:	68 64 01 00 00       	push   $0x164
f010c3a9:	68 32 20 11 f0       	push   $0xf0112032
f010c3ae:	e8 a9 3d ff ff       	call   f010015c <_panic>
	}

	cprintf("kfree: current evaluation = 15%");
f010c3b3:	83 ec 0c             	sub    $0xc,%esp
f010c3b6:	68 88 22 11 f0       	push   $0xf0112288
f010c3bb:	e8 9b 9c ff ff       	call   f010605b <cprintf>
f010c3c0:	83 c4 10             	add    $0x10,%esp

	//Check memory access after kfree [15%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[2];
f010c3c3:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f010c3c9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[2]; ++i)
f010c3cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c3d3:	eb 1e                	jmp    f010c3f3 <test_kfree+0x7b0>
		{
			sums[2] += ptr[i] ;
f010c3d5:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f010c3db:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c3de:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c3e1:	01 c8                	add    %ecx,%eax
f010c3e3:	8a 00                	mov    (%eax),%al
f010c3e5:	0f be c0             	movsbl %al,%eax
f010c3e8:	01 d0                	add    %edx,%eax
f010c3ea:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)

	//Check memory access after kfree [15%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[2];
		for (i = 0; i < lastIndices[2]; ++i)
f010c3f0:	ff 45 f4             	incl   -0xc(%ebp)
f010c3f3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010c3f9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c3fc:	7f d7                	jg     f010c3d5 <test_kfree+0x792>
		{
			sums[2] += ptr[i] ;
		}
		if (sums[2] != 2*lastIndices[2])	panic("kfree: invalid read after freeing some allocations");
f010c3fe:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f010c404:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010c40a:	01 c0                	add    %eax,%eax
f010c40c:	39 c2                	cmp    %eax,%edx
f010c40e:	74 17                	je     f010c427 <test_kfree+0x7e4>
f010c410:	83 ec 04             	sub    $0x4,%esp
f010c413:	68 a8 22 11 f0       	push   $0xf01122a8
f010c418:	68 71 01 00 00       	push   $0x171
f010c41d:	68 32 20 11 f0       	push   $0xf0112032
f010c422:	e8 35 3d ff ff       	call   f010015c <_panic>

		//2 KB
		ptr = (char*)ptr_allocations[3];
f010c427:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f010c42d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f010c430:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c437:	eb 1e                	jmp    f010c457 <test_kfree+0x814>
		{
			sums[3] += ptr[i] ;
f010c439:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f010c43f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c442:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c445:	01 c8                	add    %ecx,%eax
f010c447:	8a 00                	mov    (%eax),%al
f010c449:	0f be c0             	movsbl %al,%eax
f010c44c:	01 d0                	add    %edx,%eax
f010c44e:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		}
		if (sums[2] != 2*lastIndices[2])	panic("kfree: invalid read after freeing some allocations");

		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f010c454:	ff 45 f4             	incl   -0xc(%ebp)
f010c457:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010c45d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c460:	7f d7                	jg     f010c439 <test_kfree+0x7f6>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	panic("kfree: invalid read after freeing some allocations");
f010c462:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f010c468:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010c46e:	89 c1                	mov    %eax,%ecx
f010c470:	01 c9                	add    %ecx,%ecx
f010c472:	01 c8                	add    %ecx,%eax
f010c474:	39 c2                	cmp    %eax,%edx
f010c476:	74 17                	je     f010c48f <test_kfree+0x84c>
f010c478:	83 ec 04             	sub    $0x4,%esp
f010c47b:	68 a8 22 11 f0       	push   $0xf01122a8
f010c480:	68 79 01 00 00       	push   $0x179
f010c485:	68 32 20 11 f0       	push   $0xf0112032
f010c48a:	e8 cd 3c ff ff       	call   f010015c <_panic>

		//7 KB
		ptr = (char*)ptr_allocations[4];
f010c48f:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f010c495:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f010c498:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c49f:	eb 1e                	jmp    f010c4bf <test_kfree+0x87c>
		{
			sums[4] += ptr[i] ;
f010c4a1:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f010c4a7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c4aa:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c4ad:	01 c8                	add    %ecx,%eax
f010c4af:	8a 00                	mov    (%eax),%al
f010c4b1:	0f be c0             	movsbl %al,%eax
f010c4b4:	01 d0                	add    %edx,%eax
f010c4b6:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	panic("kfree: invalid read after freeing some allocations");

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f010c4bc:	ff 45 f4             	incl   -0xc(%ebp)
f010c4bf:	8b 45 80             	mov    -0x80(%ebp),%eax
f010c4c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c4c5:	7f da                	jg     f010c4a1 <test_kfree+0x85e>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	panic("kfree: invalid read after freeing some allocations");
f010c4c7:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f010c4cd:	8b 55 80             	mov    -0x80(%ebp),%edx
f010c4d0:	c1 e2 02             	shl    $0x2,%edx
f010c4d3:	39 d0                	cmp    %edx,%eax
f010c4d5:	74 17                	je     f010c4ee <test_kfree+0x8ab>
f010c4d7:	83 ec 04             	sub    $0x4,%esp
f010c4da:	68 a8 22 11 f0       	push   $0xf01122a8
f010c4df:	68 81 01 00 00       	push   $0x181
f010c4e4:	68 32 20 11 f0       	push   $0xf0112032
f010c4e9:	e8 6e 3c ff ff       	call   f010015c <_panic>

		//3 MB
		ptr = (char*)ptr_allocations[5];
f010c4ee:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f010c4f4:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f010c4f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c4fe:	eb 1e                	jmp    f010c51e <test_kfree+0x8db>
		{
			sums[5] += ptr[i] ;
f010c500:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f010c506:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c509:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c50c:	01 c8                	add    %ecx,%eax
f010c50e:	8a 00                	mov    (%eax),%al
f010c510:	0f be c0             	movsbl %al,%eax
f010c513:	01 d0                	add    %edx,%eax
f010c515:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	panic("kfree: invalid read after freeing some allocations");

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f010c51b:	ff 45 f4             	incl   -0xc(%ebp)
f010c51e:	8b 45 84             	mov    -0x7c(%ebp),%eax
f010c521:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c524:	7f da                	jg     f010c500 <test_kfree+0x8bd>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	panic("kfree: invalid read after freeing some allocations");
f010c526:	8b 8d 34 ff ff ff    	mov    -0xcc(%ebp),%ecx
f010c52c:	8b 55 84             	mov    -0x7c(%ebp),%edx
f010c52f:	89 d0                	mov    %edx,%eax
f010c531:	c1 e0 02             	shl    $0x2,%eax
f010c534:	01 d0                	add    %edx,%eax
f010c536:	39 c1                	cmp    %eax,%ecx
f010c538:	74 17                	je     f010c551 <test_kfree+0x90e>
f010c53a:	83 ec 04             	sub    $0x4,%esp
f010c53d:	68 a8 22 11 f0       	push   $0xf01122a8
f010c542:	68 89 01 00 00       	push   $0x189
f010c547:	68 32 20 11 f0       	push   $0xf0112032
f010c54c:	e8 0b 3c ff ff       	call   f010015c <_panic>

		//14 KB
		ptr = (char*)ptr_allocations[7];
f010c551:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f010c557:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f010c55a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c561:	eb 1e                	jmp    f010c581 <test_kfree+0x93e>
		{
			sums[7] += ptr[i] ;
f010c563:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010c569:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c56c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c56f:	01 c8                	add    %ecx,%eax
f010c571:	8a 00                	mov    (%eax),%al
f010c573:	0f be c0             	movsbl %al,%eax
f010c576:	01 d0                	add    %edx,%eax
f010c578:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	panic("kfree: invalid read after freeing some allocations");

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f010c57e:	ff 45 f4             	incl   -0xc(%ebp)
f010c581:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010c584:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c587:	7f da                	jg     f010c563 <test_kfree+0x920>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	panic("kfree: invalid read after freeing some allocations");
f010c589:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f010c58f:	8b 55 8c             	mov    -0x74(%ebp),%edx
f010c592:	89 d0                	mov    %edx,%eax
f010c594:	01 c0                	add    %eax,%eax
f010c596:	01 d0                	add    %edx,%eax
f010c598:	01 c0                	add    %eax,%eax
f010c59a:	01 d0                	add    %edx,%eax
f010c59c:	39 c1                	cmp    %eax,%ecx
f010c59e:	74 17                	je     f010c5b7 <test_kfree+0x974>
f010c5a0:	83 ec 04             	sub    $0x4,%esp
f010c5a3:	68 a8 22 11 f0       	push   $0xf01122a8
f010c5a8:	68 91 01 00 00       	push   $0x191
f010c5ad:	68 32 20 11 f0       	push   $0xf0112032
f010c5b2:	e8 a5 3b ff ff       	call   f010015c <_panic>
	}
	cprintf("\b\b\b30%");
f010c5b7:	83 ec 0c             	sub    $0xc,%esp
f010c5ba:	68 db 22 11 f0       	push   $0xf01122db
f010c5bf:	e8 97 9a ff ff       	call   f010605b <cprintf>
f010c5c4:	83 c4 10             	add    $0x10,%esp

	//Allocate after kfree [15%]
	{
		//20 KB
		freeFrames = sys_calculate_free_frames() ;
f010c5c7:	e8 05 cb ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c5cc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c5cf:	e8 49 e1 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c5d4:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[8] = kmalloc(20*kilo);
f010c5d7:	83 ec 0c             	sub    $0xc,%esp
f010c5da:	68 00 50 00 00       	push   $0x5000
f010c5df:	e8 41 e7 ff ff       	call   f010ad25 <kmalloc>
f010c5e4:	83 c4 10             	add    $0x10,%esp
f010c5e7:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[8] != (KERNEL_HEAP_START + 13*Mega + 32*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010c5ed:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f010c5f3:	3d 00 80 d0 f6       	cmp    $0xf6d08000,%eax
f010c5f8:	74 17                	je     f010c611 <test_kfree+0x9ce>
f010c5fa:	83 ec 04             	sub    $0x4,%esp
f010c5fd:	68 10 21 11 f0       	push   $0xf0112110
f010c602:	68 9b 01 00 00       	push   $0x19b
f010c607:	68 32 20 11 f0       	push   $0xf0112032
f010c60c:	e8 4b 3b ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c611:	e8 07 e1 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c616:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c619:	74 17                	je     f010c632 <test_kfree+0x9ef>
f010c61b:	83 ec 04             	sub    $0x4,%esp
f010c61e:	68 44 20 11 f0       	push   $0xf0112044
f010c623:	68 9c 01 00 00       	push   $0x19c
f010c628:	68 32 20 11 f0       	push   $0xf0112032
f010c62d:	e8 2a 3b ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 5) panic("Wrong allocation: pages are not loaded successfully into memory");
f010c632:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010c635:	e8 97 ca ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c63a:	29 c3                	sub    %eax,%ebx
f010c63c:	89 d8                	mov    %ebx,%eax
f010c63e:	83 f8 05             	cmp    $0x5,%eax
f010c641:	74 17                	je     f010c65a <test_kfree+0xa17>
f010c643:	83 ec 04             	sub    $0x4,%esp
f010c646:	68 ac 20 11 f0       	push   $0xf01120ac
f010c64b:	68 9d 01 00 00       	push   $0x19d
f010c650:	68 32 20 11 f0       	push   $0xf0112032
f010c655:	e8 02 3b ff ff       	call   f010015c <_panic>
		lastIndices[8] = (20*kilo)/sizeof(char) - 1;
f010c65a:	c7 45 90 ff 4f 00 00 	movl   $0x4fff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[8];
f010c661:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f010c667:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f010c66a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c671:	eb 0e                	jmp    f010c681 <test_kfree+0xa3e>
		{
			ptr[i] = 8 ;
f010c673:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c676:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c679:	01 d0                	add    %edx,%eax
f010c67b:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (KERNEL_HEAP_START + 13*Mega + 32*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
		if ((freeFrames - sys_calculate_free_frames()) != 5) panic("Wrong allocation: pages are not loaded successfully into memory");
		lastIndices[8] = (20*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f010c67e:	ff 45 f4             	incl   -0xc(%ebp)
f010c681:	8b 45 90             	mov    -0x70(%ebp),%eax
f010c684:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c687:	7f ea                	jg     f010c673 <test_kfree+0xa30>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f010c689:	e8 43 ca ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c68e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c691:	e8 87 e0 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c696:	89 45 cc             	mov    %eax,-0x34(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega);
f010c699:	83 ec 0c             	sub    $0xc,%esp
f010c69c:	68 00 00 10 00       	push   $0x100000
f010c6a1:	e8 7f e6 ff ff       	call   f010ad25 <kmalloc>
f010c6a6:	83 c4 10             	add    $0x10,%esp
f010c6a9:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
		if ((uint32) ptr_allocations[9] != (KERNEL_HEAP_START + 13*Mega + 52*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010c6af:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f010c6b5:	3d 00 d0 d0 f6       	cmp    $0xf6d0d000,%eax
f010c6ba:	74 17                	je     f010c6d3 <test_kfree+0xa90>
f010c6bc:	83 ec 04             	sub    $0x4,%esp
f010c6bf:	68 10 21 11 f0       	push   $0xf0112110
f010c6c4:	68 a9 01 00 00       	push   $0x1a9
f010c6c9:	68 32 20 11 f0       	push   $0xf0112032
f010c6ce:	e8 89 3a ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c6d3:	e8 45 e0 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c6d8:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c6db:	74 17                	je     f010c6f4 <test_kfree+0xab1>
f010c6dd:	83 ec 04             	sub    $0x4,%esp
f010c6e0:	68 44 20 11 f0       	push   $0xf0112044
f010c6e5:	68 aa 01 00 00       	push   $0x1aa
f010c6ea:	68 32 20 11 f0       	push   $0xf0112032
f010c6ef:	e8 68 3a ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 256) panic("Wrong allocation: pages are not loaded successfully into memory");
f010c6f4:	8b 5d d0             	mov    -0x30(%ebp),%ebx
f010c6f7:	e8 d5 c9 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c6fc:	29 c3                	sub    %eax,%ebx
f010c6fe:	89 d8                	mov    %ebx,%eax
f010c700:	3d 00 01 00 00       	cmp    $0x100,%eax
f010c705:	74 17                	je     f010c71e <test_kfree+0xadb>
f010c707:	83 ec 04             	sub    $0x4,%esp
f010c70a:	68 ac 20 11 f0       	push   $0xf01120ac
f010c70f:	68 ab 01 00 00       	push   $0x1ab
f010c714:	68 32 20 11 f0       	push   $0xf0112032
f010c719:	e8 3e 3a ff ff       	call   f010015c <_panic>
		lastIndices[9] = (1*Mega)/sizeof(char) - 1;
f010c71e:	c7 45 94 ff ff 0f 00 	movl   $0xfffff,-0x6c(%ebp)
		ptr = (char*)ptr_allocations[9];
f010c725:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f010c72b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f010c72e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c735:	eb 0e                	jmp    f010c745 <test_kfree+0xb02>
		{
			ptr[i] = 9 ;
f010c737:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c73a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c73d:	01 d0                	add    %edx,%eax
f010c73f:	c6 00 09             	movb   $0x9,(%eax)
		if ((uint32) ptr_allocations[9] != (KERNEL_HEAP_START + 13*Mega + 52*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
		if ((freeFrames - sys_calculate_free_frames()) != 256) panic("Wrong allocation: pages are not loaded successfully into memory");
		lastIndices[9] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f010c742:	ff 45 f4             	incl   -0xc(%ebp)
f010c745:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010c748:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c74b:	7f ea                	jg     f010c737 <test_kfree+0xaf4>
		{
			ptr[i] = 9 ;
		}
	}
	cprintf("\b\b\b45%");
f010c74d:	83 ec 0c             	sub    $0xc,%esp
f010c750:	68 e2 22 11 f0       	push   $0xf01122e2
f010c755:	e8 01 99 ff ff       	call   f010605b <cprintf>
f010c75a:	83 c4 10             	add    $0x10,%esp

	//kfree remaining allocated spaces [15%]
	{
		//kfree 7 KB
		freeFrames = sys_calculate_free_frames() ;
f010c75d:	e8 6f c9 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c762:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c765:	e8 b3 df ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c76a:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[4]);
f010c76d:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f010c773:	83 ec 0c             	sub    $0xc,%esp
f010c776:	50                   	push   %eax
f010c777:	e8 22 e9 ff ff       	call   f010b09e <kfree>
f010c77c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c77f:	e8 99 df ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c784:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c787:	74 17                	je     f010c7a0 <test_kfree+0xb5d>
f010c789:	83 ec 04             	sub    $0x4,%esp
f010c78c:	68 44 20 11 f0       	push   $0xf0112044
f010c791:	68 bb 01 00 00       	push   $0x1bb
f010c796:	68 32 20 11 f0       	push   $0xf0112032
f010c79b:	e8 bc 39 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 2) panic("Wrong kfree: pages in memory are not freed correctly");
f010c7a0:	e8 2c c9 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c7a5:	89 c2                	mov    %eax,%edx
f010c7a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c7aa:	29 c2                	sub    %eax,%edx
f010c7ac:	89 d0                	mov    %edx,%eax
f010c7ae:	83 f8 02             	cmp    $0x2,%eax
f010c7b1:	74 17                	je     f010c7ca <test_kfree+0xb87>
f010c7b3:	83 ec 04             	sub    $0x4,%esp
f010c7b6:	68 50 22 11 f0       	push   $0xf0112250
f010c7bb:	68 bc 01 00 00       	push   $0x1bc
f010c7c0:	68 32 20 11 f0       	push   $0xf0112032
f010c7c5:	e8 92 39 ff ff       	call   f010015c <_panic>

		//kfree 3 MB
		freeFrames = sys_calculate_free_frames() ;
f010c7ca:	e8 02 c9 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c7cf:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c7d2:	e8 46 df ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c7d7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[5]);
f010c7da:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f010c7e0:	83 ec 0c             	sub    $0xc,%esp
f010c7e3:	50                   	push   %eax
f010c7e4:	e8 b5 e8 ff ff       	call   f010b09e <kfree>
f010c7e9:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c7ec:	e8 2c df ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c7f1:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c7f4:	74 17                	je     f010c80d <test_kfree+0xbca>
f010c7f6:	83 ec 04             	sub    $0x4,%esp
f010c7f9:	68 44 20 11 f0       	push   $0xf0112044
f010c7fe:	68 c2 01 00 00       	push   $0x1c2
f010c803:	68 32 20 11 f0       	push   $0xf0112032
f010c808:	e8 4f 39 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3*Mega/4096) panic("Wrong kfree: pages in memory are not freed correctly");
f010c80d:	e8 bf c8 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c812:	89 c2                	mov    %eax,%edx
f010c814:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c817:	29 c2                	sub    %eax,%edx
f010c819:	89 d0                	mov    %edx,%eax
f010c81b:	3d 00 03 00 00       	cmp    $0x300,%eax
f010c820:	74 17                	je     f010c839 <test_kfree+0xbf6>
f010c822:	83 ec 04             	sub    $0x4,%esp
f010c825:	68 50 22 11 f0       	push   $0xf0112250
f010c82a:	68 c3 01 00 00       	push   $0x1c3
f010c82f:	68 32 20 11 f0       	push   $0xf0112032
f010c834:	e8 23 39 ff ff       	call   f010015c <_panic>

		//kfree 1st 2 KB
		freeFrames = sys_calculate_free_frames() ;
f010c839:	e8 93 c8 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c83e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c841:	e8 d7 de ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c846:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[2]);
f010c849:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f010c84f:	83 ec 0c             	sub    $0xc,%esp
f010c852:	50                   	push   %eax
f010c853:	e8 46 e8 ff ff       	call   f010b09e <kfree>
f010c858:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c85b:	e8 bd de ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c860:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c863:	74 17                	je     f010c87c <test_kfree+0xc39>
f010c865:	83 ec 04             	sub    $0x4,%esp
f010c868:	68 44 20 11 f0       	push   $0xf0112044
f010c86d:	68 c9 01 00 00       	push   $0x1c9
f010c872:	68 32 20 11 f0       	push   $0xf0112032
f010c877:	e8 e0 38 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 1) panic("Wrong kfree: pages in memory are not freed correctly");
f010c87c:	e8 50 c8 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c881:	89 c2                	mov    %eax,%edx
f010c883:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c886:	29 c2                	sub    %eax,%edx
f010c888:	89 d0                	mov    %edx,%eax
f010c88a:	83 f8 01             	cmp    $0x1,%eax
f010c88d:	74 17                	je     f010c8a6 <test_kfree+0xc63>
f010c88f:	83 ec 04             	sub    $0x4,%esp
f010c892:	68 50 22 11 f0       	push   $0xf0112250
f010c897:	68 ca 01 00 00       	push   $0x1ca
f010c89c:	68 32 20 11 f0       	push   $0xf0112032
f010c8a1:	e8 b6 38 ff ff       	call   f010015c <_panic>

		//kfree 2nd 2 KB
		freeFrames = sys_calculate_free_frames() ;
f010c8a6:	e8 26 c8 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c8ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c8ae:	e8 6a de ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c8b3:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[3]);
f010c8b6:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f010c8bc:	83 ec 0c             	sub    $0xc,%esp
f010c8bf:	50                   	push   %eax
f010c8c0:	e8 d9 e7 ff ff       	call   f010b09e <kfree>
f010c8c5:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c8c8:	e8 50 de ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c8cd:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c8d0:	74 17                	je     f010c8e9 <test_kfree+0xca6>
f010c8d2:	83 ec 04             	sub    $0x4,%esp
f010c8d5:	68 44 20 11 f0       	push   $0xf0112044
f010c8da:	68 d0 01 00 00       	push   $0x1d0
f010c8df:	68 32 20 11 f0       	push   $0xf0112032
f010c8e4:	e8 73 38 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 1) panic("Wrong kfree: pages in memory are not freed correctly");
f010c8e9:	e8 e3 c7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c8ee:	89 c2                	mov    %eax,%edx
f010c8f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c8f3:	29 c2                	sub    %eax,%edx
f010c8f5:	89 d0                	mov    %edx,%eax
f010c8f7:	83 f8 01             	cmp    $0x1,%eax
f010c8fa:	74 17                	je     f010c913 <test_kfree+0xcd0>
f010c8fc:	83 ec 04             	sub    $0x4,%esp
f010c8ff:	68 50 22 11 f0       	push   $0xf0112250
f010c904:	68 d1 01 00 00       	push   $0x1d1
f010c909:	68 32 20 11 f0       	push   $0xf0112032
f010c90e:	e8 49 38 ff ff       	call   f010015c <_panic>

		//kfree 14 KB
		freeFrames = sys_calculate_free_frames() ;
f010c913:	e8 b9 c7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c918:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c91b:	e8 fd dd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c920:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[7]);
f010c923:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f010c929:	83 ec 0c             	sub    $0xc,%esp
f010c92c:	50                   	push   %eax
f010c92d:	e8 6c e7 ff ff       	call   f010b09e <kfree>
f010c932:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c935:	e8 e3 dd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c93a:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c93d:	74 17                	je     f010c956 <test_kfree+0xd13>
f010c93f:	83 ec 04             	sub    $0x4,%esp
f010c942:	68 44 20 11 f0       	push   $0xf0112044
f010c947:	68 d7 01 00 00       	push   $0x1d7
f010c94c:	68 32 20 11 f0       	push   $0xf0112032
f010c951:	e8 06 38 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 4) panic("Wrong kfree: pages in memory are not freed correctly");
f010c956:	e8 76 c7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c95b:	89 c2                	mov    %eax,%edx
f010c95d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c960:	29 c2                	sub    %eax,%edx
f010c962:	89 d0                	mov    %edx,%eax
f010c964:	83 f8 04             	cmp    $0x4,%eax
f010c967:	74 17                	je     f010c980 <test_kfree+0xd3d>
f010c969:	83 ec 04             	sub    $0x4,%esp
f010c96c:	68 50 22 11 f0       	push   $0xf0112250
f010c971:	68 d8 01 00 00       	push   $0x1d8
f010c976:	68 32 20 11 f0       	push   $0xf0112032
f010c97b:	e8 dc 37 ff ff       	call   f010015c <_panic>

		//kfree 20 KB
		freeFrames = sys_calculate_free_frames() ;
f010c980:	e8 4c c7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c985:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c988:	e8 90 dd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c98d:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[8]);
f010c990:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f010c996:	83 ec 0c             	sub    $0xc,%esp
f010c999:	50                   	push   %eax
f010c99a:	e8 ff e6 ff ff       	call   f010b09e <kfree>
f010c99f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010c9a2:	e8 76 dd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c9a7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010c9aa:	74 17                	je     f010c9c3 <test_kfree+0xd80>
f010c9ac:	83 ec 04             	sub    $0x4,%esp
f010c9af:	68 44 20 11 f0       	push   $0xf0112044
f010c9b4:	68 de 01 00 00       	push   $0x1de
f010c9b9:	68 32 20 11 f0       	push   $0xf0112032
f010c9be:	e8 99 37 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 5) panic("Wrong kfree: pages in memory are not freed correctly");
f010c9c3:	e8 09 c7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c9c8:	89 c2                	mov    %eax,%edx
f010c9ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c9cd:	29 c2                	sub    %eax,%edx
f010c9cf:	89 d0                	mov    %edx,%eax
f010c9d1:	83 f8 05             	cmp    $0x5,%eax
f010c9d4:	74 17                	je     f010c9ed <test_kfree+0xdaa>
f010c9d6:	83 ec 04             	sub    $0x4,%esp
f010c9d9:	68 50 22 11 f0       	push   $0xf0112250
f010c9de:	68 df 01 00 00       	push   $0x1df
f010c9e3:	68 32 20 11 f0       	push   $0xf0112032
f010c9e8:	e8 6f 37 ff ff       	call   f010015c <_panic>

		//kfree 1 MB
		freeFrames = sys_calculate_free_frames() ;
f010c9ed:	e8 df c6 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010c9f2:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010c9f5:	e8 23 dd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010c9fa:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[9]);
f010c9fd:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f010ca03:	83 ec 0c             	sub    $0xc,%esp
f010ca06:	50                   	push   %eax
f010ca07:	e8 92 e6 ff ff       	call   f010b09e <kfree>
f010ca0c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010ca0f:	e8 09 dd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010ca14:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010ca17:	74 17                	je     f010ca30 <test_kfree+0xded>
f010ca19:	83 ec 04             	sub    $0x4,%esp
f010ca1c:	68 44 20 11 f0       	push   $0xf0112044
f010ca21:	68 e5 01 00 00       	push   $0x1e5
f010ca26:	68 32 20 11 f0       	push   $0xf0112032
f010ca2b:	e8 2c 37 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 256) panic("Wrong kfree: pages in memory are not freed correctly");
f010ca30:	e8 9c c6 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010ca35:	89 c2                	mov    %eax,%edx
f010ca37:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ca3a:	29 c2                	sub    %eax,%edx
f010ca3c:	89 d0                	mov    %edx,%eax
f010ca3e:	3d 00 01 00 00       	cmp    $0x100,%eax
f010ca43:	74 17                	je     f010ca5c <test_kfree+0xe19>
f010ca45:	83 ec 04             	sub    $0x4,%esp
f010ca48:	68 50 22 11 f0       	push   $0xf0112250
f010ca4d:	68 e6 01 00 00       	push   $0x1e6
f010ca52:	68 32 20 11 f0       	push   $0xf0112032
f010ca57:	e8 00 37 ff ff       	call   f010015c <_panic>

		if(start_freeFrames != (sys_calculate_free_frames())) {panic("Wrong kfree: not all pages removed correctly at end");}
f010ca5c:	e8 70 c6 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010ca61:	89 c2                	mov    %eax,%edx
f010ca63:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ca66:	39 c2                	cmp    %eax,%edx
f010ca68:	74 17                	je     f010ca81 <test_kfree+0xe3e>
f010ca6a:	83 ec 04             	sub    $0x4,%esp
f010ca6d:	68 ec 22 11 f0       	push   $0xf01122ec
f010ca72:	68 e8 01 00 00       	push   $0x1e8
f010ca77:	68 32 20 11 f0       	push   $0xf0112032
f010ca7c:	e8 db 36 ff ff       	call   f010015c <_panic>
	}
	cprintf("\b\b\b60%");
f010ca81:	83 ec 0c             	sub    $0xc,%esp
f010ca84:	68 20 23 11 f0       	push   $0xf0112320
f010ca89:	e8 cd 95 ff ff       	call   f010605b <cprintf>
f010ca8e:	83 c4 10             	add    $0x10,%esp

	//Check memory access after kfree [15%]
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f010ca91:	83 ec 0c             	sub    $0xc,%esp
f010ca94:	6a 03                	push   $0x3
f010ca96:	e8 59 c9 ff ff       	call   f01093f4 <sys_bypassPageFault>
f010ca9b:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i < 10; ++i)
f010ca9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010caa5:	e9 82 00 00 00       	jmp    f010cb2c <test_kfree+0xee9>
		{
			ptr = (char *) ptr_allocations[i];
f010caaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010caad:	8b 84 85 d0 fe ff ff 	mov    -0x130(%ebp,%eax,4),%eax
f010cab4:	89 45 c8             	mov    %eax,-0x38(%ebp)
			ptr[0] = 10;
f010cab7:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010caba:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0])) panic("kfree: successful access to freed space!! it should not be succeeded");
f010cabd:	e8 20 c9 ff ff       	call   f01093e2 <sys_rcr2>
f010cac2:	89 c2                	mov    %eax,%edx
f010cac4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010cac7:	39 c2                	cmp    %eax,%edx
f010cac9:	74 17                	je     f010cae2 <test_kfree+0xe9f>
f010cacb:	83 ec 04             	sub    $0x4,%esp
f010cace:	68 28 23 11 f0       	push   $0xf0112328
f010cad3:	68 f7 01 00 00       	push   $0x1f7
f010cad8:	68 32 20 11 f0       	push   $0xf0112032
f010cadd:	e8 7a 36 ff ff       	call   f010015c <_panic>
			ptr[lastIndices[i]] = 10;
f010cae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cae5:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010caec:	89 c2                	mov    %eax,%edx
f010caee:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010caf1:	01 d0                	add    %edx,%eax
f010caf3:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]])) panic("kfree: successful access to freed space!! it should not be succeeded");
f010caf6:	e8 e7 c8 ff ff       	call   f01093e2 <sys_rcr2>
f010cafb:	89 c2                	mov    %eax,%edx
f010cafd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb00:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010cb07:	89 c1                	mov    %eax,%ecx
f010cb09:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010cb0c:	01 c8                	add    %ecx,%eax
f010cb0e:	39 c2                	cmp    %eax,%edx
f010cb10:	74 17                	je     f010cb29 <test_kfree+0xee6>
f010cb12:	83 ec 04             	sub    $0x4,%esp
f010cb15:	68 28 23 11 f0       	push   $0xf0112328
f010cb1a:	68 f9 01 00 00       	push   $0x1f9
f010cb1f:	68 32 20 11 f0       	push   $0xf0112032
f010cb24:	e8 33 36 ff ff       	call   f010015c <_panic>
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i < 10; ++i)
f010cb29:	ff 45 f4             	incl   -0xc(%ebp)
f010cb2c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f010cb30:	0f 8e 74 ff ff ff    	jle    f010caaa <test_kfree+0xe67>
			ptr[lastIndices[i]] = 10;
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]])) panic("kfree: successful access to freed space!! it should not be succeeded");
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f010cb36:	83 ec 0c             	sub    $0xc,%esp
f010cb39:	6a 00                	push   $0x0
f010cb3b:	e8 b4 c8 ff ff       	call   f01093f4 <sys_bypassPageFault>
f010cb40:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\b\b\b75%");
f010cb43:	83 ec 0c             	sub    $0xc,%esp
f010cb46:	68 6d 23 11 f0       	push   $0xf011236d
f010cb4b:	e8 0b 95 ff ff       	call   f010605b <cprintf>
f010cb50:	83 c4 10             	add    $0x10,%esp

	//kfree non-exist item [10%]
	{
		//kfree 2 MB
		freeFrames = sys_calculate_free_frames() ;
f010cb53:	e8 79 c5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cb58:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010cb5b:	e8 bd db ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cb60:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[0]);
f010cb63:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f010cb69:	83 ec 0c             	sub    $0xc,%esp
f010cb6c:	50                   	push   %eax
f010cb6d:	e8 2c e5 ff ff       	call   f010b09e <kfree>
f010cb72:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010cb75:	e8 a3 db ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cb7a:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010cb7d:	74 17                	je     f010cb96 <test_kfree+0xf53>
f010cb7f:	83 ec 04             	sub    $0x4,%esp
f010cb82:	68 44 20 11 f0       	push   $0xf0112044
f010cb87:	68 07 02 00 00       	push   $0x207
f010cb8c:	68 32 20 11 f0       	push   $0xf0112032
f010cb91:	e8 c6 35 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Wrong kfree: attempt to kfree a non-existing ptr. It should do nothing");
f010cb96:	e8 36 c5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cb9b:	89 c2                	mov    %eax,%edx
f010cb9d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010cba0:	39 c2                	cmp    %eax,%edx
f010cba2:	74 17                	je     f010cbbb <test_kfree+0xf78>
f010cba4:	83 ec 04             	sub    $0x4,%esp
f010cba7:	68 74 23 11 f0       	push   $0xf0112374
f010cbac:	68 08 02 00 00       	push   $0x208
f010cbb1:	68 32 20 11 f0       	push   $0xf0112032
f010cbb6:	e8 a1 35 ff ff       	call   f010015c <_panic>

		//kfree 2 KB
		freeFrames = sys_calculate_free_frames() ;
f010cbbb:	e8 11 c5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cbc0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010cbc3:	e8 55 db ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cbc8:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[2]);
f010cbcb:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f010cbd1:	83 ec 0c             	sub    $0xc,%esp
f010cbd4:	50                   	push   %eax
f010cbd5:	e8 c4 e4 ff ff       	call   f010b09e <kfree>
f010cbda:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010cbdd:	e8 3b db ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cbe2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010cbe5:	74 17                	je     f010cbfe <test_kfree+0xfbb>
f010cbe7:	83 ec 04             	sub    $0x4,%esp
f010cbea:	68 44 20 11 f0       	push   $0xf0112044
f010cbef:	68 0e 02 00 00       	push   $0x20e
f010cbf4:	68 32 20 11 f0       	push   $0xf0112032
f010cbf9:	e8 5e 35 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Wrong kfree: attempt to kfree a non-existing ptr. It should do nothing");
f010cbfe:	e8 ce c4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cc03:	89 c2                	mov    %eax,%edx
f010cc05:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010cc08:	39 c2                	cmp    %eax,%edx
f010cc0a:	74 17                	je     f010cc23 <test_kfree+0xfe0>
f010cc0c:	83 ec 04             	sub    $0x4,%esp
f010cc0f:	68 74 23 11 f0       	push   $0xf0112374
f010cc14:	68 0f 02 00 00       	push   $0x20f
f010cc19:	68 32 20 11 f0       	push   $0xf0112032
f010cc1e:	e8 39 35 ff ff       	call   f010015c <_panic>

		//kfree 20 KB
		freeFrames = sys_calculate_free_frames() ;
f010cc23:	e8 a9 c4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cc28:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010cc2b:	e8 ed da ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cc30:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[8]);
f010cc33:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f010cc39:	83 ec 0c             	sub    $0xc,%esp
f010cc3c:	50                   	push   %eax
f010cc3d:	e8 5c e4 ff ff       	call   f010b09e <kfree>
f010cc42:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010cc45:	e8 d3 da ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cc4a:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010cc4d:	74 17                	je     f010cc66 <test_kfree+0x1023>
f010cc4f:	83 ec 04             	sub    $0x4,%esp
f010cc52:	68 44 20 11 f0       	push   $0xf0112044
f010cc57:	68 15 02 00 00       	push   $0x215
f010cc5c:	68 32 20 11 f0       	push   $0xf0112032
f010cc61:	e8 f6 34 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Wrong kfree: attempt to kfree a non-existing ptr. It should do nothing");
f010cc66:	e8 66 c4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cc6b:	89 c2                	mov    %eax,%edx
f010cc6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010cc70:	39 c2                	cmp    %eax,%edx
f010cc72:	74 17                	je     f010cc8b <test_kfree+0x1048>
f010cc74:	83 ec 04             	sub    $0x4,%esp
f010cc77:	68 74 23 11 f0       	push   $0xf0112374
f010cc7c:	68 16 02 00 00       	push   $0x216
f010cc81:	68 32 20 11 f0       	push   $0xf0112032
f010cc86:	e8 d1 34 ff ff       	call   f010015c <_panic>

		//kfree 1 MB
		freeFrames = sys_calculate_free_frames() ;
f010cc8b:	e8 41 c4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cc90:	89 45 d0             	mov    %eax,-0x30(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010cc93:	e8 85 da ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cc98:	89 45 cc             	mov    %eax,-0x34(%ebp)
		kfree(ptr_allocations[9]);
f010cc9b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f010cca1:	83 ec 0c             	sub    $0xc,%esp
f010cca4:	50                   	push   %eax
f010cca5:	e8 f4 e3 ff ff       	call   f010b09e <kfree>
f010ccaa:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010ccad:	e8 6b da ff ff       	call   f010a71d <pf_calculate_free_frames>
f010ccb2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010ccb5:	74 17                	je     f010ccce <test_kfree+0x108b>
f010ccb7:	83 ec 04             	sub    $0x4,%esp
f010ccba:	68 44 20 11 f0       	push   $0xf0112044
f010ccbf:	68 1c 02 00 00       	push   $0x21c
f010ccc4:	68 32 20 11 f0       	push   $0xf0112032
f010ccc9:	e8 8e 34 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Wrong kfree: attempt to kfree a non-existing ptr. It should do nothing");
f010ccce:	e8 fe c3 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010ccd3:	89 c2                	mov    %eax,%edx
f010ccd5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ccd8:	39 c2                	cmp    %eax,%edx
f010ccda:	74 17                	je     f010ccf3 <test_kfree+0x10b0>
f010ccdc:	83 ec 04             	sub    $0x4,%esp
f010ccdf:	68 74 23 11 f0       	push   $0xf0112374
f010cce4:	68 1d 02 00 00       	push   $0x21d
f010cce9:	68 32 20 11 f0       	push   $0xf0112032
f010ccee:	e8 69 34 ff ff       	call   f010015c <_panic>

	}
	cprintf("\b\b\b85%");
f010ccf3:	83 ec 0c             	sub    $0xc,%esp
f010ccf6:	68 bb 23 11 f0       	push   $0xf01123bb
f010ccfb:	e8 5b 93 ff ff       	call   f010605b <cprintf>
f010cd00:	83 c4 10             	add    $0x10,%esp

	//check tables	[15%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f010cd03:	c7 45 e8 00 00 00 f6 	movl   $0xf6000000,-0x18(%ebp)
f010cd0a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010cd11:	eb 4a                	jmp    f010cd5d <test_kfree+0x111a>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)(uint32)va, &ptr_table);
f010cd13:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010cd16:	89 c1                	mov    %eax,%ecx
f010cd18:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010cd1d:	83 ec 04             	sub    $0x4,%esp
f010cd20:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
f010cd26:	52                   	push   %edx
f010cd27:	51                   	push   %ecx
f010cd28:	50                   	push   %eax
f010cd29:	e8 e2 5f ff ff       	call   f0102d10 <get_page_table>
f010cd2e:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f010cd31:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f010cd37:	85 c0                	test   %eax,%eax
f010cd39:	75 17                	jne    f010cd52 <test_kfree+0x110f>
			{
				panic("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree");
f010cd3b:	83 ec 04             	sub    $0x4,%esp
f010cd3e:	68 c4 23 11 f0       	push   $0xf01123c4
f010cd43:	68 2b 02 00 00       	push   $0x22b
f010cd48:	68 32 20 11 f0       	push   $0xf0112032
f010cd4d:	e8 0a 34 ff ff       	call   f010015c <_panic>
	cprintf("\b\b\b85%");

	//check tables	[15%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f010cd52:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f010cd59:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f010cd5d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010cd61:	78 b0                	js     f010cd13 <test_kfree+0x10d0>
f010cd63:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010cd67:	7f 09                	jg     f010cd72 <test_kfree+0x112f>
f010cd69:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f010cd70:	76 a1                	jbe    f010cd13 <test_kfree+0x10d0>
			{
				panic("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree");
			}
		}
	}
	cprintf("\b\b\b100%\n");
f010cd72:	83 ec 0c             	sub    $0xc,%esp
f010cd75:	68 0e 22 11 f0       	push   $0xf011220e
f010cd7a:	e8 dc 92 ff ff       	call   f010605b <cprintf>
f010cd7f:	83 c4 10             	add    $0x10,%esp



	cprintf("Congratulations!! test kfree completed successfully.\n");
f010cd82:	83 ec 0c             	sub    $0xc,%esp
f010cd85:	68 2c 24 11 f0       	push   $0xf011242c
f010cd8a:	e8 cc 92 ff ff       	call   f010605b <cprintf>
f010cd8f:	83 c4 10             	add    $0x10,%esp

	return 1;
f010cd92:	b8 01 00 00 00       	mov    $0x1,%eax

}
f010cd97:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010cd9a:	5b                   	pop    %ebx
f010cd9b:	5f                   	pop    %edi
f010cd9c:	5d                   	pop    %ebp
f010cd9d:	c3                   	ret    

f010cd9e <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f010cd9e:	55                   	push   %ebp
f010cd9f:	89 e5                	mov    %esp,%ebp
f010cda1:	57                   	push   %edi
f010cda2:	53                   	push   %ebx
f010cda3:	81 ec 60 41 02 00    	sub    $0x24160,%esp
	char minByte = 1<<7;
f010cda9:	c6 45 cf 80          	movb   $0x80,-0x31(%ebp)
	char maxByte = 0x7F;
f010cdad:	c6 45 ce 7f          	movb   $0x7f,-0x32(%ebp)
	short minShort = 1<<15 ;
f010cdb1:	66 c7 45 cc 00 80    	movw   $0x8000,-0x34(%ebp)
	short maxShort = 0x7FFF;
f010cdb7:	66 c7 45 ca ff 7f    	movw   $0x7fff,-0x36(%ebp)
	int minInt = 1<<31 ;
f010cdbd:	c7 45 c4 00 00 00 80 	movl   $0x80000000,-0x3c(%ebp)
	int maxInt = 0x7FFFFFFF;
f010cdc4:	c7 45 c0 ff ff ff 7f 	movl   $0x7fffffff,-0x40(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f010cdcb:	e8 01 c3 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cdd0:	89 45 bc             	mov    %eax,-0x44(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f010cdd3:	8d 95 44 ff ff ff    	lea    -0xbc(%ebp),%edx
f010cdd9:	b9 14 00 00 00       	mov    $0x14,%ecx
f010cdde:	b8 00 00 00 00       	mov    $0x0,%eax
f010cde3:	89 d7                	mov    %edx,%edi
f010cde5:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f010cde7:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
f010cded:	b9 14 00 00 00       	mov    $0x14,%ecx
f010cdf2:	b8 00 00 00 00       	mov    $0x0,%eax
f010cdf7:	89 d7                	mov    %edx,%edi
f010cdf9:	f3 ab                	rep stos %eax,%es:(%edi)
	void* ptr_allocations[20] = {0};
f010cdfb:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
f010ce01:	b9 14 00 00 00       	mov    $0x14,%ecx
f010ce06:	b8 00 00 00 00       	mov    $0x0,%eax
f010ce0b:	89 d7                	mov    %edx,%edi
f010ce0d:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010ce0f:	e8 bd c2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010ce14:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010ce17:	e8 01 d9 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010ce1c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f010ce1f:	83 ec 0c             	sub    $0xc,%esp
f010ce22:	68 00 fc 1f 00       	push   $0x1ffc00
f010ce27:	e8 f9 de ff ff       	call   f010ad25 <kmalloc>
f010ce2c:	83 c4 10             	add    $0x10,%esp
f010ce2f:	89 85 a4 fe ff ff    	mov    %eax,-0x15c(%ebp)
		if ((uint32) ptr_allocations[0] !=  (KERNEL_HEAP_START)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010ce35:	8b 85 a4 fe ff ff    	mov    -0x15c(%ebp),%eax
f010ce3b:	3d 00 00 00 f6       	cmp    $0xf6000000,%eax
f010ce40:	74 17                	je     f010ce59 <test_kheap_phys_addr+0xbb>
f010ce42:	83 ec 04             	sub    $0x4,%esp
f010ce45:	68 10 21 11 f0       	push   $0xf0112110
f010ce4a:	68 54 02 00 00       	push   $0x254
f010ce4f:	68 32 20 11 f0       	push   $0xf0112032
f010ce54:	e8 03 33 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010ce59:	e8 bf d8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010ce5e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010ce61:	74 17                	je     f010ce7a <test_kheap_phys_addr+0xdc>
f010ce63:	83 ec 04             	sub    $0x4,%esp
f010ce66:	68 44 20 11 f0       	push   $0xf0112044
f010ce6b:	68 55 02 00 00       	push   $0x255
f010ce70:	68 32 20 11 f0       	push   $0xf0112032
f010ce75:	e8 e2 32 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010ce7a:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010ce7d:	e8 4f c2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010ce82:	29 c3                	sub    %eax,%ebx
f010ce84:	89 d8                	mov    %ebx,%eax
f010ce86:	3d 00 02 00 00       	cmp    $0x200,%eax
f010ce8b:	74 17                	je     f010cea4 <test_kheap_phys_addr+0x106>
f010ce8d:	83 ec 04             	sub    $0x4,%esp
f010ce90:	68 ac 20 11 f0       	push   $0xf01120ac
f010ce95:	68 56 02 00 00       	push   $0x256
f010ce9a:	68 32 20 11 f0       	push   $0xf0112032
f010ce9f:	e8 b8 32 ff ff       	call   f010015c <_panic>

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010cea4:	e8 28 c2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cea9:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010ceac:	e8 6c d8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010ceb1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f010ceb4:	83 ec 0c             	sub    $0xc,%esp
f010ceb7:	68 00 fc 1f 00       	push   $0x1ffc00
f010cebc:	e8 64 de ff ff       	call   f010ad25 <kmalloc>
f010cec1:	83 c4 10             	add    $0x10,%esp
f010cec4:	89 85 a8 fe ff ff    	mov    %eax,-0x158(%ebp)
		if ((uint32) ptr_allocations[1] != (KERNEL_HEAP_START + 2*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010ceca:	8b 85 a8 fe ff ff    	mov    -0x158(%ebp),%eax
f010ced0:	3d 00 00 20 f6       	cmp    $0xf6200000,%eax
f010ced5:	74 17                	je     f010ceee <test_kheap_phys_addr+0x150>
f010ced7:	83 ec 04             	sub    $0x4,%esp
f010ceda:	68 10 21 11 f0       	push   $0xf0112110
f010cedf:	68 5c 02 00 00       	push   $0x25c
f010cee4:	68 32 20 11 f0       	push   $0xf0112032
f010cee9:	e8 6e 32 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010ceee:	e8 2a d8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cef3:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010cef6:	74 17                	je     f010cf0f <test_kheap_phys_addr+0x171>
f010cef8:	83 ec 04             	sub    $0x4,%esp
f010cefb:	68 44 20 11 f0       	push   $0xf0112044
f010cf00:	68 5d 02 00 00       	push   $0x25d
f010cf05:	68 32 20 11 f0       	push   $0xf0112032
f010cf0a:	e8 4d 32 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010cf0f:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010cf12:	e8 ba c1 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cf17:	29 c3                	sub    %eax,%ebx
f010cf19:	89 d8                	mov    %ebx,%eax
f010cf1b:	3d 00 02 00 00       	cmp    $0x200,%eax
f010cf20:	74 17                	je     f010cf39 <test_kheap_phys_addr+0x19b>
f010cf22:	83 ec 04             	sub    $0x4,%esp
f010cf25:	68 ac 20 11 f0       	push   $0xf01120ac
f010cf2a:	68 5e 02 00 00       	push   $0x25e
f010cf2f:	68 32 20 11 f0       	push   $0xf0112032
f010cf34:	e8 23 32 ff ff       	call   f010015c <_panic>

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010cf39:	e8 93 c1 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cf3e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010cf41:	e8 d7 d7 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cf46:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo);
f010cf49:	83 ec 0c             	sub    $0xc,%esp
f010cf4c:	68 00 08 00 00       	push   $0x800
f010cf51:	e8 cf dd ff ff       	call   f010ad25 <kmalloc>
f010cf56:	83 c4 10             	add    $0x10,%esp
f010cf59:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
		if ((uint32) ptr_allocations[2] != (KERNEL_HEAP_START + 4*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010cf5f:	8b 85 ac fe ff ff    	mov    -0x154(%ebp),%eax
f010cf65:	3d 00 00 40 f6       	cmp    $0xf6400000,%eax
f010cf6a:	74 17                	je     f010cf83 <test_kheap_phys_addr+0x1e5>
f010cf6c:	83 ec 04             	sub    $0x4,%esp
f010cf6f:	68 10 21 11 f0       	push   $0xf0112110
f010cf74:	68 64 02 00 00       	push   $0x264
f010cf79:	68 32 20 11 f0       	push   $0xf0112032
f010cf7e:	e8 d9 31 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010cf83:	e8 95 d7 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cf88:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010cf8b:	74 17                	je     f010cfa4 <test_kheap_phys_addr+0x206>
f010cf8d:	83 ec 04             	sub    $0x4,%esp
f010cf90:	68 44 20 11 f0       	push   $0xf0112044
f010cf95:	68 65 02 00 00       	push   $0x265
f010cf9a:	68 32 20 11 f0       	push   $0xf0112032
f010cf9f:	e8 b8 31 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010cfa4:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010cfa7:	e8 25 c1 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cfac:	29 c3                	sub    %eax,%ebx
f010cfae:	89 d8                	mov    %ebx,%eax
f010cfb0:	83 f8 01             	cmp    $0x1,%eax
f010cfb3:	74 17                	je     f010cfcc <test_kheap_phys_addr+0x22e>
f010cfb5:	83 ec 04             	sub    $0x4,%esp
f010cfb8:	68 ac 20 11 f0       	push   $0xf01120ac
f010cfbd:	68 66 02 00 00       	push   $0x266
f010cfc2:	68 32 20 11 f0       	push   $0xf0112032
f010cfc7:	e8 90 31 ff ff       	call   f010015c <_panic>

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010cfcc:	e8 00 c1 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010cfd1:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010cfd4:	e8 44 d7 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010cfd9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f010cfdc:	83 ec 0c             	sub    $0xc,%esp
f010cfdf:	68 00 08 00 00       	push   $0x800
f010cfe4:	e8 3c dd ff ff       	call   f010ad25 <kmalloc>
f010cfe9:	83 c4 10             	add    $0x10,%esp
f010cfec:	89 85 b0 fe ff ff    	mov    %eax,-0x150(%ebp)
		if ((uint32) ptr_allocations[3] != (KERNEL_HEAP_START + 4*Mega + 4*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010cff2:	8b 85 b0 fe ff ff    	mov    -0x150(%ebp),%eax
f010cff8:	3d 00 10 40 f6       	cmp    $0xf6401000,%eax
f010cffd:	74 17                	je     f010d016 <test_kheap_phys_addr+0x278>
f010cfff:	83 ec 04             	sub    $0x4,%esp
f010d002:	68 10 21 11 f0       	push   $0xf0112110
f010d007:	68 6c 02 00 00       	push   $0x26c
f010d00c:	68 32 20 11 f0       	push   $0xf0112032
f010d011:	e8 46 31 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d016:	e8 02 d7 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d01b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010d01e:	74 17                	je     f010d037 <test_kheap_phys_addr+0x299>
f010d020:	83 ec 04             	sub    $0x4,%esp
f010d023:	68 44 20 11 f0       	push   $0xf0112044
f010d028:	68 6d 02 00 00       	push   $0x26d
f010d02d:	68 32 20 11 f0       	push   $0xf0112032
f010d032:	e8 25 31 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d037:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010d03a:	e8 92 c0 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d03f:	29 c3                	sub    %eax,%ebx
f010d041:	89 d8                	mov    %ebx,%eax
f010d043:	83 f8 01             	cmp    $0x1,%eax
f010d046:	74 17                	je     f010d05f <test_kheap_phys_addr+0x2c1>
f010d048:	83 ec 04             	sub    $0x4,%esp
f010d04b:	68 ac 20 11 f0       	push   $0xf01120ac
f010d050:	68 6e 02 00 00       	push   $0x26e
f010d055:	68 32 20 11 f0       	push   $0xf0112032
f010d05a:	e8 fd 30 ff ff       	call   f010015c <_panic>

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f010d05f:	e8 6d c0 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d064:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d067:	e8 b1 d6 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d06c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f010d06f:	83 ec 0c             	sub    $0xc,%esp
f010d072:	68 00 1c 00 00       	push   $0x1c00
f010d077:	e8 a9 dc ff ff       	call   f010ad25 <kmalloc>
f010d07c:	83 c4 10             	add    $0x10,%esp
f010d07f:	89 85 b4 fe ff ff    	mov    %eax,-0x14c(%ebp)
		if ((uint32) ptr_allocations[4] != (KERNEL_HEAP_START + 4*Mega + 8*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d085:	8b 85 b4 fe ff ff    	mov    -0x14c(%ebp),%eax
f010d08b:	3d 00 20 40 f6       	cmp    $0xf6402000,%eax
f010d090:	74 17                	je     f010d0a9 <test_kheap_phys_addr+0x30b>
f010d092:	83 ec 04             	sub    $0x4,%esp
f010d095:	68 10 21 11 f0       	push   $0xf0112110
f010d09a:	68 74 02 00 00       	push   $0x274
f010d09f:	68 32 20 11 f0       	push   $0xf0112032
f010d0a4:	e8 b3 30 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d0a9:	e8 6f d6 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d0ae:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010d0b1:	74 17                	je     f010d0ca <test_kheap_phys_addr+0x32c>
f010d0b3:	83 ec 04             	sub    $0x4,%esp
f010d0b6:	68 44 20 11 f0       	push   $0xf0112044
f010d0bb:	68 75 02 00 00       	push   $0x275
f010d0c0:	68 32 20 11 f0       	push   $0xf0112032
f010d0c5:	e8 92 30 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 2) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d0ca:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010d0cd:	e8 ff bf ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d0d2:	29 c3                	sub    %eax,%ebx
f010d0d4:	89 d8                	mov    %ebx,%eax
f010d0d6:	83 f8 02             	cmp    $0x2,%eax
f010d0d9:	74 17                	je     f010d0f2 <test_kheap_phys_addr+0x354>
f010d0db:	83 ec 04             	sub    $0x4,%esp
f010d0de:	68 ac 20 11 f0       	push   $0xf01120ac
f010d0e3:	68 76 02 00 00       	push   $0x276
f010d0e8:	68 32 20 11 f0       	push   $0xf0112032
f010d0ed:	e8 6a 30 ff ff       	call   f010015c <_panic>

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f010d0f2:	e8 da bf ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d0f7:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d0fa:	e8 1e d6 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d0ff:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f010d102:	83 ec 0c             	sub    $0xc,%esp
f010d105:	68 00 fc 2f 00       	push   $0x2ffc00
f010d10a:	e8 16 dc ff ff       	call   f010ad25 <kmalloc>
f010d10f:	83 c4 10             	add    $0x10,%esp
f010d112:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
		if ((uint32) ptr_allocations[5] != (KERNEL_HEAP_START + 4*Mega + 16*kilo) ) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d118:	8b 85 b8 fe ff ff    	mov    -0x148(%ebp),%eax
f010d11e:	3d 00 40 40 f6       	cmp    $0xf6404000,%eax
f010d123:	74 17                	je     f010d13c <test_kheap_phys_addr+0x39e>
f010d125:	83 ec 04             	sub    $0x4,%esp
f010d128:	68 10 21 11 f0       	push   $0xf0112110
f010d12d:	68 7c 02 00 00       	push   $0x27c
f010d132:	68 32 20 11 f0       	push   $0xf0112032
f010d137:	e8 20 30 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d13c:	e8 dc d5 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d141:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010d144:	74 17                	je     f010d15d <test_kheap_phys_addr+0x3bf>
f010d146:	83 ec 04             	sub    $0x4,%esp
f010d149:	68 44 20 11 f0       	push   $0xf0112044
f010d14e:	68 7d 02 00 00       	push   $0x27d
f010d153:	68 32 20 11 f0       	push   $0xf0112032
f010d158:	e8 ff 2f ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 768) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d15d:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010d160:	e8 6c bf ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d165:	29 c3                	sub    %eax,%ebx
f010d167:	89 d8                	mov    %ebx,%eax
f010d169:	3d 00 03 00 00       	cmp    $0x300,%eax
f010d16e:	74 17                	je     f010d187 <test_kheap_phys_addr+0x3e9>
f010d170:	83 ec 04             	sub    $0x4,%esp
f010d173:	68 ac 20 11 f0       	push   $0xf01120ac
f010d178:	68 7e 02 00 00       	push   $0x27e
f010d17d:	68 32 20 11 f0       	push   $0xf0112032
f010d182:	e8 d5 2f ff ff       	call   f010015c <_panic>

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f010d187:	e8 45 bf ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d18c:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d18f:	e8 89 d5 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d194:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f010d197:	83 ec 0c             	sub    $0xc,%esp
f010d19a:	68 00 fc 5f 00       	push   $0x5ffc00
f010d19f:	e8 81 db ff ff       	call   f010ad25 <kmalloc>
f010d1a4:	83 c4 10             	add    $0x10,%esp
f010d1a7:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)
		if ((uint32) ptr_allocations[6] != (KERNEL_HEAP_START + 7*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d1ad:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
f010d1b3:	3d 00 40 70 f6       	cmp    $0xf6704000,%eax
f010d1b8:	74 17                	je     f010d1d1 <test_kheap_phys_addr+0x433>
f010d1ba:	83 ec 04             	sub    $0x4,%esp
f010d1bd:	68 10 21 11 f0       	push   $0xf0112110
f010d1c2:	68 84 02 00 00       	push   $0x284
f010d1c7:	68 32 20 11 f0       	push   $0xf0112032
f010d1cc:	e8 8b 2f ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d1d1:	e8 47 d5 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d1d6:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010d1d9:	74 17                	je     f010d1f2 <test_kheap_phys_addr+0x454>
f010d1db:	83 ec 04             	sub    $0x4,%esp
f010d1de:	68 44 20 11 f0       	push   $0xf0112044
f010d1e3:	68 85 02 00 00       	push   $0x285
f010d1e8:	68 32 20 11 f0       	push   $0xf0112032
f010d1ed:	e8 6a 2f ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1536) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d1f2:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010d1f5:	e8 d7 be ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d1fa:	29 c3                	sub    %eax,%ebx
f010d1fc:	89 d8                	mov    %ebx,%eax
f010d1fe:	3d 00 06 00 00       	cmp    $0x600,%eax
f010d203:	74 17                	je     f010d21c <test_kheap_phys_addr+0x47e>
f010d205:	83 ec 04             	sub    $0x4,%esp
f010d208:	68 ac 20 11 f0       	push   $0xf01120ac
f010d20d:	68 86 02 00 00       	push   $0x286
f010d212:	68 32 20 11 f0       	push   $0xf0112032
f010d217:	e8 40 2f ff ff       	call   f010015c <_panic>

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f010d21c:	e8 b0 be ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d221:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d224:	e8 f4 d4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d229:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f010d22c:	83 ec 0c             	sub    $0xc,%esp
f010d22f:	68 00 38 00 00       	push   $0x3800
f010d234:	e8 ec da ff ff       	call   f010ad25 <kmalloc>
f010d239:	83 c4 10             	add    $0x10,%esp
f010d23c:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%ebp)
		if ((uint32) ptr_allocations[7] != (KERNEL_HEAP_START + 13*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d242:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f010d248:	3d 00 40 d0 f6       	cmp    $0xf6d04000,%eax
f010d24d:	74 17                	je     f010d266 <test_kheap_phys_addr+0x4c8>
f010d24f:	83 ec 04             	sub    $0x4,%esp
f010d252:	68 10 21 11 f0       	push   $0xf0112110
f010d257:	68 8c 02 00 00       	push   $0x28c
f010d25c:	68 32 20 11 f0       	push   $0xf0112032
f010d261:	e8 f6 2e ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d266:	e8 b2 d4 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d26b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010d26e:	74 17                	je     f010d287 <test_kheap_phys_addr+0x4e9>
f010d270:	83 ec 04             	sub    $0x4,%esp
f010d273:	68 44 20 11 f0       	push   $0xf0112044
f010d278:	68 8d 02 00 00       	push   $0x28d
f010d27d:	68 32 20 11 f0       	push   $0xf0112032
f010d282:	e8 d5 2e ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 4) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d287:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f010d28a:	e8 42 be ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d28f:	29 c3                	sub    %eax,%ebx
f010d291:	89 d8                	mov    %ebx,%eax
f010d293:	83 f8 04             	cmp    $0x4,%eax
f010d296:	74 17                	je     f010d2af <test_kheap_phys_addr+0x511>
f010d298:	83 ec 04             	sub    $0x4,%esp
f010d29b:	68 ac 20 11 f0       	push   $0xf01120ac
f010d2a0:	68 8e 02 00 00       	push   $0x28e
f010d2a5:	68 32 20 11 f0       	push   $0xf0112032
f010d2aa:	e8 ad 2e ff ff       	call   f010015c <_panic>
	}

	//test kheap_physical_address after kmalloc only [40%]
	{
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
f010d2af:	c7 45 b0 00 80 d0 f6 	movl   $0xf6d08000,-0x50(%ebp)
		uint32 allPAs[(13*Mega + 32*kilo)/PAGE_SIZE] ;
		i = 0;
f010d2b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = KERNEL_HEAP_START; va < endVA; va+=PAGE_SIZE)
f010d2bd:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
f010d2c4:	eb 25                	jmp    f010d2eb <test_kheap_phys_addr+0x54d>
		{
			allPAs[i++] = kheap_physical_address(va);
f010d2c6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f010d2c9:	8d 43 01             	lea    0x1(%ebx),%eax
f010d2cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d2cf:	83 ec 0c             	sub    $0xc,%esp
f010d2d2:	ff 75 f0             	pushl  -0x10(%ebp)
f010d2d5:	e8 e8 de ff ff       	call   f010b1c2 <kheap_physical_address>
f010d2da:	83 c4 10             	add    $0x10,%esp
f010d2dd:	89 84 9d 9c be fd ff 	mov    %eax,-0x24164(%ebp,%ebx,4)
	{
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
		uint32 allPAs[(13*Mega + 32*kilo)/PAGE_SIZE] ;
		i = 0;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PAGE_SIZE)
f010d2e4:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f010d2eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d2ee:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f010d2f1:	72 d3                	jb     f010d2c6 <test_kheap_phys_addr+0x528>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f010d2f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2f6:	89 45 ac             	mov    %eax,-0x54(%ebp)
		i = 0;
f010d2f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PTSIZE)
f010d300:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
f010d307:	e9 a0 00 00 00       	jmp    f010d3ac <test_kheap_phys_addr+0x60e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)va, &ptr_table);
f010d30c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010d30f:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010d314:	83 ec 04             	sub    $0x4,%esp
f010d317:	8d 8d a0 fe ff ff    	lea    -0x160(%ebp),%ecx
f010d31d:	51                   	push   %ecx
f010d31e:	52                   	push   %edx
f010d31f:	50                   	push   %eax
f010d320:	e8 eb 59 ff ff       	call   f0102d10 <get_page_table>
f010d325:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f010d328:	8b 85 a0 fe ff ff    	mov    -0x160(%ebp),%eax
f010d32e:	85 c0                	test   %eax,%eax
f010d330:	75 17                	jne    f010d349 <test_kheap_phys_addr+0x5ab>
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");
f010d332:	83 ec 04             	sub    $0x4,%esp
f010d335:	68 64 24 11 f0       	push   $0xf0112464
f010d33a:	68 a3 02 00 00       	push   $0x2a3
f010d33f:	68 32 20 11 f0       	push   $0xf0112032
f010d344:	e8 13 2e ff ff       	call   f010015c <_panic>

			for (j = 0; i < ii && j < 1024; ++j, ++i)
f010d349:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010d350:	eb 42                	jmp    f010d394 <test_kheap_phys_addr+0x5f6>
			{
				if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
f010d352:	8b 85 a0 fe ff ff    	mov    -0x160(%ebp),%eax
f010d358:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010d35b:	c1 e2 02             	shl    $0x2,%edx
f010d35e:	01 d0                	add    %edx,%eax
f010d360:	8b 00                	mov    (%eax),%eax
f010d362:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010d367:	89 c2                	mov    %eax,%edx
f010d369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d36c:	8b 84 85 9c be fd ff 	mov    -0x24164(%ebp,%eax,4),%eax
f010d373:	39 c2                	cmp    %eax,%edx
f010d375:	74 17                	je     f010d38e <test_kheap_phys_addr+0x5f0>
				{
					//cprintf("VA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					panic("Wrong kheap_physical_address");
f010d377:	83 ec 04             	sub    $0x4,%esp
f010d37a:	68 bd 24 11 f0       	push   $0xf01124bd
f010d37f:	68 aa 02 00 00       	push   $0x2aa
f010d384:	68 32 20 11 f0       	push   $0xf0112032
f010d389:	e8 ce 2d ff ff       	call   f010015c <_panic>
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)va, &ptr_table);
			if (ptr_table == NULL)
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");

			for (j = 0; i < ii && j < 1024; ++j, ++i)
f010d38e:	ff 45 ec             	incl   -0x14(%ebp)
f010d391:	ff 45 f4             	incl   -0xc(%ebp)
f010d394:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d397:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f010d39a:	7d 09                	jge    f010d3a5 <test_kheap_phys_addr+0x607>
f010d39c:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010d3a3:	7e ad                	jle    f010d352 <test_kheap_phys_addr+0x5b4>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PTSIZE)
f010d3a5:	81 45 f0 00 00 40 00 	addl   $0x400000,-0x10(%ebp)
f010d3ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d3af:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f010d3b2:	0f 82 54 ff ff ff    	jb     f010d30c <test_kheap_phys_addr+0x56e>
					panic("Wrong kheap_physical_address");
				}
			}
		}
	}
	cprintf("kheap_physical_address: current evaluation = 40%");
f010d3b8:	83 ec 0c             	sub    $0xc,%esp
f010d3bb:	68 dc 24 11 f0       	push   $0xf01124dc
f010d3c0:	e8 96 8c ff ff       	call   f010605b <cprintf>
f010d3c5:	83 c4 10             	add    $0x10,%esp

	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f010d3c8:	e8 04 bd ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d3cd:	89 45 a8             	mov    %eax,-0x58(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f010d3d0:	e8 48 d3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d3d5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		kfree(ptr_allocations[0]);
f010d3d8:	8b 85 a4 fe ff ff    	mov    -0x15c(%ebp),%eax
f010d3de:	83 ec 0c             	sub    $0xc,%esp
f010d3e1:	50                   	push   %eax
f010d3e2:	e8 b7 dc ff ff       	call   f010b09e <kfree>
f010d3e7:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d3ea:	e8 2e d3 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d3ef:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f010d3f2:	74 17                	je     f010d40b <test_kheap_phys_addr+0x66d>
f010d3f4:	83 ec 04             	sub    $0x4,%esp
f010d3f7:	68 44 20 11 f0       	push   $0xf0112044
f010d3fc:	68 b7 02 00 00       	push   $0x2b7
f010d401:	68 32 20 11 f0       	push   $0xf0112032
f010d406:	e8 51 2d ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 512 ) panic("Wrong kfree: pages in memory are not freed correctly");
f010d40b:	e8 c1 bc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d410:	89 c2                	mov    %eax,%edx
f010d412:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010d415:	29 c2                	sub    %eax,%edx
f010d417:	89 d0                	mov    %edx,%eax
f010d419:	3d 00 02 00 00       	cmp    $0x200,%eax
f010d41e:	74 17                	je     f010d437 <test_kheap_phys_addr+0x699>
f010d420:	83 ec 04             	sub    $0x4,%esp
f010d423:	68 50 22 11 f0       	push   $0xf0112250
f010d428:	68 b8 02 00 00       	push   $0x2b8
f010d42d:	68 32 20 11 f0       	push   $0xf0112032
f010d432:	e8 25 2d ff ff       	call   f010015c <_panic>

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f010d437:	e8 95 bc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d43c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d43f:	e8 d9 d2 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d444:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		kfree(ptr_allocations[1]);
f010d447:	8b 85 a8 fe ff ff    	mov    -0x158(%ebp),%eax
f010d44d:	83 ec 0c             	sub    $0xc,%esp
f010d450:	50                   	push   %eax
f010d451:	e8 48 dc ff ff       	call   f010b09e <kfree>
f010d456:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d459:	e8 bf d2 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d45e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f010d461:	74 17                	je     f010d47a <test_kheap_phys_addr+0x6dc>
f010d463:	83 ec 04             	sub    $0x4,%esp
f010d466:	68 44 20 11 f0       	push   $0xf0112044
f010d46b:	68 be 02 00 00       	push   $0x2be
f010d470:	68 32 20 11 f0       	push   $0xf0112032
f010d475:	e8 e2 2c ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 512) panic("Wrong kfree: pages in memory are not freed correctly");
f010d47a:	e8 52 bc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d47f:	89 c2                	mov    %eax,%edx
f010d481:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010d484:	29 c2                	sub    %eax,%edx
f010d486:	89 d0                	mov    %edx,%eax
f010d488:	3d 00 02 00 00       	cmp    $0x200,%eax
f010d48d:	74 17                	je     f010d4a6 <test_kheap_phys_addr+0x708>
f010d48f:	83 ec 04             	sub    $0x4,%esp
f010d492:	68 50 22 11 f0       	push   $0xf0112250
f010d497:	68 bf 02 00 00       	push   $0x2bf
f010d49c:	68 32 20 11 f0       	push   $0xf0112032
f010d4a1:	e8 b6 2c ff ff       	call   f010015c <_panic>

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f010d4a6:	e8 26 bc ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d4ab:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d4ae:	e8 6a d2 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d4b3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		kfree(ptr_allocations[6]);
f010d4b6:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
f010d4bc:	83 ec 0c             	sub    $0xc,%esp
f010d4bf:	50                   	push   %eax
f010d4c0:	e8 d9 db ff ff       	call   f010b09e <kfree>
f010d4c5:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d4c8:	e8 50 d2 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d4cd:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f010d4d0:	74 17                	je     f010d4e9 <test_kheap_phys_addr+0x74b>
f010d4d2:	83 ec 04             	sub    $0x4,%esp
f010d4d5:	68 44 20 11 f0       	push   $0xf0112044
f010d4da:	68 c5 02 00 00       	push   $0x2c5
f010d4df:	68 32 20 11 f0       	push   $0xf0112032
f010d4e4:	e8 73 2c ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 6*Mega/4096) panic("Wrong kfree: pages in memory are not freed correctly");
f010d4e9:	e8 e3 bb ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d4ee:	89 c2                	mov    %eax,%edx
f010d4f0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010d4f3:	29 c2                	sub    %eax,%edx
f010d4f5:	89 d0                	mov    %edx,%eax
f010d4f7:	3d 00 06 00 00       	cmp    $0x600,%eax
f010d4fc:	74 17                	je     f010d515 <test_kheap_phys_addr+0x777>
f010d4fe:	83 ec 04             	sub    $0x4,%esp
f010d501:	68 50 22 11 f0       	push   $0xf0112250
f010d506:	68 c6 02 00 00       	push   $0x2c6
f010d50b:	68 32 20 11 f0       	push   $0xf0112032
f010d510:	e8 47 2c ff ff       	call   f010015c <_panic>


	//test kheap_physical_address after kmalloc and kfree [40%]
	{
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
f010d515:	c7 45 a0 00 80 d0 f6 	movl   $0xf6d08000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 32*kilo)/PAGE_SIZE] ;
		i = 0;
f010d51c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = KERNEL_HEAP_START; va < endVA; va+=PAGE_SIZE)
f010d523:	c7 45 e8 00 00 00 f6 	movl   $0xf6000000,-0x18(%ebp)
f010d52a:	eb 25                	jmp    f010d551 <test_kheap_phys_addr+0x7b3>
		{
			allPAs[i++] = kheap_physical_address(va);
f010d52c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f010d52f:	8d 43 01             	lea    0x1(%ebx),%eax
f010d532:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d535:	83 ec 0c             	sub    $0xc,%esp
f010d538:	ff 75 e8             	pushl  -0x18(%ebp)
f010d53b:	e8 82 dc ff ff       	call   f010b1c2 <kheap_physical_address>
f010d540:	83 c4 10             	add    $0x10,%esp
f010d543:	89 84 9d 9c be fd ff 	mov    %eax,-0x24164(%ebp,%ebx,4)
	{
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
		uint32 allPAs[(13*Mega + 32*kilo)/PAGE_SIZE] ;
		i = 0;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PAGE_SIZE)
f010d54a:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
f010d551:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d554:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f010d557:	72 d3                	jb     f010d52c <test_kheap_phys_addr+0x78e>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f010d559:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d55c:	89 45 9c             	mov    %eax,-0x64(%ebp)
		i = 0;
f010d55f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PTSIZE)
f010d566:	c7 45 e8 00 00 00 f6 	movl   $0xf6000000,-0x18(%ebp)
f010d56d:	e9 a0 00 00 00       	jmp    f010d612 <test_kheap_phys_addr+0x874>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)va, &ptr_table);
f010d572:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d575:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010d57a:	83 ec 04             	sub    $0x4,%esp
f010d57d:	8d 8d 9c fe ff ff    	lea    -0x164(%ebp),%ecx
f010d583:	51                   	push   %ecx
f010d584:	52                   	push   %edx
f010d585:	50                   	push   %eax
f010d586:	e8 85 57 ff ff       	call   f0102d10 <get_page_table>
f010d58b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f010d58e:	8b 85 9c fe ff ff    	mov    -0x164(%ebp),%eax
f010d594:	85 c0                	test   %eax,%eax
f010d596:	75 17                	jne    f010d5af <test_kheap_phys_addr+0x811>
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");
f010d598:	83 ec 04             	sub    $0x4,%esp
f010d59b:	68 64 24 11 f0       	push   $0xf0112464
f010d5a0:	68 dc 02 00 00       	push   $0x2dc
f010d5a5:	68 32 20 11 f0       	push   $0xf0112032
f010d5aa:	e8 ad 2b ff ff       	call   f010015c <_panic>

			for (j = 0; i < ii && j < 1024; ++j, ++i)
f010d5af:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f010d5b6:	eb 42                	jmp    f010d5fa <test_kheap_phys_addr+0x85c>
			{
				if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
f010d5b8:	8b 85 9c fe ff ff    	mov    -0x164(%ebp),%eax
f010d5be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010d5c1:	c1 e2 02             	shl    $0x2,%edx
f010d5c4:	01 d0                	add    %edx,%eax
f010d5c6:	8b 00                	mov    (%eax),%eax
f010d5c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010d5cd:	89 c2                	mov    %eax,%edx
f010d5cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d5d2:	8b 84 85 9c be fd ff 	mov    -0x24164(%ebp,%eax,4),%eax
f010d5d9:	39 c2                	cmp    %eax,%edx
f010d5db:	74 17                	je     f010d5f4 <test_kheap_phys_addr+0x856>
				{
					//cprintf("VA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					panic("Wrong kheap_physical_address");
f010d5dd:	83 ec 04             	sub    $0x4,%esp
f010d5e0:	68 bd 24 11 f0       	push   $0xf01124bd
f010d5e5:	68 e3 02 00 00       	push   $0x2e3
f010d5ea:	68 32 20 11 f0       	push   $0xf0112032
f010d5ef:	e8 68 2b ff ff       	call   f010015c <_panic>
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)va, &ptr_table);
			if (ptr_table == NULL)
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");

			for (j = 0; i < ii && j < 1024; ++j, ++i)
f010d5f4:	ff 45 e4             	incl   -0x1c(%ebp)
f010d5f7:	ff 45 f4             	incl   -0xc(%ebp)
f010d5fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d5fd:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f010d600:	7d 09                	jge    f010d60b <test_kheap_phys_addr+0x86d>
f010d602:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f010d609:	7e ad                	jle    f010d5b8 <test_kheap_phys_addr+0x81a>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PTSIZE)
f010d60b:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f010d612:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d615:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f010d618:	0f 82 54 ff ff ff    	jb     f010d572 <test_kheap_phys_addr+0x7d4>
				}
			}
		}
	}

	cprintf("\b\b\b80%");
f010d61e:	83 ec 0c             	sub    $0xc,%esp
f010d621:	68 b5 21 11 f0       	push   $0xf01121b5
f010d626:	e8 30 8a ff ff       	call   f010605b <cprintf>
f010d62b:	83 c4 10             	add    $0x10,%esp

	//test kheap_physical_address on non-mapped area [20%]
	{
		uint32 va;
		uint32 startVA = KERNEL_HEAP_START + 16*Mega;
f010d62e:	c7 45 98 00 00 00 f7 	movl   $0xf7000000,-0x68(%ebp)
		uint32 allPAs[(KERNEL_HEAP_MAX - (KERNEL_HEAP_START + 16*Mega))/PAGE_SIZE] ;
		i = 0;
f010d635:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f010d63c:	8b 45 98             	mov    -0x68(%ebp),%eax
f010d63f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010d642:	eb 25                	jmp    f010d669 <test_kheap_phys_addr+0x8cb>
		{
			allPAs[i++] = kheap_physical_address(va);
f010d644:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f010d647:	8d 43 01             	lea    0x1(%ebx),%eax
f010d64a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d64d:	83 ec 0c             	sub    $0xc,%esp
f010d650:	ff 75 e0             	pushl  -0x20(%ebp)
f010d653:	e8 6a db ff ff       	call   f010b1c2 <kheap_physical_address>
f010d658:	83 c4 10             	add    $0x10,%esp
f010d65b:	89 84 9d 9c be fd ff 	mov    %eax,-0x24164(%ebp,%ebx,4)
	{
		uint32 va;
		uint32 startVA = KERNEL_HEAP_START + 16*Mega;
		uint32 allPAs[(KERNEL_HEAP_MAX - (KERNEL_HEAP_START + 16*Mega))/PAGE_SIZE] ;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f010d662:	81 45 e0 00 10 00 00 	addl   $0x1000,-0x20(%ebp)
f010d669:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f010d670:	76 d2                	jbe    f010d644 <test_kheap_phys_addr+0x8a6>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f010d672:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d675:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f010d678:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f010d67f:	8b 45 98             	mov    -0x68(%ebp),%eax
f010d682:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010d685:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f010d68c:	e9 a6 00 00 00       	jmp    f010d737 <test_kheap_phys_addr+0x999>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)(uint32)va2, &ptr_table);
f010d691:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010d694:	89 c1                	mov    %eax,%ecx
f010d696:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010d69b:	83 ec 04             	sub    $0x4,%esp
f010d69e:	8d 95 98 fe ff ff    	lea    -0x168(%ebp),%edx
f010d6a4:	52                   	push   %edx
f010d6a5:	51                   	push   %ecx
f010d6a6:	50                   	push   %eax
f010d6a7:	e8 64 56 ff ff       	call   f0102d10 <get_page_table>
f010d6ac:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f010d6af:	8b 85 98 fe ff ff    	mov    -0x168(%ebp),%eax
f010d6b5:	85 c0                	test   %eax,%eax
f010d6b7:	75 17                	jne    f010d6d0 <test_kheap_phys_addr+0x932>
			{
				//cprintf("VA = %x\n",va2);
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");
f010d6b9:	83 ec 04             	sub    $0x4,%esp
f010d6bc:	68 64 24 11 f0       	push   $0xf0112464
f010d6c1:	68 00 03 00 00       	push   $0x300
f010d6c6:	68 32 20 11 f0       	push   $0xf0112032
f010d6cb:	e8 8c 2a ff ff       	call   f010015c <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f010d6d0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010d6d7:	eb 42                	jmp    f010d71b <test_kheap_phys_addr+0x97d>
			{
				if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
f010d6d9:	8b 85 98 fe ff ff    	mov    -0x168(%ebp),%eax
f010d6df:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010d6e2:	c1 e2 02             	shl    $0x2,%edx
f010d6e5:	01 d0                	add    %edx,%eax
f010d6e7:	8b 00                	mov    (%eax),%eax
f010d6e9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010d6ee:	89 c2                	mov    %eax,%edx
f010d6f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d6f3:	8b 84 85 9c be fd ff 	mov    -0x24164(%ebp,%eax,4),%eax
f010d6fa:	39 c2                	cmp    %eax,%edx
f010d6fc:	74 17                	je     f010d715 <test_kheap_phys_addr+0x977>
				{
					//cprintf("VA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					panic("Wrong kheap_physical_address");
f010d6fe:	83 ec 04             	sub    $0x4,%esp
f010d701:	68 bd 24 11 f0       	push   $0xf01124bd
f010d706:	68 07 03 00 00       	push   $0x307
f010d70b:	68 32 20 11 f0       	push   $0xf0112032
f010d710:	e8 47 2a ff ff       	call   f010015c <_panic>
			if (ptr_table == NULL)
			{
				//cprintf("VA = %x\n",va2);
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f010d715:	ff 45 dc             	incl   -0x24(%ebp)
f010d718:	ff 45 f4             	incl   -0xc(%ebp)
f010d71b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d71e:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010d721:	7d 09                	jge    f010d72c <test_kheap_phys_addr+0x98e>
f010d723:	81 7d dc ff 03 00 00 	cmpl   $0x3ff,-0x24(%ebp)
f010d72a:	7e ad                	jle    f010d6d9 <test_kheap_phys_addr+0x93b>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f010d72c:	81 45 d0 00 00 40 00 	addl   $0x400000,-0x30(%ebp)
f010d733:	83 55 d4 00          	adcl   $0x0,-0x2c(%ebp)
f010d737:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010d73b:	0f 88 50 ff ff ff    	js     f010d691 <test_kheap_phys_addr+0x8f3>
f010d741:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010d745:	7f 0d                	jg     f010d754 <test_kheap_phys_addr+0x9b6>
f010d747:	81 7d d0 ff ef ff ff 	cmpl   $0xffffefff,-0x30(%ebp)
f010d74e:	0f 86 3d ff ff ff    	jbe    f010d691 <test_kheap_phys_addr+0x8f3>
				}
			}
		}
	}

	cprintf("\b\b\b100%\n");
f010d754:	83 ec 0c             	sub    $0xc,%esp
f010d757:	68 0e 22 11 f0       	push   $0xf011220e
f010d75c:	e8 fa 88 ff ff       	call   f010605b <cprintf>
f010d761:	83 c4 10             	add    $0x10,%esp

	cprintf("Congratulations!! test kheap_physical_address completed successfully.\n");
f010d764:	83 ec 0c             	sub    $0xc,%esp
f010d767:	68 10 25 11 f0       	push   $0xf0112510
f010d76c:	e8 ea 88 ff ff       	call   f010605b <cprintf>
f010d771:	83 c4 10             	add    $0x10,%esp

	return 1;
f010d774:	b8 01 00 00 00       	mov    $0x1,%eax

}
f010d779:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010d77c:	5b                   	pop    %ebx
f010d77d:	5f                   	pop    %edi
f010d77e:	5d                   	pop    %ebp
f010d77f:	c3                   	ret    

f010d780 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f010d780:	55                   	push   %ebp
f010d781:	89 e5                	mov    %esp,%ebp
f010d783:	57                   	push   %edi
f010d784:	53                   	push   %ebx
f010d785:	81 ec 70 35 00 00    	sub    $0x3570,%esp
	char minByte = 1<<7;
f010d78b:	c6 45 e3 80          	movb   $0x80,-0x1d(%ebp)
	char maxByte = 0x7F;
f010d78f:	c6 45 e2 7f          	movb   $0x7f,-0x1e(%ebp)
	short minShort = 1<<15 ;
f010d793:	66 c7 45 e0 00 80    	movw   $0x8000,-0x20(%ebp)
	short maxShort = 0x7FFF;
f010d799:	66 c7 45 de ff 7f    	movw   $0x7fff,-0x22(%ebp)
	int minInt = 1<<31 ;
f010d79f:	c7 45 d8 00 00 00 80 	movl   $0x80000000,-0x28(%ebp)
	int maxInt = 0x7FFFFFFF;
f010d7a6:	c7 45 d4 ff ff ff 7f 	movl   $0x7fffffff,-0x2c(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f010d7ad:	e8 1f b9 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d7b2:	89 45 d0             	mov    %eax,-0x30(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f010d7b5:	8d 95 4c ff ff ff    	lea    -0xb4(%ebp),%edx
f010d7bb:	b9 14 00 00 00       	mov    $0x14,%ecx
f010d7c0:	b8 00 00 00 00       	mov    $0x0,%eax
f010d7c5:	89 d7                	mov    %edx,%edi
f010d7c7:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f010d7c9:	8d 95 fc fe ff ff    	lea    -0x104(%ebp),%edx
f010d7cf:	b9 14 00 00 00       	mov    $0x14,%ecx
f010d7d4:	b8 00 00 00 00       	mov    $0x0,%eax
f010d7d9:	89 d7                	mov    %edx,%edi
f010d7db:	f3 ab                	rep stos %eax,%es:(%edi)
	void* ptr_allocations[20] = {0};
f010d7dd:	8d 95 ac fe ff ff    	lea    -0x154(%ebp),%edx
f010d7e3:	b9 14 00 00 00       	mov    $0x14,%ecx
f010d7e8:	b8 00 00 00 00       	mov    $0x0,%eax
f010d7ed:	89 d7                	mov    %edx,%edi
f010d7ef:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010d7f1:	e8 db b8 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d7f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d7f9:	e8 1f cf ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d7fe:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f010d801:	83 ec 0c             	sub    $0xc,%esp
f010d804:	68 00 fc 1f 00       	push   $0x1ffc00
f010d809:	e8 17 d5 ff ff       	call   f010ad25 <kmalloc>
f010d80e:	83 c4 10             	add    $0x10,%esp
f010d811:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
		if ((uint32) ptr_allocations[0] !=  (KERNEL_HEAP_START)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d817:	8b 85 ac fe ff ff    	mov    -0x154(%ebp),%eax
f010d81d:	3d 00 00 00 f6       	cmp    $0xf6000000,%eax
f010d822:	74 17                	je     f010d83b <test_kheap_virt_addr+0xbb>
f010d824:	83 ec 04             	sub    $0x4,%esp
f010d827:	68 10 21 11 f0       	push   $0xf0112110
f010d82c:	68 30 03 00 00       	push   $0x330
f010d831:	68 32 20 11 f0       	push   $0xf0112032
f010d836:	e8 21 29 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d83b:	e8 dd ce ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d840:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010d843:	74 17                	je     f010d85c <test_kheap_virt_addr+0xdc>
f010d845:	83 ec 04             	sub    $0x4,%esp
f010d848:	68 44 20 11 f0       	push   $0xf0112044
f010d84d:	68 31 03 00 00       	push   $0x331
f010d852:	68 32 20 11 f0       	push   $0xf0112032
f010d857:	e8 00 29 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d85c:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010d85f:	e8 6d b8 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d864:	29 c3                	sub    %eax,%ebx
f010d866:	89 d8                	mov    %ebx,%eax
f010d868:	3d 00 02 00 00       	cmp    $0x200,%eax
f010d86d:	74 17                	je     f010d886 <test_kheap_virt_addr+0x106>
f010d86f:	83 ec 04             	sub    $0x4,%esp
f010d872:	68 ac 20 11 f0       	push   $0xf01120ac
f010d877:	68 32 03 00 00       	push   $0x332
f010d87c:	68 32 20 11 f0       	push   $0xf0112032
f010d881:	e8 d6 28 ff ff       	call   f010015c <_panic>

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f010d886:	e8 46 b8 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d88b:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d88e:	e8 8a ce ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d893:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f010d896:	83 ec 0c             	sub    $0xc,%esp
f010d899:	68 00 fc 1f 00       	push   $0x1ffc00
f010d89e:	e8 82 d4 ff ff       	call   f010ad25 <kmalloc>
f010d8a3:	83 c4 10             	add    $0x10,%esp
f010d8a6:	89 85 b0 fe ff ff    	mov    %eax,-0x150(%ebp)
		if ((uint32) ptr_allocations[1] != (KERNEL_HEAP_START + 2*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d8ac:	8b 85 b0 fe ff ff    	mov    -0x150(%ebp),%eax
f010d8b2:	3d 00 00 20 f6       	cmp    $0xf6200000,%eax
f010d8b7:	74 17                	je     f010d8d0 <test_kheap_virt_addr+0x150>
f010d8b9:	83 ec 04             	sub    $0x4,%esp
f010d8bc:	68 10 21 11 f0       	push   $0xf0112110
f010d8c1:	68 38 03 00 00       	push   $0x338
f010d8c6:	68 32 20 11 f0       	push   $0xf0112032
f010d8cb:	e8 8c 28 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d8d0:	e8 48 ce ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d8d5:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010d8d8:	74 17                	je     f010d8f1 <test_kheap_virt_addr+0x171>
f010d8da:	83 ec 04             	sub    $0x4,%esp
f010d8dd:	68 44 20 11 f0       	push   $0xf0112044
f010d8e2:	68 39 03 00 00       	push   $0x339
f010d8e7:	68 32 20 11 f0       	push   $0xf0112032
f010d8ec:	e8 6b 28 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 512) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d8f1:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010d8f4:	e8 d8 b7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d8f9:	29 c3                	sub    %eax,%ebx
f010d8fb:	89 d8                	mov    %ebx,%eax
f010d8fd:	3d 00 02 00 00       	cmp    $0x200,%eax
f010d902:	74 17                	je     f010d91b <test_kheap_virt_addr+0x19b>
f010d904:	83 ec 04             	sub    $0x4,%esp
f010d907:	68 ac 20 11 f0       	push   $0xf01120ac
f010d90c:	68 3a 03 00 00       	push   $0x33a
f010d911:	68 32 20 11 f0       	push   $0xf0112032
f010d916:	e8 41 28 ff ff       	call   f010015c <_panic>

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010d91b:	e8 b1 b7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d920:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d923:	e8 f5 cd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d928:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo);
f010d92b:	83 ec 0c             	sub    $0xc,%esp
f010d92e:	68 00 08 00 00       	push   $0x800
f010d933:	e8 ed d3 ff ff       	call   f010ad25 <kmalloc>
f010d938:	83 c4 10             	add    $0x10,%esp
f010d93b:	89 85 b4 fe ff ff    	mov    %eax,-0x14c(%ebp)
		if ((uint32) ptr_allocations[2] != (KERNEL_HEAP_START + 4*Mega)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d941:	8b 85 b4 fe ff ff    	mov    -0x14c(%ebp),%eax
f010d947:	3d 00 00 40 f6       	cmp    $0xf6400000,%eax
f010d94c:	74 17                	je     f010d965 <test_kheap_virt_addr+0x1e5>
f010d94e:	83 ec 04             	sub    $0x4,%esp
f010d951:	68 10 21 11 f0       	push   $0xf0112110
f010d956:	68 40 03 00 00       	push   $0x340
f010d95b:	68 32 20 11 f0       	push   $0xf0112032
f010d960:	e8 f7 27 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d965:	e8 b3 cd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d96a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010d96d:	74 17                	je     f010d986 <test_kheap_virt_addr+0x206>
f010d96f:	83 ec 04             	sub    $0x4,%esp
f010d972:	68 44 20 11 f0       	push   $0xf0112044
f010d977:	68 41 03 00 00       	push   $0x341
f010d97c:	68 32 20 11 f0       	push   $0xf0112032
f010d981:	e8 d6 27 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010d986:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010d989:	e8 43 b7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d98e:	29 c3                	sub    %eax,%ebx
f010d990:	89 d8                	mov    %ebx,%eax
f010d992:	83 f8 01             	cmp    $0x1,%eax
f010d995:	74 17                	je     f010d9ae <test_kheap_virt_addr+0x22e>
f010d997:	83 ec 04             	sub    $0x4,%esp
f010d99a:	68 ac 20 11 f0       	push   $0xf01120ac
f010d99f:	68 42 03 00 00       	push   $0x342
f010d9a4:	68 32 20 11 f0       	push   $0xf0112032
f010d9a9:	e8 ae 27 ff ff       	call   f010015c <_panic>

		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f010d9ae:	e8 1e b7 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010d9b3:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010d9b6:	e8 62 cd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d9bb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f010d9be:	83 ec 0c             	sub    $0xc,%esp
f010d9c1:	68 00 08 00 00       	push   $0x800
f010d9c6:	e8 5a d3 ff ff       	call   f010ad25 <kmalloc>
f010d9cb:	83 c4 10             	add    $0x10,%esp
f010d9ce:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
		if ((uint32) ptr_allocations[3] != (KERNEL_HEAP_START + 4*Mega + 4*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010d9d4:	8b 85 b8 fe ff ff    	mov    -0x148(%ebp),%eax
f010d9da:	3d 00 10 40 f6       	cmp    $0xf6401000,%eax
f010d9df:	74 17                	je     f010d9f8 <test_kheap_virt_addr+0x278>
f010d9e1:	83 ec 04             	sub    $0x4,%esp
f010d9e4:	68 10 21 11 f0       	push   $0xf0112110
f010d9e9:	68 48 03 00 00       	push   $0x348
f010d9ee:	68 32 20 11 f0       	push   $0xf0112032
f010d9f3:	e8 64 27 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010d9f8:	e8 20 cd ff ff       	call   f010a71d <pf_calculate_free_frames>
f010d9fd:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010da00:	74 17                	je     f010da19 <test_kheap_virt_addr+0x299>
f010da02:	83 ec 04             	sub    $0x4,%esp
f010da05:	68 44 20 11 f0       	push   $0xf0112044
f010da0a:	68 49 03 00 00       	push   $0x349
f010da0f:	68 32 20 11 f0       	push   $0xf0112032
f010da14:	e8 43 27 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory");
f010da19:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010da1c:	e8 b0 b6 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010da21:	29 c3                	sub    %eax,%ebx
f010da23:	89 d8                	mov    %ebx,%eax
f010da25:	83 f8 01             	cmp    $0x1,%eax
f010da28:	74 17                	je     f010da41 <test_kheap_virt_addr+0x2c1>
f010da2a:	83 ec 04             	sub    $0x4,%esp
f010da2d:	68 ac 20 11 f0       	push   $0xf01120ac
f010da32:	68 4a 03 00 00       	push   $0x34a
f010da37:	68 32 20 11 f0       	push   $0xf0112032
f010da3c:	e8 1b 27 ff ff       	call   f010015c <_panic>

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f010da41:	e8 8b b6 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010da46:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010da49:	e8 cf cc ff ff       	call   f010a71d <pf_calculate_free_frames>
f010da4e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f010da51:	83 ec 0c             	sub    $0xc,%esp
f010da54:	68 00 1c 00 00       	push   $0x1c00
f010da59:	e8 c7 d2 ff ff       	call   f010ad25 <kmalloc>
f010da5e:	83 c4 10             	add    $0x10,%esp
f010da61:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)
		if ((uint32) ptr_allocations[4] != (KERNEL_HEAP_START + 4*Mega + 8*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010da67:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
f010da6d:	3d 00 20 40 f6       	cmp    $0xf6402000,%eax
f010da72:	74 17                	je     f010da8b <test_kheap_virt_addr+0x30b>
f010da74:	83 ec 04             	sub    $0x4,%esp
f010da77:	68 10 21 11 f0       	push   $0xf0112110
f010da7c:	68 50 03 00 00       	push   $0x350
f010da81:	68 32 20 11 f0       	push   $0xf0112032
f010da86:	e8 d1 26 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010da8b:	e8 8d cc ff ff       	call   f010a71d <pf_calculate_free_frames>
f010da90:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010da93:	74 17                	je     f010daac <test_kheap_virt_addr+0x32c>
f010da95:	83 ec 04             	sub    $0x4,%esp
f010da98:	68 44 20 11 f0       	push   $0xf0112044
f010da9d:	68 51 03 00 00       	push   $0x351
f010daa2:	68 32 20 11 f0       	push   $0xf0112032
f010daa7:	e8 b0 26 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 2) panic("Wrong allocation: pages are not loaded successfully into memory");
f010daac:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010daaf:	e8 1d b6 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010dab4:	29 c3                	sub    %eax,%ebx
f010dab6:	89 d8                	mov    %ebx,%eax
f010dab8:	83 f8 02             	cmp    $0x2,%eax
f010dabb:	74 17                	je     f010dad4 <test_kheap_virt_addr+0x354>
f010dabd:	83 ec 04             	sub    $0x4,%esp
f010dac0:	68 ac 20 11 f0       	push   $0xf01120ac
f010dac5:	68 52 03 00 00       	push   $0x352
f010daca:	68 32 20 11 f0       	push   $0xf0112032
f010dacf:	e8 88 26 ff ff       	call   f010015c <_panic>

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f010dad4:	e8 f8 b5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010dad9:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010dadc:	e8 3c cc ff ff       	call   f010a71d <pf_calculate_free_frames>
f010dae1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f010dae4:	83 ec 0c             	sub    $0xc,%esp
f010dae7:	68 00 fc 2f 00       	push   $0x2ffc00
f010daec:	e8 34 d2 ff ff       	call   f010ad25 <kmalloc>
f010daf1:	83 c4 10             	add    $0x10,%esp
f010daf4:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%ebp)
		if ((uint32) ptr_allocations[5] != (KERNEL_HEAP_START + 4*Mega + 16*kilo) ) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010dafa:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f010db00:	3d 00 40 40 f6       	cmp    $0xf6404000,%eax
f010db05:	74 17                	je     f010db1e <test_kheap_virt_addr+0x39e>
f010db07:	83 ec 04             	sub    $0x4,%esp
f010db0a:	68 10 21 11 f0       	push   $0xf0112110
f010db0f:	68 58 03 00 00       	push   $0x358
f010db14:	68 32 20 11 f0       	push   $0xf0112032
f010db19:	e8 3e 26 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010db1e:	e8 fa cb ff ff       	call   f010a71d <pf_calculate_free_frames>
f010db23:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010db26:	74 17                	je     f010db3f <test_kheap_virt_addr+0x3bf>
f010db28:	83 ec 04             	sub    $0x4,%esp
f010db2b:	68 44 20 11 f0       	push   $0xf0112044
f010db30:	68 59 03 00 00       	push   $0x359
f010db35:	68 32 20 11 f0       	push   $0xf0112032
f010db3a:	e8 1d 26 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 768) panic("Wrong allocation: pages are not loaded successfully into memory");
f010db3f:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010db42:	e8 8a b5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010db47:	29 c3                	sub    %eax,%ebx
f010db49:	89 d8                	mov    %ebx,%eax
f010db4b:	3d 00 03 00 00       	cmp    $0x300,%eax
f010db50:	74 17                	je     f010db69 <test_kheap_virt_addr+0x3e9>
f010db52:	83 ec 04             	sub    $0x4,%esp
f010db55:	68 ac 20 11 f0       	push   $0xf01120ac
f010db5a:	68 5a 03 00 00       	push   $0x35a
f010db5f:	68 32 20 11 f0       	push   $0xf0112032
f010db64:	e8 f3 25 ff ff       	call   f010015c <_panic>

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f010db69:	e8 63 b5 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010db6e:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010db71:	e8 a7 cb ff ff       	call   f010a71d <pf_calculate_free_frames>
f010db76:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f010db79:	83 ec 0c             	sub    $0xc,%esp
f010db7c:	68 00 fc 5f 00       	push   $0x5ffc00
f010db81:	e8 9f d1 ff ff       	call   f010ad25 <kmalloc>
f010db86:	83 c4 10             	add    $0x10,%esp
f010db89:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
		if ((uint32) ptr_allocations[6] != (KERNEL_HEAP_START + 7*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010db8f:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f010db95:	3d 00 40 70 f6       	cmp    $0xf6704000,%eax
f010db9a:	74 17                	je     f010dbb3 <test_kheap_virt_addr+0x433>
f010db9c:	83 ec 04             	sub    $0x4,%esp
f010db9f:	68 10 21 11 f0       	push   $0xf0112110
f010dba4:	68 60 03 00 00       	push   $0x360
f010dba9:	68 32 20 11 f0       	push   $0xf0112032
f010dbae:	e8 a9 25 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010dbb3:	e8 65 cb ff ff       	call   f010a71d <pf_calculate_free_frames>
f010dbb8:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010dbbb:	74 17                	je     f010dbd4 <test_kheap_virt_addr+0x454>
f010dbbd:	83 ec 04             	sub    $0x4,%esp
f010dbc0:	68 44 20 11 f0       	push   $0xf0112044
f010dbc5:	68 61 03 00 00       	push   $0x361
f010dbca:	68 32 20 11 f0       	push   $0xf0112032
f010dbcf:	e8 88 25 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 1536) panic("Wrong allocation: pages are not loaded successfully into memory");
f010dbd4:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010dbd7:	e8 f5 b4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010dbdc:	29 c3                	sub    %eax,%ebx
f010dbde:	89 d8                	mov    %ebx,%eax
f010dbe0:	3d 00 06 00 00       	cmp    $0x600,%eax
f010dbe5:	74 17                	je     f010dbfe <test_kheap_virt_addr+0x47e>
f010dbe7:	83 ec 04             	sub    $0x4,%esp
f010dbea:	68 ac 20 11 f0       	push   $0xf01120ac
f010dbef:	68 62 03 00 00       	push   $0x362
f010dbf4:	68 32 20 11 f0       	push   $0xf0112032
f010dbf9:	e8 5e 25 ff ff       	call   f010015c <_panic>

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f010dbfe:	e8 ce b4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010dc03:	89 45 cc             	mov    %eax,-0x34(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010dc06:	e8 12 cb ff ff       	call   f010a71d <pf_calculate_free_frames>
f010dc0b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f010dc0e:	83 ec 0c             	sub    $0xc,%esp
f010dc11:	68 00 38 00 00       	push   $0x3800
f010dc16:	e8 0a d1 ff ff       	call   f010ad25 <kmalloc>
f010dc1b:	83 c4 10             	add    $0x10,%esp
f010dc1e:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
		if ((uint32) ptr_allocations[7] != (KERNEL_HEAP_START + 13*Mega + 16*kilo)) panic("Wrong start address for the allocated space... check return address of kmalloc & updating of heap ptr");
f010dc24:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f010dc2a:	3d 00 40 d0 f6       	cmp    $0xf6d04000,%eax
f010dc2f:	74 17                	je     f010dc48 <test_kheap_virt_addr+0x4c8>
f010dc31:	83 ec 04             	sub    $0x4,%esp
f010dc34:	68 10 21 11 f0       	push   $0xf0112110
f010dc39:	68 68 03 00 00       	push   $0x368
f010dc3e:	68 32 20 11 f0       	push   $0xf0112032
f010dc43:	e8 14 25 ff ff       	call   f010015c <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010dc48:	e8 d0 ca ff ff       	call   f010a71d <pf_calculate_free_frames>
f010dc4d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f010dc50:	74 17                	je     f010dc69 <test_kheap_virt_addr+0x4e9>
f010dc52:	83 ec 04             	sub    $0x4,%esp
f010dc55:	68 44 20 11 f0       	push   $0xf0112044
f010dc5a:	68 69 03 00 00       	push   $0x369
f010dc5f:	68 32 20 11 f0       	push   $0xf0112032
f010dc64:	e8 f3 24 ff ff       	call   f010015c <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 4) panic("Wrong allocation: pages are not loaded successfully into memory");
f010dc69:	8b 5d cc             	mov    -0x34(%ebp),%ebx
f010dc6c:	e8 60 b4 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010dc71:	29 c3                	sub    %eax,%ebx
f010dc73:	89 d8                	mov    %ebx,%eax
f010dc75:	83 f8 04             	cmp    $0x4,%eax
f010dc78:	74 17                	je     f010dc91 <test_kheap_virt_addr+0x511>
f010dc7a:	83 ec 04             	sub    $0x4,%esp
f010dc7d:	68 ac 20 11 f0       	push   $0xf01120ac
f010dc82:	68 6a 03 00 00       	push   $0x36a
f010dc87:	68 32 20 11 f0       	push   $0xf0112032
f010dc8c:	e8 cb 24 ff ff       	call   f010015c <_panic>
	}

	uint32 allPAs[(13*Mega + 32*kilo)/PAGE_SIZE] ;
	int numOfFrames = (13*Mega + 32*kilo)/PAGE_SIZE ;
f010dc91:	c7 45 c4 08 0d 00 00 	movl   $0xd08,-0x3c(%ebp)

	//test kheap_virtual_address after kmalloc only [40%]
	{
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
f010dc98:	c7 45 c0 00 80 d0 f6 	movl   $0xf6d08000,-0x40(%ebp)
		int i = 0;
f010dc9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int j;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PTSIZE)
f010dca6:	c7 45 f4 00 00 00 f6 	movl   $0xf6000000,-0xc(%ebp)
f010dcad:	e9 c7 00 00 00       	jmp    f010dd79 <test_kheap_virt_addr+0x5f9>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)va, &ptr_table);
f010dcb2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010dcb5:	a1 90 52 45 f0       	mov    0xf0455290,%eax
f010dcba:	83 ec 04             	sub    $0x4,%esp
f010dcbd:	8d 8d 88 ca ff ff    	lea    -0x3578(%ebp),%ecx
f010dcc3:	51                   	push   %ecx
f010dcc4:	52                   	push   %edx
f010dcc5:	50                   	push   %eax
f010dcc6:	e8 45 50 ff ff       	call   f0102d10 <get_page_table>
f010dccb:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f010dcce:	8b 85 88 ca ff ff    	mov    -0x3578(%ebp),%eax
f010dcd4:	85 c0                	test   %eax,%eax
f010dcd6:	75 17                	jne    f010dcef <test_kheap_virt_addr+0x56f>
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");
f010dcd8:	83 ec 04             	sub    $0x4,%esp
f010dcdb:	68 64 24 11 f0       	push   $0xf0112464
f010dce0:	68 7b 03 00 00       	push   $0x37b
f010dce5:	68 32 20 11 f0       	push   $0xf0112032
f010dcea:	e8 6d 24 ff ff       	call   f010015c <_panic>

			for (j = 0; i < numOfFrames && j < 1024; ++j, ++i)
f010dcef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010dcf6:	eb 69                	jmp    f010dd61 <test_kheap_virt_addr+0x5e1>
			{
				allPAs[i] = (ptr_table[j] & 0xFFFFF000);
f010dcf8:	8b 85 88 ca ff ff    	mov    -0x3578(%ebp),%eax
f010dcfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010dd01:	c1 e2 02             	shl    $0x2,%edx
f010dd04:	01 d0                	add    %edx,%eax
f010dd06:	8b 00                	mov    (%eax),%eax
f010dd08:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010dd0d:	89 c2                	mov    %eax,%edx
f010dd0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd12:	89 94 85 8c ca ff ff 	mov    %edx,-0x3574(%ebp,%eax,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f010dd19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd1c:	8b 84 85 8c ca ff ff 	mov    -0x3574(%ebp,%eax,4),%eax
f010dd23:	83 ec 0c             	sub    $0xc,%esp
f010dd26:	50                   	push   %eax
f010dd27:	e8 77 d4 ff ff       	call   f010b1a3 <kheap_virtual_address>
f010dd2c:	83 c4 10             	add    $0x10,%esp
f010dd2f:	89 45 bc             	mov    %eax,-0x44(%ebp)

				if (retrievedVA != (va + j*PAGE_SIZE))
f010dd32:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010dd35:	c1 e0 0c             	shl    $0xc,%eax
f010dd38:	89 c2                	mov    %eax,%edx
f010dd3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dd3d:	01 d0                	add    %edx,%eax
f010dd3f:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f010dd42:	74 17                	je     f010dd5b <test_kheap_virt_addr+0x5db>
				{
					//cprintf("VA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					panic("Wrong kheap_virtual_address");
f010dd44:	83 ec 04             	sub    $0x4,%esp
f010dd47:	68 57 25 11 f0       	push   $0xf0112557
f010dd4c:	68 85 03 00 00       	push   $0x385
f010dd51:	68 32 20 11 f0       	push   $0xf0112032
f010dd56:	e8 01 24 ff ff       	call   f010015c <_panic>
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (void*)va, &ptr_table);
			if (ptr_table == NULL)
				panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed");

			for (j = 0; i < numOfFrames && j < 1024; ++j, ++i)
f010dd5b:	ff 45 ec             	incl   -0x14(%ebp)
f010dd5e:	ff 45 f0             	incl   -0x10(%ebp)
f010dd61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd64:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f010dd67:	7d 09                	jge    f010dd72 <test_kheap_virt_addr+0x5f2>
f010dd69:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010dd70:	7e 86                	jle    f010dcf8 <test_kheap_virt_addr+0x578>
	{
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
		int i = 0;
		int j;
		for (va = KERNEL_HEAP_START; va < endVA; va+=PTSIZE)
f010dd72:	81 45 f4 00 00 40 00 	addl   $0x400000,-0xc(%ebp)
f010dd79:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dd7c:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010dd7f:	0f 82 2d ff ff ff    	jb     f010dcb2 <test_kheap_virt_addr+0x532>
					panic("Wrong kheap_virtual_address");
				}
			}
		}
	}
	cprintf("kheap_virtual_address: current evaluation = 40%");
f010dd85:	83 ec 0c             	sub    $0xc,%esp
f010dd88:	68 74 25 11 f0       	push   $0xf0112574
f010dd8d:	e8 c9 82 ff ff       	call   f010605b <cprintf>
f010dd92:	83 c4 10             	add    $0x10,%esp

	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f010dd95:	e8 37 b3 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010dd9a:	89 45 b8             	mov    %eax,-0x48(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f010dd9d:	e8 7b c9 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010dda2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		kfree(ptr_allocations[0]);
f010dda5:	8b 85 ac fe ff ff    	mov    -0x154(%ebp),%eax
f010ddab:	83 ec 0c             	sub    $0xc,%esp
f010ddae:	50                   	push   %eax
f010ddaf:	e8 ea d2 ff ff       	call   f010b09e <kfree>
f010ddb4:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010ddb7:	e8 61 c9 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010ddbc:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010ddbf:	74 17                	je     f010ddd8 <test_kheap_virt_addr+0x658>
f010ddc1:	83 ec 04             	sub    $0x4,%esp
f010ddc4:	68 44 20 11 f0       	push   $0xf0112044
f010ddc9:	68 92 03 00 00       	push   $0x392
f010ddce:	68 32 20 11 f0       	push   $0xf0112032
f010ddd3:	e8 84 23 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 512 ) panic("Wrong kfree: pages in memory are not freed correctly");
f010ddd8:	e8 f4 b2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010dddd:	89 c2                	mov    %eax,%edx
f010dddf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010dde2:	29 c2                	sub    %eax,%edx
f010dde4:	89 d0                	mov    %edx,%eax
f010dde6:	3d 00 02 00 00       	cmp    $0x200,%eax
f010ddeb:	74 17                	je     f010de04 <test_kheap_virt_addr+0x684>
f010dded:	83 ec 04             	sub    $0x4,%esp
f010ddf0:	68 50 22 11 f0       	push   $0xf0112250
f010ddf5:	68 93 03 00 00       	push   $0x393
f010ddfa:	68 32 20 11 f0       	push   $0xf0112032
f010ddff:	e8 58 23 ff ff       	call   f010015c <_panic>

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f010de04:	e8 c8 b2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010de09:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010de0c:	e8 0c c9 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010de11:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		kfree(ptr_allocations[1]);
f010de14:	8b 85 b0 fe ff ff    	mov    -0x150(%ebp),%eax
f010de1a:	83 ec 0c             	sub    $0xc,%esp
f010de1d:	50                   	push   %eax
f010de1e:	e8 7b d2 ff ff       	call   f010b09e <kfree>
f010de23:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010de26:	e8 f2 c8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010de2b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010de2e:	74 17                	je     f010de47 <test_kheap_virt_addr+0x6c7>
f010de30:	83 ec 04             	sub    $0x4,%esp
f010de33:	68 44 20 11 f0       	push   $0xf0112044
f010de38:	68 99 03 00 00       	push   $0x399
f010de3d:	68 32 20 11 f0       	push   $0xf0112032
f010de42:	e8 15 23 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 512) panic("Wrong kfree: pages in memory are not freed correctly");
f010de47:	e8 85 b2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010de4c:	89 c2                	mov    %eax,%edx
f010de4e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010de51:	29 c2                	sub    %eax,%edx
f010de53:	89 d0                	mov    %edx,%eax
f010de55:	3d 00 02 00 00       	cmp    $0x200,%eax
f010de5a:	74 17                	je     f010de73 <test_kheap_virt_addr+0x6f3>
f010de5c:	83 ec 04             	sub    $0x4,%esp
f010de5f:	68 50 22 11 f0       	push   $0xf0112250
f010de64:	68 9a 03 00 00       	push   $0x39a
f010de69:	68 32 20 11 f0       	push   $0xf0112032
f010de6e:	e8 e9 22 ff ff       	call   f010015c <_panic>

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f010de73:	e8 59 b2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010de78:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f010de7b:	e8 9d c8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010de80:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		kfree(ptr_allocations[6]);
f010de83:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f010de89:	83 ec 0c             	sub    $0xc,%esp
f010de8c:	50                   	push   %eax
f010de8d:	e8 0c d2 ff ff       	call   f010b09e <kfree>
f010de92:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010de95:	e8 83 c8 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010de9a:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f010de9d:	74 17                	je     f010deb6 <test_kheap_virt_addr+0x736>
f010de9f:	83 ec 04             	sub    $0x4,%esp
f010dea2:	68 44 20 11 f0       	push   $0xf0112044
f010dea7:	68 a0 03 00 00       	push   $0x3a0
f010deac:	68 32 20 11 f0       	push   $0xf0112032
f010deb1:	e8 a6 22 ff ff       	call   f010015c <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 6*Mega/4096) panic("Wrong kfree: pages in memory are not freed correctly");
f010deb6:	e8 16 b2 ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010debb:	89 c2                	mov    %eax,%edx
f010debd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010dec0:	29 c2                	sub    %eax,%edx
f010dec2:	89 d0                	mov    %edx,%eax
f010dec4:	3d 00 06 00 00       	cmp    $0x600,%eax
f010dec9:	74 17                	je     f010dee2 <test_kheap_virt_addr+0x762>
f010decb:	83 ec 04             	sub    $0x4,%esp
f010dece:	68 50 22 11 f0       	push   $0xf0112250
f010ded3:	68 a1 03 00 00       	push   $0x3a1
f010ded8:	68 32 20 11 f0       	push   $0xf0112032
f010dedd:	e8 7a 22 ff ff       	call   f010015c <_panic>


	//test kheap_virtual_address after kmalloc and kfree [40%]
	{
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
f010dee2:	c7 45 b0 00 80 d0 f6 	movl   $0xf6d08000,-0x50(%ebp)
		int i = 0;
f010dee9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		int j;
		//frames of first 4 MB
		for (i = 0; i < 4*Mega/PAGE_SIZE; ++i)
f010def0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010def7:	eb 39                	jmp    f010df32 <test_kheap_virt_addr+0x7b2>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f010def9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010defc:	8b 84 85 8c ca ff ff 	mov    -0x3574(%ebp,%eax,4),%eax
f010df03:	83 ec 0c             	sub    $0xc,%esp
f010df06:	50                   	push   %eax
f010df07:	e8 97 d2 ff ff       	call   f010b1a3 <kheap_virtual_address>
f010df0c:	83 c4 10             	add    $0x10,%esp
f010df0f:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (retrievedVA != 0)
f010df12:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f010df16:	74 17                	je     f010df2f <test_kheap_virt_addr+0x7af>
			{
				panic("Wrong kheap_virtual_address");
f010df18:	83 ec 04             	sub    $0x4,%esp
f010df1b:	68 57 25 11 f0       	push   $0xf0112557
f010df20:	68 b1 03 00 00       	push   $0x3b1
f010df25:	68 32 20 11 f0       	push   $0xf0112032
f010df2a:	e8 2d 22 ff ff       	call   f010015c <_panic>
		uint32 va;
		uint32 endVA = KERNEL_HEAP_START + 13*Mega + 32*kilo;
		int i = 0;
		int j;
		//frames of first 4 MB
		for (i = 0; i < 4*Mega/PAGE_SIZE; ++i)
f010df2f:	ff 45 e8             	incl   -0x18(%ebp)
f010df32:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
f010df39:	7e be                	jle    f010def9 <test_kheap_virt_addr+0x779>
				panic("Wrong kheap_virtual_address");
			}

		}
		//next frames until 6 MB
		for (i = 4*Mega/PAGE_SIZE; i < (7*Mega + 16*kilo)/PAGE_SIZE; ++i)
f010df3b:	c7 45 e8 00 04 00 00 	movl   $0x400,-0x18(%ebp)
f010df42:	eb 43                	jmp    f010df87 <test_kheap_virt_addr+0x807>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f010df44:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010df47:	8b 84 85 8c ca ff ff 	mov    -0x3574(%ebp,%eax,4),%eax
f010df4e:	83 ec 0c             	sub    $0xc,%esp
f010df51:	50                   	push   %eax
f010df52:	e8 4c d2 ff ff       	call   f010b1a3 <kheap_virtual_address>
f010df57:	83 c4 10             	add    $0x10,%esp
f010df5a:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if (retrievedVA != KERNEL_HEAP_START + i*PAGE_SIZE)
f010df5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010df60:	c1 e0 0c             	shl    $0xc,%eax
f010df63:	2d 00 00 00 0a       	sub    $0xa000000,%eax
f010df68:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010df6b:	74 17                	je     f010df84 <test_kheap_virt_addr+0x804>
			{
				panic("Wrong kheap_virtual_address");
f010df6d:	83 ec 04             	sub    $0x4,%esp
f010df70:	68 57 25 11 f0       	push   $0xf0112557
f010df75:	68 bb 03 00 00       	push   $0x3bb
f010df7a:	68 32 20 11 f0       	push   $0xf0112032
f010df7f:	e8 d8 21 ff ff       	call   f010015c <_panic>
				panic("Wrong kheap_virtual_address");
			}

		}
		//next frames until 6 MB
		for (i = 4*Mega/PAGE_SIZE; i < (7*Mega + 16*kilo)/PAGE_SIZE; ++i)
f010df84:	ff 45 e8             	incl   -0x18(%ebp)
f010df87:	81 7d e8 03 07 00 00 	cmpl   $0x703,-0x18(%ebp)
f010df8e:	7e b4                	jle    f010df44 <test_kheap_virt_addr+0x7c4>
			{
				panic("Wrong kheap_virtual_address");
			}
		}
		//frames of 6 MB
		for (i = (7*Mega + 16*kilo)/PAGE_SIZE; i < (13*Mega + 16*kilo)/PAGE_SIZE; ++i)
f010df90:	c7 45 e8 04 07 00 00 	movl   $0x704,-0x18(%ebp)
f010df97:	eb 39                	jmp    f010dfd2 <test_kheap_virt_addr+0x852>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f010df99:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010df9c:	8b 84 85 8c ca ff ff 	mov    -0x3574(%ebp,%eax,4),%eax
f010dfa3:	83 ec 0c             	sub    $0xc,%esp
f010dfa6:	50                   	push   %eax
f010dfa7:	e8 f7 d1 ff ff       	call   f010b1a3 <kheap_virtual_address>
f010dfac:	83 c4 10             	add    $0x10,%esp
f010dfaf:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if (retrievedVA != 0)
f010dfb2:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f010dfb6:	74 17                	je     f010dfcf <test_kheap_virt_addr+0x84f>
			{
				panic("Wrong kheap_virtual_address");
f010dfb8:	83 ec 04             	sub    $0x4,%esp
f010dfbb:	68 57 25 11 f0       	push   $0xf0112557
f010dfc0:	68 c4 03 00 00       	push   $0x3c4
f010dfc5:	68 32 20 11 f0       	push   $0xf0112032
f010dfca:	e8 8d 21 ff ff       	call   f010015c <_panic>
			{
				panic("Wrong kheap_virtual_address");
			}
		}
		//frames of 6 MB
		for (i = (7*Mega + 16*kilo)/PAGE_SIZE; i < (13*Mega + 16*kilo)/PAGE_SIZE; ++i)
f010dfcf:	ff 45 e8             	incl   -0x18(%ebp)
f010dfd2:	81 7d e8 03 0d 00 00 	cmpl   $0xd03,-0x18(%ebp)
f010dfd9:	7e be                	jle    f010df99 <test_kheap_virt_addr+0x819>
			{
				panic("Wrong kheap_virtual_address");
			}
		}
		//frames of last allocation (14 KB)
		for (i = (13*Mega + 16*kilo)/PAGE_SIZE; i < (13*Mega + 32*kilo)/PAGE_SIZE; ++i)
f010dfdb:	c7 45 e8 04 0d 00 00 	movl   $0xd04,-0x18(%ebp)
f010dfe2:	eb 43                	jmp    f010e027 <test_kheap_virt_addr+0x8a7>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f010dfe4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010dfe7:	8b 84 85 8c ca ff ff 	mov    -0x3574(%ebp,%eax,4),%eax
f010dfee:	83 ec 0c             	sub    $0xc,%esp
f010dff1:	50                   	push   %eax
f010dff2:	e8 ac d1 ff ff       	call   f010b1a3 <kheap_virtual_address>
f010dff7:	83 c4 10             	add    $0x10,%esp
f010dffa:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if (retrievedVA != KERNEL_HEAP_START + i*PAGE_SIZE)
f010dffd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e000:	c1 e0 0c             	shl    $0xc,%eax
f010e003:	2d 00 00 00 0a       	sub    $0xa000000,%eax
f010e008:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f010e00b:	74 17                	je     f010e024 <test_kheap_virt_addr+0x8a4>
			{
				panic("Wrong kheap_virtual_address");
f010e00d:	83 ec 04             	sub    $0x4,%esp
f010e010:	68 57 25 11 f0       	push   $0xf0112557
f010e015:	68 cd 03 00 00       	push   $0x3cd
f010e01a:	68 32 20 11 f0       	push   $0xf0112032
f010e01f:	e8 38 21 ff ff       	call   f010015c <_panic>
			{
				panic("Wrong kheap_virtual_address");
			}
		}
		//frames of last allocation (14 KB)
		for (i = (13*Mega + 16*kilo)/PAGE_SIZE; i < (13*Mega + 32*kilo)/PAGE_SIZE; ++i)
f010e024:	ff 45 e8             	incl   -0x18(%ebp)
f010e027:	81 7d e8 07 0d 00 00 	cmpl   $0xd07,-0x18(%ebp)
f010e02e:	7e b4                	jle    f010dfe4 <test_kheap_virt_addr+0x864>
				panic("Wrong kheap_virtual_address");
			}
		}
	}

	cprintf("\b\b\b80%");
f010e030:	83 ec 0c             	sub    $0xc,%esp
f010e033:	68 b5 21 11 f0       	push   $0xf01121b5
f010e038:	e8 1e 80 ff ff       	call   f010605b <cprintf>
f010e03d:	83 c4 10             	add    $0x10,%esp

	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f010e040:	c7 45 e4 00 00 10 00 	movl   $0x100000,-0x1c(%ebp)
f010e047:	eb 4b                	jmp    f010e094 <test_kheap_virt_addr+0x914>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f010e049:	83 ec 0c             	sub    $0xc,%esp
f010e04c:	ff 75 e4             	pushl  -0x1c(%ebp)
f010e04f:	e8 4f d1 ff ff       	call   f010b1a3 <kheap_virtual_address>
f010e054:	83 c4 10             	add    $0x10,%esp
f010e057:	89 45 9c             	mov    %eax,-0x64(%ebp)
			if (retrievedVA != 0)
f010e05a:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f010e05e:	74 2d                	je     f010e08d <test_kheap_virt_addr+0x90d>
			{
				cprintf("PA = %x, retrievedVA = %x\n", i, retrievedVA);
f010e060:	83 ec 04             	sub    $0x4,%esp
f010e063:	ff 75 9c             	pushl  -0x64(%ebp)
f010e066:	ff 75 e4             	pushl  -0x1c(%ebp)
f010e069:	68 a4 25 11 f0       	push   $0xf01125a4
f010e06e:	e8 e8 7f ff ff       	call   f010605b <cprintf>
f010e073:	83 c4 10             	add    $0x10,%esp
				panic("Wrong kheap_virtual_address");
f010e076:	83 ec 04             	sub    $0x4,%esp
f010e079:	68 57 25 11 f0       	push   $0xf0112557
f010e07e:	68 dd 03 00 00       	push   $0x3dd
f010e083:	68 32 20 11 f0       	push   $0xf0112032
f010e088:	e8 cf 20 ff ff       	call   f010015c <_panic>
	cprintf("\b\b\b80%");

	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f010e08d:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010e094:	b8 c0 67 51 00       	mov    $0x5167c0,%eax
f010e099:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e09c:	72 ab                	jb     f010e049 <test_kheap_virt_addr+0x8c9>
				panic("Wrong kheap_virtual_address");
			}
		}
	}

	cprintf("\b\b\b100%\n");
f010e09e:	83 ec 0c             	sub    $0xc,%esp
f010e0a1:	68 0e 22 11 f0       	push   $0xf011220e
f010e0a6:	e8 b0 7f ff ff       	call   f010605b <cprintf>
f010e0ab:	83 c4 10             	add    $0x10,%esp

	cprintf("Congratulations!! test kheap_virtual_address completed successfully.\n");
f010e0ae:	83 ec 0c             	sub    $0xc,%esp
f010e0b1:	68 c0 25 11 f0       	push   $0xf01125c0
f010e0b6:	e8 a0 7f ff ff       	call   f010605b <cprintf>
f010e0bb:	83 c4 10             	add    $0x10,%esp

	return 1;
f010e0be:	b8 01 00 00 00       	mov    $0x1,%eax

}
f010e0c3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010e0c6:	5b                   	pop    %ebx
f010e0c7:	5f                   	pop    %edi
f010e0c8:	5d                   	pop    %ebp
f010e0c9:	c3                   	ret    

f010e0ca <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f010e0ca:	55                   	push   %ebp
f010e0cb:	89 e5                	mov    %esp,%ebp
f010e0cd:	57                   	push   %edi
f010e0ce:	56                   	push   %esi
f010e0cf:	53                   	push   %ebx
f010e0d0:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f010e0d6:	a0 74 a9 13 f0       	mov    0xf013a974,%al
f010e0db:	84 c0                	test   %al,%al
f010e0dd:	74 56                	je     f010e135 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f010e0df:	c6 05 74 a9 13 f0 00 	movb   $0x0,0xf013a974
		initFreeFrames = sys_calculate_free_frames() ;
f010e0e6:	e8 e6 af ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010e0eb:	a3 bc 67 51 f0       	mov    %eax,0xf05167bc
		initFreeDiskFrames = pf_calculate_free_frames() ;
f010e0f0:	e8 28 c6 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010e0f5:	a3 b8 67 51 f0       	mov    %eax,0xf05167b8
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f010e0fa:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f010e100:	bb 1c 27 11 f0       	mov    $0xf011271c,%ebx
f010e105:	ba 11 00 00 00       	mov    $0x11,%edx
f010e10a:	89 c7                	mov    %eax,%edi
f010e10c:	89 de                	mov    %ebx,%esi
f010e10e:	89 d1                	mov    %edx,%ecx
f010e110:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010e112:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f010e118:	b9 53 00 00 00       	mov    $0x53,%ecx
f010e11d:	b0 00                	mov    $0x0,%al
f010e11f:	89 d7                	mov    %edx,%edi
f010e121:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f010e123:	83 ec 0c             	sub    $0xc,%esp
f010e126:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f010e12c:	50                   	push   %eax
f010e12d:	e8 32 2e ff ff       	call   f0100f64 <execute_command>
f010e132:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f010e135:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f010e13c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &env_exit_queue)
f010e143:	a1 9c 52 45 f0       	mov    0xf045529c,%eax
f010e148:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010e14b:	eb 2e                	jmp    f010e17b <test_three_creation_functions+0xb1>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f010e14d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e150:	8b 80 ec 02 00 00    	mov    0x2ec(%eax),%eax
f010e156:	83 ec 08             	sub    $0x8,%esp
f010e159:	68 06 26 11 f0       	push   $0xf0112606
f010e15e:	50                   	push   %eax
f010e15f:	e8 58 0a 00 00       	call   f010ebbc <strcmp>
f010e164:	83 c4 10             	add    $0x10,%esp
f010e167:	85 c0                	test   %eax,%eax
f010e169:	75 08                	jne    f010e173 <test_three_creation_functions+0xa9>
			{
				e = ptr_env ;
f010e16b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e16e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f010e171:	eb 2f                	jmp    f010e1a2 <test_three_creation_functions+0xd8>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &env_exit_queue)
f010e173:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f010e178:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010e17b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e17f:	74 08                	je     f010e189 <test_three_creation_functions+0xbf>
f010e181:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e184:	8b 40 44             	mov    0x44(%eax),%eax
f010e187:	eb 05                	jmp    f010e18e <test_three_creation_functions+0xc4>
f010e189:	b8 00 00 00 00       	mov    $0x0,%eax
f010e18e:	a3 a4 52 45 f0       	mov    %eax,0xf04552a4
f010e193:	a1 a4 52 45 f0       	mov    0xf04552a4,%eax
f010e198:	85 c0                	test   %eax,%eax
f010e19a:	75 b1                	jne    f010e14d <test_three_creation_functions+0x83>
f010e19c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e1a0:	75 ab                	jne    f010e14d <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f010e1a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e1a5:	8b 80 dc 02 00 00    	mov    0x2dc(%eax),%eax
f010e1ab:	85 c0                	test   %eax,%eax
f010e1ad:	74 17                	je     f010e1c6 <test_three_creation_functions+0xfc>
			panic("Page fault is occur while not expected to. Review the three creation fuctions");
f010e1af:	83 ec 04             	sub    $0x4,%esp
f010e1b2:	68 10 26 11 f0       	push   $0xf0112610
f010e1b7:	68 07 04 00 00       	push   $0x407
f010e1bc:	68 32 20 11 f0       	push   $0xf0112032
f010e1c1:	e8 96 1f ff ff       	call   f010015c <_panic>

		int pagesInWS = env_page_ws_get_size(e);
f010e1c6:	83 ec 0c             	sub    $0xc,%esp
f010e1c9:	ff 75 e4             	pushl  -0x1c(%ebp)
f010e1cc:	e8 22 54 ff ff       	call   f01035f3 <env_page_ws_get_size>
f010e1d1:	83 c4 10             	add    $0x10,%esp
f010e1d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int curFreeFrames = sys_calculate_free_frames() ;
f010e1d7:	e8 f5 ae ff ff       	call   f01090d1 <sys_calculate_free_frames>
f010e1dc:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f010e1df:	e8 39 c5 ff ff       	call   f010a71d <pf_calculate_free_frames>
f010e1e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("diff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f010e1e7:	a1 b8 67 51 f0       	mov    0xf05167b8,%eax
f010e1ec:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f010e1ef:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010e1f2:	74 17                	je     f010e20b <test_three_creation_functions+0x141>
f010e1f4:	83 ec 04             	sub    $0x4,%esp
f010e1f7:	68 44 20 11 f0       	push   $0xf0112044
f010e1fc:	68 0d 04 00 00       	push   $0x40d
f010e201:	68 32 20 11 f0       	push   $0xf0112032
f010e206:	e8 51 1f ff ff       	call   f010015c <_panic>
		//cprintf("diff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f010e20b:	a1 bc 67 51 f0       	mov    0xf05167bc,%eax
f010e210:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010e213:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010e216:	83 c2 15             	add    $0x15,%edx
f010e219:	39 d0                	cmp    %edx,%eax
f010e21b:	74 17                	je     f010e234 <test_three_creation_functions+0x16a>
f010e21d:	83 ec 04             	sub    $0x4,%esp
f010e220:	68 ac 20 11 f0       	push   $0xf01120ac
f010e225:	68 0f 04 00 00       	push   $0x40f
f010e22a:	68 32 20 11 f0       	push   $0xf0112032
f010e22f:	e8 28 1f ff ff       	call   f010015c <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f010e234:	83 ec 0c             	sub    $0xc,%esp
f010e237:	68 00 10 00 00       	push   $0x1000
f010e23c:	e8 e4 ca ff ff       	call   f010ad25 <kmalloc>
f010e241:	83 c4 10             	add    $0x10,%esp
f010e244:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (KERNEL_HEAP_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f010e247:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e24a:	3d 00 50 01 f6       	cmp    $0xf6015000,%eax
f010e24f:	74 17                	je     f010e268 <test_three_creation_functions+0x19e>
f010e251:	83 ec 04             	sub    $0x4,%esp
f010e254:	68 60 26 11 f0       	push   $0xf0112660
f010e259:	68 13 04 00 00       	push   $0x413
f010e25e:	68 32 20 11 f0       	push   $0xf0112032
f010e263:	e8 f4 1e ff ff       	call   f010015c <_panic>
	}

	cprintf("Congratulations!! test the 3 creation functions is completed successfully.\n");
f010e268:	83 ec 0c             	sub    $0xc,%esp
f010e26b:	68 d0 26 11 f0       	push   $0xf01126d0
f010e270:	e8 e6 7d ff ff       	call   f010605b <cprintf>
f010e275:	83 c4 10             	add    $0x10,%esp

	return 1;
f010e278:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010e27d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e280:	5b                   	pop    %ebx
f010e281:	5e                   	pop    %esi
f010e282:	5f                   	pop    %edi
f010e283:	5d                   	pop    %ebp
f010e284:	c3                   	ret    

f010e285 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f010e285:	55                   	push   %ebp
f010e286:	89 e5                	mov    %esp,%ebp
f010e288:	53                   	push   %ebx
f010e289:	83 ec 14             	sub    $0x14,%esp
f010e28c:	8b 45 10             	mov    0x10(%ebp),%eax
f010e28f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e292:	8b 45 14             	mov    0x14(%ebp),%eax
f010e295:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f010e298:	8b 45 18             	mov    0x18(%ebp),%eax
f010e29b:	ba 00 00 00 00       	mov    $0x0,%edx
f010e2a0:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f010e2a3:	77 55                	ja     f010e2fa <printnum+0x75>
f010e2a5:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f010e2a8:	72 05                	jb     f010e2af <printnum+0x2a>
f010e2aa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e2ad:	77 4b                	ja     f010e2fa <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f010e2af:	8b 45 1c             	mov    0x1c(%ebp),%eax
f010e2b2:	8d 58 ff             	lea    -0x1(%eax),%ebx
f010e2b5:	8b 45 18             	mov    0x18(%ebp),%eax
f010e2b8:	ba 00 00 00 00       	mov    $0x0,%edx
f010e2bd:	52                   	push   %edx
f010e2be:	50                   	push   %eax
f010e2bf:	ff 75 f4             	pushl  -0xc(%ebp)
f010e2c2:	ff 75 f0             	pushl  -0x10(%ebp)
f010e2c5:	e8 ba 11 00 00       	call   f010f484 <__udivdi3>
f010e2ca:	83 c4 10             	add    $0x10,%esp
f010e2cd:	83 ec 04             	sub    $0x4,%esp
f010e2d0:	ff 75 20             	pushl  0x20(%ebp)
f010e2d3:	53                   	push   %ebx
f010e2d4:	ff 75 18             	pushl  0x18(%ebp)
f010e2d7:	52                   	push   %edx
f010e2d8:	50                   	push   %eax
f010e2d9:	ff 75 0c             	pushl  0xc(%ebp)
f010e2dc:	ff 75 08             	pushl  0x8(%ebp)
f010e2df:	e8 a1 ff ff ff       	call   f010e285 <printnum>
f010e2e4:	83 c4 20             	add    $0x20,%esp
f010e2e7:	eb 1a                	jmp    f010e303 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f010e2e9:	83 ec 08             	sub    $0x8,%esp
f010e2ec:	ff 75 0c             	pushl  0xc(%ebp)
f010e2ef:	ff 75 20             	pushl  0x20(%ebp)
f010e2f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2f5:	ff d0                	call   *%eax
f010e2f7:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f010e2fa:	ff 4d 1c             	decl   0x1c(%ebp)
f010e2fd:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f010e301:	7f e6                	jg     f010e2e9 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f010e303:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e306:	bb 00 00 00 00       	mov    $0x0,%ebx
f010e30b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e30e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e311:	53                   	push   %ebx
f010e312:	51                   	push   %ecx
f010e313:	52                   	push   %edx
f010e314:	50                   	push   %eax
f010e315:	e8 7a 12 00 00       	call   f010f594 <__umoddi3>
f010e31a:	83 c4 10             	add    $0x10,%esp
f010e31d:	05 94 29 11 f0       	add    $0xf0112994,%eax
f010e322:	8a 00                	mov    (%eax),%al
f010e324:	0f be c0             	movsbl %al,%eax
f010e327:	83 ec 08             	sub    $0x8,%esp
f010e32a:	ff 75 0c             	pushl  0xc(%ebp)
f010e32d:	50                   	push   %eax
f010e32e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e331:	ff d0                	call   *%eax
f010e333:	83 c4 10             	add    $0x10,%esp
}
f010e336:	90                   	nop
f010e337:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e33a:	c9                   	leave  
f010e33b:	c3                   	ret    

f010e33c <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f010e33c:	55                   	push   %ebp
f010e33d:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f010e33f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f010e343:	7e 1c                	jle    f010e361 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f010e345:	8b 45 08             	mov    0x8(%ebp),%eax
f010e348:	8b 00                	mov    (%eax),%eax
f010e34a:	8d 50 08             	lea    0x8(%eax),%edx
f010e34d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e350:	89 10                	mov    %edx,(%eax)
f010e352:	8b 45 08             	mov    0x8(%ebp),%eax
f010e355:	8b 00                	mov    (%eax),%eax
f010e357:	83 e8 08             	sub    $0x8,%eax
f010e35a:	8b 50 04             	mov    0x4(%eax),%edx
f010e35d:	8b 00                	mov    (%eax),%eax
f010e35f:	eb 40                	jmp    f010e3a1 <getuint+0x65>
	else if (lflag)
f010e361:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010e365:	74 1e                	je     f010e385 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f010e367:	8b 45 08             	mov    0x8(%ebp),%eax
f010e36a:	8b 00                	mov    (%eax),%eax
f010e36c:	8d 50 04             	lea    0x4(%eax),%edx
f010e36f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e372:	89 10                	mov    %edx,(%eax)
f010e374:	8b 45 08             	mov    0x8(%ebp),%eax
f010e377:	8b 00                	mov    (%eax),%eax
f010e379:	83 e8 04             	sub    $0x4,%eax
f010e37c:	8b 00                	mov    (%eax),%eax
f010e37e:	ba 00 00 00 00       	mov    $0x0,%edx
f010e383:	eb 1c                	jmp    f010e3a1 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f010e385:	8b 45 08             	mov    0x8(%ebp),%eax
f010e388:	8b 00                	mov    (%eax),%eax
f010e38a:	8d 50 04             	lea    0x4(%eax),%edx
f010e38d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e390:	89 10                	mov    %edx,(%eax)
f010e392:	8b 45 08             	mov    0x8(%ebp),%eax
f010e395:	8b 00                	mov    (%eax),%eax
f010e397:	83 e8 04             	sub    $0x4,%eax
f010e39a:	8b 00                	mov    (%eax),%eax
f010e39c:	ba 00 00 00 00       	mov    $0x0,%edx
}
f010e3a1:	5d                   	pop    %ebp
f010e3a2:	c3                   	ret    

f010e3a3 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f010e3a3:	55                   	push   %ebp
f010e3a4:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f010e3a6:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f010e3aa:	7e 1c                	jle    f010e3c8 <getint+0x25>
		return va_arg(*ap, long long);
f010e3ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3af:	8b 00                	mov    (%eax),%eax
f010e3b1:	8d 50 08             	lea    0x8(%eax),%edx
f010e3b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3b7:	89 10                	mov    %edx,(%eax)
f010e3b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3bc:	8b 00                	mov    (%eax),%eax
f010e3be:	83 e8 08             	sub    $0x8,%eax
f010e3c1:	8b 50 04             	mov    0x4(%eax),%edx
f010e3c4:	8b 00                	mov    (%eax),%eax
f010e3c6:	eb 38                	jmp    f010e400 <getint+0x5d>
	else if (lflag)
f010e3c8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010e3cc:	74 1a                	je     f010e3e8 <getint+0x45>
		return va_arg(*ap, long);
f010e3ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3d1:	8b 00                	mov    (%eax),%eax
f010e3d3:	8d 50 04             	lea    0x4(%eax),%edx
f010e3d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3d9:	89 10                	mov    %edx,(%eax)
f010e3db:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3de:	8b 00                	mov    (%eax),%eax
f010e3e0:	83 e8 04             	sub    $0x4,%eax
f010e3e3:	8b 00                	mov    (%eax),%eax
f010e3e5:	99                   	cltd   
f010e3e6:	eb 18                	jmp    f010e400 <getint+0x5d>
	else
		return va_arg(*ap, int);
f010e3e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3eb:	8b 00                	mov    (%eax),%eax
f010e3ed:	8d 50 04             	lea    0x4(%eax),%edx
f010e3f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3f3:	89 10                	mov    %edx,(%eax)
f010e3f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3f8:	8b 00                	mov    (%eax),%eax
f010e3fa:	83 e8 04             	sub    $0x4,%eax
f010e3fd:	8b 00                	mov    (%eax),%eax
f010e3ff:	99                   	cltd   
}
f010e400:	5d                   	pop    %ebp
f010e401:	c3                   	ret    

f010e402 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f010e402:	55                   	push   %ebp
f010e403:	89 e5                	mov    %esp,%ebp
f010e405:	56                   	push   %esi
f010e406:	53                   	push   %ebx
f010e407:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f010e40a:	eb 17                	jmp    f010e423 <vprintfmt+0x21>
			if (ch == '\0')
f010e40c:	85 db                	test   %ebx,%ebx
f010e40e:	0f 84 af 03 00 00    	je     f010e7c3 <vprintfmt+0x3c1>
				return;
			putch(ch, putdat);
f010e414:	83 ec 08             	sub    $0x8,%esp
f010e417:	ff 75 0c             	pushl  0xc(%ebp)
f010e41a:	53                   	push   %ebx
f010e41b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e41e:	ff d0                	call   *%eax
f010e420:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f010e423:	8b 45 10             	mov    0x10(%ebp),%eax
f010e426:	8d 50 01             	lea    0x1(%eax),%edx
f010e429:	89 55 10             	mov    %edx,0x10(%ebp)
f010e42c:	8a 00                	mov    (%eax),%al
f010e42e:	0f b6 d8             	movzbl %al,%ebx
f010e431:	83 fb 25             	cmp    $0x25,%ebx
f010e434:	75 d6                	jne    f010e40c <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f010e436:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f010e43a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f010e441:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f010e448:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f010e44f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f010e456:	8b 45 10             	mov    0x10(%ebp),%eax
f010e459:	8d 50 01             	lea    0x1(%eax),%edx
f010e45c:	89 55 10             	mov    %edx,0x10(%ebp)
f010e45f:	8a 00                	mov    (%eax),%al
f010e461:	0f b6 d8             	movzbl %al,%ebx
f010e464:	8d 43 dd             	lea    -0x23(%ebx),%eax
f010e467:	83 f8 55             	cmp    $0x55,%eax
f010e46a:	0f 87 2b 03 00 00    	ja     f010e79b <vprintfmt+0x399>
f010e470:	8b 04 85 b8 29 11 f0 	mov    -0xfeed648(,%eax,4),%eax
f010e477:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f010e479:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f010e47d:	eb d7                	jmp    f010e456 <vprintfmt+0x54>
			
		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f010e47f:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f010e483:	eb d1                	jmp    f010e456 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f010e485:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f010e48c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e48f:	89 d0                	mov    %edx,%eax
f010e491:	c1 e0 02             	shl    $0x2,%eax
f010e494:	01 d0                	add    %edx,%eax
f010e496:	01 c0                	add    %eax,%eax
f010e498:	01 d8                	add    %ebx,%eax
f010e49a:	83 e8 30             	sub    $0x30,%eax
f010e49d:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f010e4a0:	8b 45 10             	mov    0x10(%ebp),%eax
f010e4a3:	8a 00                	mov    (%eax),%al
f010e4a5:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f010e4a8:	83 fb 2f             	cmp    $0x2f,%ebx
f010e4ab:	7e 3e                	jle    f010e4eb <vprintfmt+0xe9>
f010e4ad:	83 fb 39             	cmp    $0x39,%ebx
f010e4b0:	7f 39                	jg     f010e4eb <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f010e4b2:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f010e4b5:	eb d5                	jmp    f010e48c <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f010e4b7:	8b 45 14             	mov    0x14(%ebp),%eax
f010e4ba:	83 c0 04             	add    $0x4,%eax
f010e4bd:	89 45 14             	mov    %eax,0x14(%ebp)
f010e4c0:	8b 45 14             	mov    0x14(%ebp),%eax
f010e4c3:	83 e8 04             	sub    $0x4,%eax
f010e4c6:	8b 00                	mov    (%eax),%eax
f010e4c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f010e4cb:	eb 1f                	jmp    f010e4ec <vprintfmt+0xea>

		case '.':
			if (width < 0)
f010e4cd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e4d1:	79 83                	jns    f010e456 <vprintfmt+0x54>
				width = 0;
f010e4d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f010e4da:	e9 77 ff ff ff       	jmp    f010e456 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f010e4df:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f010e4e6:	e9 6b ff ff ff       	jmp    f010e456 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f010e4eb:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f010e4ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e4f0:	0f 89 60 ff ff ff    	jns    f010e456 <vprintfmt+0x54>
				width = precision, precision = -1;
f010e4f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e4f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010e4fc:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f010e503:	e9 4e ff ff ff       	jmp    f010e456 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f010e508:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f010e50b:	e9 46 ff ff ff       	jmp    f010e456 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f010e510:	8b 45 14             	mov    0x14(%ebp),%eax
f010e513:	83 c0 04             	add    $0x4,%eax
f010e516:	89 45 14             	mov    %eax,0x14(%ebp)
f010e519:	8b 45 14             	mov    0x14(%ebp),%eax
f010e51c:	83 e8 04             	sub    $0x4,%eax
f010e51f:	8b 00                	mov    (%eax),%eax
f010e521:	83 ec 08             	sub    $0x8,%esp
f010e524:	ff 75 0c             	pushl  0xc(%ebp)
f010e527:	50                   	push   %eax
f010e528:	8b 45 08             	mov    0x8(%ebp),%eax
f010e52b:	ff d0                	call   *%eax
f010e52d:	83 c4 10             	add    $0x10,%esp
			break;
f010e530:	e9 89 02 00 00       	jmp    f010e7be <vprintfmt+0x3bc>

		// error message
		case 'e':
			err = va_arg(ap, int);
f010e535:	8b 45 14             	mov    0x14(%ebp),%eax
f010e538:	83 c0 04             	add    $0x4,%eax
f010e53b:	89 45 14             	mov    %eax,0x14(%ebp)
f010e53e:	8b 45 14             	mov    0x14(%ebp),%eax
f010e541:	83 e8 04             	sub    $0x4,%eax
f010e544:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f010e546:	85 db                	test   %ebx,%ebx
f010e548:	79 02                	jns    f010e54c <vprintfmt+0x14a>
				err = -err;
f010e54a:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f010e54c:	83 fb 64             	cmp    $0x64,%ebx
f010e54f:	7f 0b                	jg     f010e55c <vprintfmt+0x15a>
f010e551:	8b 34 9d 00 28 11 f0 	mov    -0xfeed800(,%ebx,4),%esi
f010e558:	85 f6                	test   %esi,%esi
f010e55a:	75 19                	jne    f010e575 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f010e55c:	53                   	push   %ebx
f010e55d:	68 a5 29 11 f0       	push   $0xf01129a5
f010e562:	ff 75 0c             	pushl  0xc(%ebp)
f010e565:	ff 75 08             	pushl  0x8(%ebp)
f010e568:	e8 5e 02 00 00       	call   f010e7cb <printfmt>
f010e56d:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f010e570:	e9 49 02 00 00       	jmp    f010e7be <vprintfmt+0x3bc>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f010e575:	56                   	push   %esi
f010e576:	68 ae 29 11 f0       	push   $0xf01129ae
f010e57b:	ff 75 0c             	pushl  0xc(%ebp)
f010e57e:	ff 75 08             	pushl  0x8(%ebp)
f010e581:	e8 45 02 00 00       	call   f010e7cb <printfmt>
f010e586:	83 c4 10             	add    $0x10,%esp
			break;
f010e589:	e9 30 02 00 00       	jmp    f010e7be <vprintfmt+0x3bc>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f010e58e:	8b 45 14             	mov    0x14(%ebp),%eax
f010e591:	83 c0 04             	add    $0x4,%eax
f010e594:	89 45 14             	mov    %eax,0x14(%ebp)
f010e597:	8b 45 14             	mov    0x14(%ebp),%eax
f010e59a:	83 e8 04             	sub    $0x4,%eax
f010e59d:	8b 30                	mov    (%eax),%esi
f010e59f:	85 f6                	test   %esi,%esi
f010e5a1:	75 05                	jne    f010e5a8 <vprintfmt+0x1a6>
				p = "(null)";
f010e5a3:	be b1 29 11 f0       	mov    $0xf01129b1,%esi
			if (width > 0 && padc != '-')
f010e5a8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e5ac:	7e 6d                	jle    f010e61b <vprintfmt+0x219>
f010e5ae:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f010e5b2:	74 67                	je     f010e61b <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f010e5b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e5b7:	83 ec 08             	sub    $0x8,%esp
f010e5ba:	50                   	push   %eax
f010e5bb:	56                   	push   %esi
f010e5bc:	e8 12 05 00 00       	call   f010ead3 <strnlen>
f010e5c1:	83 c4 10             	add    $0x10,%esp
f010e5c4:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f010e5c7:	eb 16                	jmp    f010e5df <vprintfmt+0x1dd>
					putch(padc, putdat);
f010e5c9:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f010e5cd:	83 ec 08             	sub    $0x8,%esp
f010e5d0:	ff 75 0c             	pushl  0xc(%ebp)
f010e5d3:	50                   	push   %eax
f010e5d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5d7:	ff d0                	call   *%eax
f010e5d9:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f010e5dc:	ff 4d e4             	decl   -0x1c(%ebp)
f010e5df:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e5e3:	7f e4                	jg     f010e5c9 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f010e5e5:	eb 34                	jmp    f010e61b <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f010e5e7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010e5eb:	74 1c                	je     f010e609 <vprintfmt+0x207>
f010e5ed:	83 fb 1f             	cmp    $0x1f,%ebx
f010e5f0:	7e 05                	jle    f010e5f7 <vprintfmt+0x1f5>
f010e5f2:	83 fb 7e             	cmp    $0x7e,%ebx
f010e5f5:	7e 12                	jle    f010e609 <vprintfmt+0x207>
					putch('?', putdat);
f010e5f7:	83 ec 08             	sub    $0x8,%esp
f010e5fa:	ff 75 0c             	pushl  0xc(%ebp)
f010e5fd:	6a 3f                	push   $0x3f
f010e5ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010e602:	ff d0                	call   *%eax
f010e604:	83 c4 10             	add    $0x10,%esp
f010e607:	eb 0f                	jmp    f010e618 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f010e609:	83 ec 08             	sub    $0x8,%esp
f010e60c:	ff 75 0c             	pushl  0xc(%ebp)
f010e60f:	53                   	push   %ebx
f010e610:	8b 45 08             	mov    0x8(%ebp),%eax
f010e613:	ff d0                	call   *%eax
f010e615:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f010e618:	ff 4d e4             	decl   -0x1c(%ebp)
f010e61b:	89 f0                	mov    %esi,%eax
f010e61d:	8d 70 01             	lea    0x1(%eax),%esi
f010e620:	8a 00                	mov    (%eax),%al
f010e622:	0f be d8             	movsbl %al,%ebx
f010e625:	85 db                	test   %ebx,%ebx
f010e627:	74 24                	je     f010e64d <vprintfmt+0x24b>
f010e629:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e62d:	78 b8                	js     f010e5e7 <vprintfmt+0x1e5>
f010e62f:	ff 4d e0             	decl   -0x20(%ebp)
f010e632:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e636:	79 af                	jns    f010e5e7 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f010e638:	eb 13                	jmp    f010e64d <vprintfmt+0x24b>
				putch(' ', putdat);
f010e63a:	83 ec 08             	sub    $0x8,%esp
f010e63d:	ff 75 0c             	pushl  0xc(%ebp)
f010e640:	6a 20                	push   $0x20
f010e642:	8b 45 08             	mov    0x8(%ebp),%eax
f010e645:	ff d0                	call   *%eax
f010e647:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f010e64a:	ff 4d e4             	decl   -0x1c(%ebp)
f010e64d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e651:	7f e7                	jg     f010e63a <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f010e653:	e9 66 01 00 00       	jmp    f010e7be <vprintfmt+0x3bc>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f010e658:	83 ec 08             	sub    $0x8,%esp
f010e65b:	ff 75 e8             	pushl  -0x18(%ebp)
f010e65e:	8d 45 14             	lea    0x14(%ebp),%eax
f010e661:	50                   	push   %eax
f010e662:	e8 3c fd ff ff       	call   f010e3a3 <getint>
f010e667:	83 c4 10             	add    $0x10,%esp
f010e66a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e66d:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f010e670:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e673:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e676:	85 d2                	test   %edx,%edx
f010e678:	79 23                	jns    f010e69d <vprintfmt+0x29b>
				putch('-', putdat);
f010e67a:	83 ec 08             	sub    $0x8,%esp
f010e67d:	ff 75 0c             	pushl  0xc(%ebp)
f010e680:	6a 2d                	push   $0x2d
f010e682:	8b 45 08             	mov    0x8(%ebp),%eax
f010e685:	ff d0                	call   *%eax
f010e687:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f010e68a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e68d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e690:	f7 d8                	neg    %eax
f010e692:	83 d2 00             	adc    $0x0,%edx
f010e695:	f7 da                	neg    %edx
f010e697:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e69a:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f010e69d:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f010e6a4:	e9 bc 00 00 00       	jmp    f010e765 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f010e6a9:	83 ec 08             	sub    $0x8,%esp
f010e6ac:	ff 75 e8             	pushl  -0x18(%ebp)
f010e6af:	8d 45 14             	lea    0x14(%ebp),%eax
f010e6b2:	50                   	push   %eax
f010e6b3:	e8 84 fc ff ff       	call   f010e33c <getuint>
f010e6b8:	83 c4 10             	add    $0x10,%esp
f010e6bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e6be:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f010e6c1:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f010e6c8:	e9 98 00 00 00       	jmp    f010e765 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f010e6cd:	83 ec 08             	sub    $0x8,%esp
f010e6d0:	ff 75 0c             	pushl  0xc(%ebp)
f010e6d3:	6a 58                	push   $0x58
f010e6d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6d8:	ff d0                	call   *%eax
f010e6da:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f010e6dd:	83 ec 08             	sub    $0x8,%esp
f010e6e0:	ff 75 0c             	pushl  0xc(%ebp)
f010e6e3:	6a 58                	push   $0x58
f010e6e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6e8:	ff d0                	call   *%eax
f010e6ea:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f010e6ed:	83 ec 08             	sub    $0x8,%esp
f010e6f0:	ff 75 0c             	pushl  0xc(%ebp)
f010e6f3:	6a 58                	push   $0x58
f010e6f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6f8:	ff d0                	call   *%eax
f010e6fa:	83 c4 10             	add    $0x10,%esp
			break;
f010e6fd:	e9 bc 00 00 00       	jmp    f010e7be <vprintfmt+0x3bc>

		// pointer
		case 'p':
			putch('0', putdat);
f010e702:	83 ec 08             	sub    $0x8,%esp
f010e705:	ff 75 0c             	pushl  0xc(%ebp)
f010e708:	6a 30                	push   $0x30
f010e70a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e70d:	ff d0                	call   *%eax
f010e70f:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f010e712:	83 ec 08             	sub    $0x8,%esp
f010e715:	ff 75 0c             	pushl  0xc(%ebp)
f010e718:	6a 78                	push   $0x78
f010e71a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e71d:	ff d0                	call   *%eax
f010e71f:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f010e722:	8b 45 14             	mov    0x14(%ebp),%eax
f010e725:	83 c0 04             	add    $0x4,%eax
f010e728:	89 45 14             	mov    %eax,0x14(%ebp)
f010e72b:	8b 45 14             	mov    0x14(%ebp),%eax
f010e72e:	83 e8 04             	sub    $0x4,%eax
f010e731:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f010e733:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e736:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f010e73d:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f010e744:	eb 1f                	jmp    f010e765 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f010e746:	83 ec 08             	sub    $0x8,%esp
f010e749:	ff 75 e8             	pushl  -0x18(%ebp)
f010e74c:	8d 45 14             	lea    0x14(%ebp),%eax
f010e74f:	50                   	push   %eax
f010e750:	e8 e7 fb ff ff       	call   f010e33c <getuint>
f010e755:	83 c4 10             	add    $0x10,%esp
f010e758:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e75b:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f010e75e:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f010e765:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010e769:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e76c:	83 ec 04             	sub    $0x4,%esp
f010e76f:	52                   	push   %edx
f010e770:	ff 75 e4             	pushl  -0x1c(%ebp)
f010e773:	50                   	push   %eax
f010e774:	ff 75 f4             	pushl  -0xc(%ebp)
f010e777:	ff 75 f0             	pushl  -0x10(%ebp)
f010e77a:	ff 75 0c             	pushl  0xc(%ebp)
f010e77d:	ff 75 08             	pushl  0x8(%ebp)
f010e780:	e8 00 fb ff ff       	call   f010e285 <printnum>
f010e785:	83 c4 20             	add    $0x20,%esp
			break;
f010e788:	eb 34                	jmp    f010e7be <vprintfmt+0x3bc>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f010e78a:	83 ec 08             	sub    $0x8,%esp
f010e78d:	ff 75 0c             	pushl  0xc(%ebp)
f010e790:	53                   	push   %ebx
f010e791:	8b 45 08             	mov    0x8(%ebp),%eax
f010e794:	ff d0                	call   *%eax
f010e796:	83 c4 10             	add    $0x10,%esp
			break;
f010e799:	eb 23                	jmp    f010e7be <vprintfmt+0x3bc>
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f010e79b:	83 ec 08             	sub    $0x8,%esp
f010e79e:	ff 75 0c             	pushl  0xc(%ebp)
f010e7a1:	6a 25                	push   $0x25
f010e7a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7a6:	ff d0                	call   *%eax
f010e7a8:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f010e7ab:	ff 4d 10             	decl   0x10(%ebp)
f010e7ae:	eb 03                	jmp    f010e7b3 <vprintfmt+0x3b1>
f010e7b0:	ff 4d 10             	decl   0x10(%ebp)
f010e7b3:	8b 45 10             	mov    0x10(%ebp),%eax
f010e7b6:	48                   	dec    %eax
f010e7b7:	8a 00                	mov    (%eax),%al
f010e7b9:	3c 25                	cmp    $0x25,%al
f010e7bb:	75 f3                	jne    f010e7b0 <vprintfmt+0x3ae>
				/* do nothing */;
			break;
f010e7bd:	90                   	nop
		}
	}
f010e7be:	e9 47 fc ff ff       	jmp    f010e40a <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f010e7c3:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f010e7c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010e7c7:	5b                   	pop    %ebx
f010e7c8:	5e                   	pop    %esi
f010e7c9:	5d                   	pop    %ebp
f010e7ca:	c3                   	ret    

f010e7cb <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f010e7cb:	55                   	push   %ebp
f010e7cc:	89 e5                	mov    %esp,%ebp
f010e7ce:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f010e7d1:	8d 45 10             	lea    0x10(%ebp),%eax
f010e7d4:	83 c0 04             	add    $0x4,%eax
f010e7d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f010e7da:	8b 45 10             	mov    0x10(%ebp),%eax
f010e7dd:	ff 75 f4             	pushl  -0xc(%ebp)
f010e7e0:	50                   	push   %eax
f010e7e1:	ff 75 0c             	pushl  0xc(%ebp)
f010e7e4:	ff 75 08             	pushl  0x8(%ebp)
f010e7e7:	e8 16 fc ff ff       	call   f010e402 <vprintfmt>
f010e7ec:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010e7ef:	90                   	nop
f010e7f0:	c9                   	leave  
f010e7f1:	c3                   	ret    

f010e7f2 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f010e7f2:	55                   	push   %ebp
f010e7f3:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f010e7f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7f8:	8b 40 08             	mov    0x8(%eax),%eax
f010e7fb:	8d 50 01             	lea    0x1(%eax),%edx
f010e7fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e801:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f010e804:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e807:	8b 10                	mov    (%eax),%edx
f010e809:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e80c:	8b 40 04             	mov    0x4(%eax),%eax
f010e80f:	39 c2                	cmp    %eax,%edx
f010e811:	73 12                	jae    f010e825 <sprintputch+0x33>
		*b->buf++ = ch;
f010e813:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e816:	8b 00                	mov    (%eax),%eax
f010e818:	8d 48 01             	lea    0x1(%eax),%ecx
f010e81b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e81e:	89 0a                	mov    %ecx,(%edx)
f010e820:	8b 55 08             	mov    0x8(%ebp),%edx
f010e823:	88 10                	mov    %dl,(%eax)
}
f010e825:	90                   	nop
f010e826:	5d                   	pop    %ebp
f010e827:	c3                   	ret    

f010e828 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f010e828:	55                   	push   %ebp
f010e829:	89 e5                	mov    %esp,%ebp
f010e82b:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f010e82e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e831:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010e834:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e837:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e83a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e83d:	01 d0                	add    %edx,%eax
f010e83f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e842:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f010e849:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e84d:	74 06                	je     f010e855 <vsnprintf+0x2d>
f010e84f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010e853:	7f 07                	jg     f010e85c <vsnprintf+0x34>
		return -E_INVAL;
f010e855:	b8 03 00 00 00       	mov    $0x3,%eax
f010e85a:	eb 20                	jmp    f010e87c <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f010e85c:	ff 75 14             	pushl  0x14(%ebp)
f010e85f:	ff 75 10             	pushl  0x10(%ebp)
f010e862:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e865:	50                   	push   %eax
f010e866:	68 f2 e7 10 f0       	push   $0xf010e7f2
f010e86b:	e8 92 fb ff ff       	call   f010e402 <vprintfmt>
f010e870:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f010e873:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e876:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f010e879:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e87c:	c9                   	leave  
f010e87d:	c3                   	ret    

f010e87e <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f010e87e:	55                   	push   %ebp
f010e87f:	89 e5                	mov    %esp,%ebp
f010e881:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f010e884:	8d 45 10             	lea    0x10(%ebp),%eax
f010e887:	83 c0 04             	add    $0x4,%eax
f010e88a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f010e88d:	8b 45 10             	mov    0x10(%ebp),%eax
f010e890:	ff 75 f4             	pushl  -0xc(%ebp)
f010e893:	50                   	push   %eax
f010e894:	ff 75 0c             	pushl  0xc(%ebp)
f010e897:	ff 75 08             	pushl  0x8(%ebp)
f010e89a:	e8 89 ff ff ff       	call   f010e828 <vsnprintf>
f010e89f:	83 c4 10             	add    $0x10,%esp
f010e8a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f010e8a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010e8a8:	c9                   	leave  
f010e8a9:	c3                   	ret    

f010e8aa <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f010e8aa:	55                   	push   %ebp
f010e8ab:	89 e5                	mov    %esp,%ebp
f010e8ad:	83 ec 18             	sub    $0x18,%esp
		int i, c, echoing;

	if (prompt != NULL)
f010e8b0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e8b4:	74 13                	je     f010e8c9 <readline+0x1f>
		cprintf("%s", prompt);
f010e8b6:	83 ec 08             	sub    $0x8,%esp
f010e8b9:	ff 75 08             	pushl  0x8(%ebp)
f010e8bc:	68 10 2b 11 f0       	push   $0xf0112b10
f010e8c1:	e8 95 77 ff ff       	call   f010605b <cprintf>
f010e8c6:	83 c4 10             	add    $0x10,%esp

	i = 0;
f010e8c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f010e8d0:	83 ec 0c             	sub    $0xc,%esp
f010e8d3:	6a 00                	push   $0x0
f010e8d5:	e8 99 21 ff ff       	call   f0100a73 <iscons>
f010e8da:	83 c4 10             	add    $0x10,%esp
f010e8dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f010e8e0:	e8 75 21 ff ff       	call   f0100a5a <getchar>
f010e8e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f010e8e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010e8ec:	79 22                	jns    f010e910 <readline+0x66>
			if (c != -E_EOF)
f010e8ee:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f010e8f2:	0f 84 ad 00 00 00    	je     f010e9a5 <readline+0xfb>
				cprintf("read error: %e\n", c);
f010e8f8:	83 ec 08             	sub    $0x8,%esp
f010e8fb:	ff 75 ec             	pushl  -0x14(%ebp)
f010e8fe:	68 13 2b 11 f0       	push   $0xf0112b13
f010e903:	e8 53 77 ff ff       	call   f010605b <cprintf>
f010e908:	83 c4 10             	add    $0x10,%esp
			return;
f010e90b:	e9 95 00 00 00       	jmp    f010e9a5 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f010e910:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f010e914:	7e 34                	jle    f010e94a <readline+0xa0>
f010e916:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f010e91d:	7f 2b                	jg     f010e94a <readline+0xa0>
			if (echoing)
f010e91f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e923:	74 0e                	je     f010e933 <readline+0x89>
				cputchar(c);
f010e925:	83 ec 0c             	sub    $0xc,%esp
f010e928:	ff 75 ec             	pushl  -0x14(%ebp)
f010e92b:	e8 13 21 ff ff       	call   f0100a43 <cputchar>
f010e930:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f010e933:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e936:	8d 50 01             	lea    0x1(%eax),%edx
f010e939:	89 55 f4             	mov    %edx,-0xc(%ebp)
f010e93c:	89 c2                	mov    %eax,%edx
f010e93e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e941:	01 d0                	add    %edx,%eax
f010e943:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e946:	88 10                	mov    %dl,(%eax)
f010e948:	eb 56                	jmp    f010e9a0 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f010e94a:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f010e94e:	75 1f                	jne    f010e96f <readline+0xc5>
f010e950:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e954:	7e 19                	jle    f010e96f <readline+0xc5>
			if (echoing)
f010e956:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e95a:	74 0e                	je     f010e96a <readline+0xc0>
				cputchar(c);
f010e95c:	83 ec 0c             	sub    $0xc,%esp
f010e95f:	ff 75 ec             	pushl  -0x14(%ebp)
f010e962:	e8 dc 20 ff ff       	call   f0100a43 <cputchar>
f010e967:	83 c4 10             	add    $0x10,%esp

			i--;
f010e96a:	ff 4d f4             	decl   -0xc(%ebp)
f010e96d:	eb 31                	jmp    f010e9a0 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f010e96f:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f010e973:	74 0a                	je     f010e97f <readline+0xd5>
f010e975:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f010e979:	0f 85 61 ff ff ff    	jne    f010e8e0 <readline+0x36>
			if (echoing)
f010e97f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e983:	74 0e                	je     f010e993 <readline+0xe9>
				cputchar(c);
f010e985:	83 ec 0c             	sub    $0xc,%esp
f010e988:	ff 75 ec             	pushl  -0x14(%ebp)
f010e98b:	e8 b3 20 ff ff       	call   f0100a43 <cputchar>
f010e990:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f010e993:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e996:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e999:	01 d0                	add    %edx,%eax
f010e99b:	c6 00 00             	movb   $0x0,(%eax)
			return;
f010e99e:	eb 06                	jmp    f010e9a6 <readline+0xfc>
		}
	}
f010e9a0:	e9 3b ff ff ff       	jmp    f010e8e0 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f010e9a5:	90                   	nop
			buf[i] = 0;
			return;
		}
	}

}
f010e9a6:	c9                   	leave  
f010e9a7:	c3                   	ret    

f010e9a8 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f010e9a8:	55                   	push   %ebp
f010e9a9:	89 e5                	mov    %esp,%ebp
f010e9ab:	83 ec 18             	sub    $0x18,%esp
	sys_disable_interrupt();
f010e9ae:	e8 ec a7 ff ff       	call   f010919f <sys_disable_interrupt>
	int i, c, echoing;

	if (prompt != NULL)
f010e9b3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e9b7:	74 13                	je     f010e9cc <atomic_readline+0x24>
		cprintf("%s", prompt);
f010e9b9:	83 ec 08             	sub    $0x8,%esp
f010e9bc:	ff 75 08             	pushl  0x8(%ebp)
f010e9bf:	68 10 2b 11 f0       	push   $0xf0112b10
f010e9c4:	e8 92 76 ff ff       	call   f010605b <cprintf>
f010e9c9:	83 c4 10             	add    $0x10,%esp

	i = 0;
f010e9cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f010e9d3:	83 ec 0c             	sub    $0xc,%esp
f010e9d6:	6a 00                	push   $0x0
f010e9d8:	e8 96 20 ff ff       	call   f0100a73 <iscons>
f010e9dd:	83 c4 10             	add    $0x10,%esp
f010e9e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f010e9e3:	e8 72 20 ff ff       	call   f0100a5a <getchar>
f010e9e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f010e9eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010e9ef:	79 23                	jns    f010ea14 <atomic_readline+0x6c>
			if (c != -E_EOF)
f010e9f1:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f010e9f5:	74 13                	je     f010ea0a <atomic_readline+0x62>
				cprintf("read error: %e\n", c);
f010e9f7:	83 ec 08             	sub    $0x8,%esp
f010e9fa:	ff 75 ec             	pushl  -0x14(%ebp)
f010e9fd:	68 13 2b 11 f0       	push   $0xf0112b13
f010ea02:	e8 54 76 ff ff       	call   f010605b <cprintf>
f010ea07:	83 c4 10             	add    $0x10,%esp
			sys_enable_interrupt();
f010ea0a:	e8 aa a7 ff ff       	call   f01091b9 <sys_enable_interrupt>
			return;
f010ea0f:	e9 9a 00 00 00       	jmp    f010eaae <atomic_readline+0x106>
		} else if (c >= ' ' && i < BUFLEN-1) {
f010ea14:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f010ea18:	7e 34                	jle    f010ea4e <atomic_readline+0xa6>
f010ea1a:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f010ea21:	7f 2b                	jg     f010ea4e <atomic_readline+0xa6>
			if (echoing)
f010ea23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ea27:	74 0e                	je     f010ea37 <atomic_readline+0x8f>
				cputchar(c);
f010ea29:	83 ec 0c             	sub    $0xc,%esp
f010ea2c:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea2f:	e8 0f 20 ff ff       	call   f0100a43 <cputchar>
f010ea34:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f010ea37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea3a:	8d 50 01             	lea    0x1(%eax),%edx
f010ea3d:	89 55 f4             	mov    %edx,-0xc(%ebp)
f010ea40:	89 c2                	mov    %eax,%edx
f010ea42:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea45:	01 d0                	add    %edx,%eax
f010ea47:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ea4a:	88 10                	mov    %dl,(%eax)
f010ea4c:	eb 5b                	jmp    f010eaa9 <atomic_readline+0x101>
		} else if (c == '\b' && i > 0) {
f010ea4e:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f010ea52:	75 1f                	jne    f010ea73 <atomic_readline+0xcb>
f010ea54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ea58:	7e 19                	jle    f010ea73 <atomic_readline+0xcb>
			if (echoing)
f010ea5a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ea5e:	74 0e                	je     f010ea6e <atomic_readline+0xc6>
				cputchar(c);
f010ea60:	83 ec 0c             	sub    $0xc,%esp
f010ea63:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea66:	e8 d8 1f ff ff       	call   f0100a43 <cputchar>
f010ea6b:	83 c4 10             	add    $0x10,%esp
			i--;
f010ea6e:	ff 4d f4             	decl   -0xc(%ebp)
f010ea71:	eb 36                	jmp    f010eaa9 <atomic_readline+0x101>
		} else if (c == '\n' || c == '\r') {
f010ea73:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f010ea77:	74 0a                	je     f010ea83 <atomic_readline+0xdb>
f010ea79:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f010ea7d:	0f 85 60 ff ff ff    	jne    f010e9e3 <atomic_readline+0x3b>
			if (echoing)
f010ea83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ea87:	74 0e                	je     f010ea97 <atomic_readline+0xef>
				cputchar(c);
f010ea89:	83 ec 0c             	sub    $0xc,%esp
f010ea8c:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea8f:	e8 af 1f ff ff       	call   f0100a43 <cputchar>
f010ea94:	83 c4 10             	add    $0x10,%esp
			buf[i] = 0;
f010ea97:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ea9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea9d:	01 d0                	add    %edx,%eax
f010ea9f:	c6 00 00             	movb   $0x0,(%eax)
			sys_enable_interrupt();
f010eaa2:	e8 12 a7 ff ff       	call   f01091b9 <sys_enable_interrupt>
			return;
f010eaa7:	eb 05                	jmp    f010eaae <atomic_readline+0x106>
		}
	}
f010eaa9:	e9 35 ff ff ff       	jmp    f010e9e3 <atomic_readline+0x3b>
}
f010eaae:	c9                   	leave  
f010eaaf:	c3                   	ret    

f010eab0 <strlen>:

#include <inc/string.h>

int
strlen(const char *s)
{
f010eab0:	55                   	push   %ebp
f010eab1:	89 e5                	mov    %esp,%ebp
f010eab3:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f010eab6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010eabd:	eb 06                	jmp    f010eac5 <strlen+0x15>
		n++;
f010eabf:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f010eac2:	ff 45 08             	incl   0x8(%ebp)
f010eac5:	8b 45 08             	mov    0x8(%ebp),%eax
f010eac8:	8a 00                	mov    (%eax),%al
f010eaca:	84 c0                	test   %al,%al
f010eacc:	75 f1                	jne    f010eabf <strlen+0xf>
		n++;
	return n;
f010eace:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f010ead1:	c9                   	leave  
f010ead2:	c3                   	ret    

f010ead3 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f010ead3:	55                   	push   %ebp
f010ead4:	89 e5                	mov    %esp,%ebp
f010ead6:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f010ead9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010eae0:	eb 09                	jmp    f010eaeb <strnlen+0x18>
		n++;
f010eae2:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f010eae5:	ff 45 08             	incl   0x8(%ebp)
f010eae8:	ff 4d 0c             	decl   0xc(%ebp)
f010eaeb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010eaef:	74 09                	je     f010eafa <strnlen+0x27>
f010eaf1:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf4:	8a 00                	mov    (%eax),%al
f010eaf6:	84 c0                	test   %al,%al
f010eaf8:	75 e8                	jne    f010eae2 <strnlen+0xf>
		n++;
	return n;
f010eafa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f010eafd:	c9                   	leave  
f010eafe:	c3                   	ret    

f010eaff <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f010eaff:	55                   	push   %ebp
f010eb00:	89 e5                	mov    %esp,%ebp
f010eb02:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f010eb05:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb08:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f010eb0b:	90                   	nop
f010eb0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb0f:	8d 50 01             	lea    0x1(%eax),%edx
f010eb12:	89 55 08             	mov    %edx,0x8(%ebp)
f010eb15:	8b 55 0c             	mov    0xc(%ebp),%edx
f010eb18:	8d 4a 01             	lea    0x1(%edx),%ecx
f010eb1b:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f010eb1e:	8a 12                	mov    (%edx),%dl
f010eb20:	88 10                	mov    %dl,(%eax)
f010eb22:	8a 00                	mov    (%eax),%al
f010eb24:	84 c0                	test   %al,%al
f010eb26:	75 e4                	jne    f010eb0c <strcpy+0xd>
		/* do nothing */;
	return ret;
f010eb28:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f010eb2b:	c9                   	leave  
f010eb2c:	c3                   	ret    

f010eb2d <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f010eb2d:	55                   	push   %ebp
f010eb2e:	89 e5                	mov    %esp,%ebp
f010eb30:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f010eb33:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb36:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f010eb39:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010eb40:	eb 1f                	jmp    f010eb61 <strncpy+0x34>
		*dst++ = *src;
f010eb42:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb45:	8d 50 01             	lea    0x1(%eax),%edx
f010eb48:	89 55 08             	mov    %edx,0x8(%ebp)
f010eb4b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010eb4e:	8a 12                	mov    (%edx),%dl
f010eb50:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f010eb52:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb55:	8a 00                	mov    (%eax),%al
f010eb57:	84 c0                	test   %al,%al
f010eb59:	74 03                	je     f010eb5e <strncpy+0x31>
			src++;
f010eb5b:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f010eb5e:	ff 45 fc             	incl   -0x4(%ebp)
f010eb61:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010eb64:	3b 45 10             	cmp    0x10(%ebp),%eax
f010eb67:	72 d9                	jb     f010eb42 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f010eb69:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010eb6c:	c9                   	leave  
f010eb6d:	c3                   	ret    

f010eb6e <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f010eb6e:	55                   	push   %ebp
f010eb6f:	89 e5                	mov    %esp,%ebp
f010eb71:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f010eb74:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb77:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f010eb7a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010eb7e:	74 30                	je     f010ebb0 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f010eb80:	eb 16                	jmp    f010eb98 <strlcpy+0x2a>
			*dst++ = *src++;
f010eb82:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb85:	8d 50 01             	lea    0x1(%eax),%edx
f010eb88:	89 55 08             	mov    %edx,0x8(%ebp)
f010eb8b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010eb8e:	8d 4a 01             	lea    0x1(%edx),%ecx
f010eb91:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f010eb94:	8a 12                	mov    (%edx),%dl
f010eb96:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f010eb98:	ff 4d 10             	decl   0x10(%ebp)
f010eb9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010eb9f:	74 09                	je     f010ebaa <strlcpy+0x3c>
f010eba1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eba4:	8a 00                	mov    (%eax),%al
f010eba6:	84 c0                	test   %al,%al
f010eba8:	75 d8                	jne    f010eb82 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f010ebaa:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebad:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f010ebb0:	8b 55 08             	mov    0x8(%ebp),%edx
f010ebb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ebb6:	29 c2                	sub    %eax,%edx
f010ebb8:	89 d0                	mov    %edx,%eax
}
f010ebba:	c9                   	leave  
f010ebbb:	c3                   	ret    

f010ebbc <strcmp>:

int
strcmp(const char *p, const char *q)
{
f010ebbc:	55                   	push   %ebp
f010ebbd:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f010ebbf:	eb 06                	jmp    f010ebc7 <strcmp+0xb>
		p++, q++;
f010ebc1:	ff 45 08             	incl   0x8(%ebp)
f010ebc4:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f010ebc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebca:	8a 00                	mov    (%eax),%al
f010ebcc:	84 c0                	test   %al,%al
f010ebce:	74 0e                	je     f010ebde <strcmp+0x22>
f010ebd0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebd3:	8a 10                	mov    (%eax),%dl
f010ebd5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebd8:	8a 00                	mov    (%eax),%al
f010ebda:	38 c2                	cmp    %al,%dl
f010ebdc:	74 e3                	je     f010ebc1 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f010ebde:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebe1:	8a 00                	mov    (%eax),%al
f010ebe3:	0f b6 d0             	movzbl %al,%edx
f010ebe6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebe9:	8a 00                	mov    (%eax),%al
f010ebeb:	0f b6 c0             	movzbl %al,%eax
f010ebee:	29 c2                	sub    %eax,%edx
f010ebf0:	89 d0                	mov    %edx,%eax
}
f010ebf2:	5d                   	pop    %ebp
f010ebf3:	c3                   	ret    

f010ebf4 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f010ebf4:	55                   	push   %ebp
f010ebf5:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f010ebf7:	eb 09                	jmp    f010ec02 <strncmp+0xe>
		n--, p++, q++;
f010ebf9:	ff 4d 10             	decl   0x10(%ebp)
f010ebfc:	ff 45 08             	incl   0x8(%ebp)
f010ebff:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f010ec02:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010ec06:	74 17                	je     f010ec1f <strncmp+0x2b>
f010ec08:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec0b:	8a 00                	mov    (%eax),%al
f010ec0d:	84 c0                	test   %al,%al
f010ec0f:	74 0e                	je     f010ec1f <strncmp+0x2b>
f010ec11:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec14:	8a 10                	mov    (%eax),%dl
f010ec16:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec19:	8a 00                	mov    (%eax),%al
f010ec1b:	38 c2                	cmp    %al,%dl
f010ec1d:	74 da                	je     f010ebf9 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f010ec1f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010ec23:	75 07                	jne    f010ec2c <strncmp+0x38>
		return 0;
f010ec25:	b8 00 00 00 00       	mov    $0x0,%eax
f010ec2a:	eb 14                	jmp    f010ec40 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f010ec2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec2f:	8a 00                	mov    (%eax),%al
f010ec31:	0f b6 d0             	movzbl %al,%edx
f010ec34:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec37:	8a 00                	mov    (%eax),%al
f010ec39:	0f b6 c0             	movzbl %al,%eax
f010ec3c:	29 c2                	sub    %eax,%edx
f010ec3e:	89 d0                	mov    %edx,%eax
}
f010ec40:	5d                   	pop    %ebp
f010ec41:	c3                   	ret    

f010ec42 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f010ec42:	55                   	push   %ebp
f010ec43:	89 e5                	mov    %esp,%ebp
f010ec45:	83 ec 04             	sub    $0x4,%esp
f010ec48:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec4b:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f010ec4e:	eb 12                	jmp    f010ec62 <strchr+0x20>
		if (*s == c)
f010ec50:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec53:	8a 00                	mov    (%eax),%al
f010ec55:	3a 45 fc             	cmp    -0x4(%ebp),%al
f010ec58:	75 05                	jne    f010ec5f <strchr+0x1d>
			return (char *) s;
f010ec5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec5d:	eb 11                	jmp    f010ec70 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f010ec5f:	ff 45 08             	incl   0x8(%ebp)
f010ec62:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec65:	8a 00                	mov    (%eax),%al
f010ec67:	84 c0                	test   %al,%al
f010ec69:	75 e5                	jne    f010ec50 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f010ec6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ec70:	c9                   	leave  
f010ec71:	c3                   	ret    

f010ec72 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f010ec72:	55                   	push   %ebp
f010ec73:	89 e5                	mov    %esp,%ebp
f010ec75:	83 ec 04             	sub    $0x4,%esp
f010ec78:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec7b:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f010ec7e:	eb 0d                	jmp    f010ec8d <strfind+0x1b>
		if (*s == c)
f010ec80:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec83:	8a 00                	mov    (%eax),%al
f010ec85:	3a 45 fc             	cmp    -0x4(%ebp),%al
f010ec88:	74 0e                	je     f010ec98 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f010ec8a:	ff 45 08             	incl   0x8(%ebp)
f010ec8d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec90:	8a 00                	mov    (%eax),%al
f010ec92:	84 c0                	test   %al,%al
f010ec94:	75 ea                	jne    f010ec80 <strfind+0xe>
f010ec96:	eb 01                	jmp    f010ec99 <strfind+0x27>
		if (*s == c)
			break;
f010ec98:	90                   	nop
	return (char *) s;
f010ec99:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010ec9c:	c9                   	leave  
f010ec9d:	c3                   	ret    

f010ec9e <memset>:


void *
memset(void *v, int c, uint32 n)
{
f010ec9e:	55                   	push   %ebp
f010ec9f:	89 e5                	mov    %esp,%ebp
f010eca1:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f010eca4:	8b 45 08             	mov    0x8(%ebp),%eax
f010eca7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f010ecaa:	8b 45 10             	mov    0x10(%ebp),%eax
f010ecad:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f010ecb0:	eb 0e                	jmp    f010ecc0 <memset+0x22>
		*p++ = c;
f010ecb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ecb5:	8d 50 01             	lea    0x1(%eax),%edx
f010ecb8:	89 55 fc             	mov    %edx,-0x4(%ebp)
f010ecbb:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ecbe:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f010ecc0:	ff 4d f8             	decl   -0x8(%ebp)
f010ecc3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f010ecc7:	79 e9                	jns    f010ecb2 <memset+0x14>
		*p++ = c;

	return v;
f010ecc9:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010eccc:	c9                   	leave  
f010eccd:	c3                   	ret    

f010ecce <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f010ecce:	55                   	push   %ebp
f010eccf:	89 e5                	mov    %esp,%ebp
f010ecd1:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f010ecd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecd7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f010ecda:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecdd:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f010ece0:	eb 16                	jmp    f010ecf8 <memcpy+0x2a>
		*d++ = *s++;
f010ece2:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ece5:	8d 50 01             	lea    0x1(%eax),%edx
f010ece8:	89 55 f8             	mov    %edx,-0x8(%ebp)
f010eceb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ecee:	8d 4a 01             	lea    0x1(%edx),%ecx
f010ecf1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f010ecf4:	8a 12                	mov    (%edx),%dl
f010ecf6:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f010ecf8:	8b 45 10             	mov    0x10(%ebp),%eax
f010ecfb:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ecfe:	89 55 10             	mov    %edx,0x10(%ebp)
f010ed01:	85 c0                	test   %eax,%eax
f010ed03:	75 dd                	jne    f010ece2 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f010ed05:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010ed08:	c9                   	leave  
f010ed09:	c3                   	ret    

f010ed0a <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f010ed0a:	55                   	push   %ebp
f010ed0b:	89 e5                	mov    %esp,%ebp
f010ed0d:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;
	
	s = src;
f010ed10:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed13:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f010ed16:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed19:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f010ed1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ed1f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010ed22:	73 50                	jae    f010ed74 <memmove+0x6a>
f010ed24:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ed27:	8b 45 10             	mov    0x10(%ebp),%eax
f010ed2a:	01 d0                	add    %edx,%eax
f010ed2c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010ed2f:	76 43                	jbe    f010ed74 <memmove+0x6a>
		s += n;
f010ed31:	8b 45 10             	mov    0x10(%ebp),%eax
f010ed34:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f010ed37:	8b 45 10             	mov    0x10(%ebp),%eax
f010ed3a:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f010ed3d:	eb 10                	jmp    f010ed4f <memmove+0x45>
			*--d = *--s;
f010ed3f:	ff 4d f8             	decl   -0x8(%ebp)
f010ed42:	ff 4d fc             	decl   -0x4(%ebp)
f010ed45:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ed48:	8a 10                	mov    (%eax),%dl
f010ed4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ed4d:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f010ed4f:	8b 45 10             	mov    0x10(%ebp),%eax
f010ed52:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ed55:	89 55 10             	mov    %edx,0x10(%ebp)
f010ed58:	85 c0                	test   %eax,%eax
f010ed5a:	75 e3                	jne    f010ed3f <memmove+0x35>
	const char *s;
	char *d;
	
	s = src;
	d = dst;
	if (s < d && s + n > d) {
f010ed5c:	eb 23                	jmp    f010ed81 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f010ed5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ed61:	8d 50 01             	lea    0x1(%eax),%edx
f010ed64:	89 55 f8             	mov    %edx,-0x8(%ebp)
f010ed67:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ed6a:	8d 4a 01             	lea    0x1(%edx),%ecx
f010ed6d:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f010ed70:	8a 12                	mov    (%edx),%dl
f010ed72:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f010ed74:	8b 45 10             	mov    0x10(%ebp),%eax
f010ed77:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ed7a:	89 55 10             	mov    %edx,0x10(%ebp)
f010ed7d:	85 c0                	test   %eax,%eax
f010ed7f:	75 dd                	jne    f010ed5e <memmove+0x54>
			*d++ = *s++;

	return dst;
f010ed81:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010ed84:	c9                   	leave  
f010ed85:	c3                   	ret    

f010ed86 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f010ed86:	55                   	push   %ebp
f010ed87:	89 e5                	mov    %esp,%ebp
f010ed89:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f010ed8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f010ed92:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed95:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f010ed98:	eb 2a                	jmp    f010edc4 <memcmp+0x3e>
		if (*s1 != *s2)
f010ed9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ed9d:	8a 10                	mov    (%eax),%dl
f010ed9f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010eda2:	8a 00                	mov    (%eax),%al
f010eda4:	38 c2                	cmp    %al,%dl
f010eda6:	74 16                	je     f010edbe <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f010eda8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010edab:	8a 00                	mov    (%eax),%al
f010edad:	0f b6 d0             	movzbl %al,%edx
f010edb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010edb3:	8a 00                	mov    (%eax),%al
f010edb5:	0f b6 c0             	movzbl %al,%eax
f010edb8:	29 c2                	sub    %eax,%edx
f010edba:	89 d0                	mov    %edx,%eax
f010edbc:	eb 18                	jmp    f010edd6 <memcmp+0x50>
		s1++, s2++;
f010edbe:	ff 45 fc             	incl   -0x4(%ebp)
f010edc1:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f010edc4:	8b 45 10             	mov    0x10(%ebp),%eax
f010edc7:	8d 50 ff             	lea    -0x1(%eax),%edx
f010edca:	89 55 10             	mov    %edx,0x10(%ebp)
f010edcd:	85 c0                	test   %eax,%eax
f010edcf:	75 c9                	jne    f010ed9a <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f010edd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010edd6:	c9                   	leave  
f010edd7:	c3                   	ret    

f010edd8 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f010edd8:	55                   	push   %ebp
f010edd9:	89 e5                	mov    %esp,%ebp
f010eddb:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f010edde:	8b 55 08             	mov    0x8(%ebp),%edx
f010ede1:	8b 45 10             	mov    0x10(%ebp),%eax
f010ede4:	01 d0                	add    %edx,%eax
f010ede6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f010ede9:	eb 15                	jmp    f010ee00 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f010edeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010edee:	8a 00                	mov    (%eax),%al
f010edf0:	0f b6 d0             	movzbl %al,%edx
f010edf3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010edf6:	0f b6 c0             	movzbl %al,%eax
f010edf9:	39 c2                	cmp    %eax,%edx
f010edfb:	74 0d                	je     f010ee0a <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f010edfd:	ff 45 08             	incl   0x8(%ebp)
f010ee00:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee03:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010ee06:	72 e3                	jb     f010edeb <memfind+0x13>
f010ee08:	eb 01                	jmp    f010ee0b <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f010ee0a:	90                   	nop
	return (void *) s;
f010ee0b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f010ee0e:	c9                   	leave  
f010ee0f:	c3                   	ret    

f010ee10 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f010ee10:	55                   	push   %ebp
f010ee11:	89 e5                	mov    %esp,%ebp
f010ee13:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f010ee16:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f010ee1d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f010ee24:	eb 03                	jmp    f010ee29 <strtol+0x19>
		s++;
f010ee26:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f010ee29:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee2c:	8a 00                	mov    (%eax),%al
f010ee2e:	3c 20                	cmp    $0x20,%al
f010ee30:	74 f4                	je     f010ee26 <strtol+0x16>
f010ee32:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee35:	8a 00                	mov    (%eax),%al
f010ee37:	3c 09                	cmp    $0x9,%al
f010ee39:	74 eb                	je     f010ee26 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f010ee3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee3e:	8a 00                	mov    (%eax),%al
f010ee40:	3c 2b                	cmp    $0x2b,%al
f010ee42:	75 05                	jne    f010ee49 <strtol+0x39>
		s++;
f010ee44:	ff 45 08             	incl   0x8(%ebp)
f010ee47:	eb 13                	jmp    f010ee5c <strtol+0x4c>
	else if (*s == '-')
f010ee49:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee4c:	8a 00                	mov    (%eax),%al
f010ee4e:	3c 2d                	cmp    $0x2d,%al
f010ee50:	75 0a                	jne    f010ee5c <strtol+0x4c>
		s++, neg = 1;
f010ee52:	ff 45 08             	incl   0x8(%ebp)
f010ee55:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f010ee5c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010ee60:	74 06                	je     f010ee68 <strtol+0x58>
f010ee62:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f010ee66:	75 20                	jne    f010ee88 <strtol+0x78>
f010ee68:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee6b:	8a 00                	mov    (%eax),%al
f010ee6d:	3c 30                	cmp    $0x30,%al
f010ee6f:	75 17                	jne    f010ee88 <strtol+0x78>
f010ee71:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee74:	40                   	inc    %eax
f010ee75:	8a 00                	mov    (%eax),%al
f010ee77:	3c 78                	cmp    $0x78,%al
f010ee79:	75 0d                	jne    f010ee88 <strtol+0x78>
		s += 2, base = 16;
f010ee7b:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f010ee7f:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f010ee86:	eb 28                	jmp    f010eeb0 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f010ee88:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010ee8c:	75 15                	jne    f010eea3 <strtol+0x93>
f010ee8e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee91:	8a 00                	mov    (%eax),%al
f010ee93:	3c 30                	cmp    $0x30,%al
f010ee95:	75 0c                	jne    f010eea3 <strtol+0x93>
		s++, base = 8;
f010ee97:	ff 45 08             	incl   0x8(%ebp)
f010ee9a:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f010eea1:	eb 0d                	jmp    f010eeb0 <strtol+0xa0>
	else if (base == 0)
f010eea3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010eea7:	75 07                	jne    f010eeb0 <strtol+0xa0>
		base = 10;
f010eea9:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f010eeb0:	8b 45 08             	mov    0x8(%ebp),%eax
f010eeb3:	8a 00                	mov    (%eax),%al
f010eeb5:	3c 2f                	cmp    $0x2f,%al
f010eeb7:	7e 19                	jle    f010eed2 <strtol+0xc2>
f010eeb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010eebc:	8a 00                	mov    (%eax),%al
f010eebe:	3c 39                	cmp    $0x39,%al
f010eec0:	7f 10                	jg     f010eed2 <strtol+0xc2>
			dig = *s - '0';
f010eec2:	8b 45 08             	mov    0x8(%ebp),%eax
f010eec5:	8a 00                	mov    (%eax),%al
f010eec7:	0f be c0             	movsbl %al,%eax
f010eeca:	83 e8 30             	sub    $0x30,%eax
f010eecd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eed0:	eb 42                	jmp    f010ef14 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f010eed2:	8b 45 08             	mov    0x8(%ebp),%eax
f010eed5:	8a 00                	mov    (%eax),%al
f010eed7:	3c 60                	cmp    $0x60,%al
f010eed9:	7e 19                	jle    f010eef4 <strtol+0xe4>
f010eedb:	8b 45 08             	mov    0x8(%ebp),%eax
f010eede:	8a 00                	mov    (%eax),%al
f010eee0:	3c 7a                	cmp    $0x7a,%al
f010eee2:	7f 10                	jg     f010eef4 <strtol+0xe4>
			dig = *s - 'a' + 10;
f010eee4:	8b 45 08             	mov    0x8(%ebp),%eax
f010eee7:	8a 00                	mov    (%eax),%al
f010eee9:	0f be c0             	movsbl %al,%eax
f010eeec:	83 e8 57             	sub    $0x57,%eax
f010eeef:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eef2:	eb 20                	jmp    f010ef14 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f010eef4:	8b 45 08             	mov    0x8(%ebp),%eax
f010eef7:	8a 00                	mov    (%eax),%al
f010eef9:	3c 40                	cmp    $0x40,%al
f010eefb:	7e 39                	jle    f010ef36 <strtol+0x126>
f010eefd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef00:	8a 00                	mov    (%eax),%al
f010ef02:	3c 5a                	cmp    $0x5a,%al
f010ef04:	7f 30                	jg     f010ef36 <strtol+0x126>
			dig = *s - 'A' + 10;
f010ef06:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef09:	8a 00                	mov    (%eax),%al
f010ef0b:	0f be c0             	movsbl %al,%eax
f010ef0e:	83 e8 37             	sub    $0x37,%eax
f010ef11:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f010ef14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef17:	3b 45 10             	cmp    0x10(%ebp),%eax
f010ef1a:	7d 19                	jge    f010ef35 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f010ef1c:	ff 45 08             	incl   0x8(%ebp)
f010ef1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ef22:	0f af 45 10          	imul   0x10(%ebp),%eax
f010ef26:	89 c2                	mov    %eax,%edx
f010ef28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef2b:	01 d0                	add    %edx,%eax
f010ef2d:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f010ef30:	e9 7b ff ff ff       	jmp    f010eeb0 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f010ef35:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f010ef36:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010ef3a:	74 08                	je     f010ef44 <strtol+0x134>
		*endptr = (char *) s;
f010ef3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef3f:	8b 55 08             	mov    0x8(%ebp),%edx
f010ef42:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f010ef44:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010ef48:	74 07                	je     f010ef51 <strtol+0x141>
f010ef4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ef4d:	f7 d8                	neg    %eax
f010ef4f:	eb 03                	jmp    f010ef54 <strtol+0x144>
f010ef51:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010ef54:	c9                   	leave  
f010ef55:	c3                   	ret    

f010ef56 <ltostr>:

void
ltostr(long value, char *str)
{
f010ef56:	55                   	push   %ebp
f010ef57:	89 e5                	mov    %esp,%ebp
f010ef59:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f010ef5c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f010ef63:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f010ef6a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ef6e:	79 13                	jns    f010ef83 <ltostr+0x2d>
	{
		neg = 1;
f010ef70:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f010ef77:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef7a:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f010ef7d:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f010ef80:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f010ef83:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef86:	b9 0a 00 00 00       	mov    $0xa,%ecx
f010ef8b:	99                   	cltd   
f010ef8c:	f7 f9                	idiv   %ecx
f010ef8e:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f010ef91:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ef94:	8d 50 01             	lea    0x1(%eax),%edx
f010ef97:	89 55 f8             	mov    %edx,-0x8(%ebp)
f010ef9a:	89 c2                	mov    %eax,%edx
f010ef9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef9f:	01 d0                	add    %edx,%eax
f010efa1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010efa4:	83 c2 30             	add    $0x30,%edx
f010efa7:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f010efa9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010efac:	b8 67 66 66 66       	mov    $0x66666667,%eax
f010efb1:	f7 e9                	imul   %ecx
f010efb3:	c1 fa 02             	sar    $0x2,%edx
f010efb6:	89 c8                	mov    %ecx,%eax
f010efb8:	c1 f8 1f             	sar    $0x1f,%eax
f010efbb:	29 c2                	sub    %eax,%edx
f010efbd:	89 d0                	mov    %edx,%eax
f010efbf:	89 45 08             	mov    %eax,0x8(%ebp)
	} while (value % 10 != 0);
f010efc2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010efc5:	b8 67 66 66 66       	mov    $0x66666667,%eax
f010efca:	f7 e9                	imul   %ecx
f010efcc:	c1 fa 02             	sar    $0x2,%edx
f010efcf:	89 c8                	mov    %ecx,%eax
f010efd1:	c1 f8 1f             	sar    $0x1f,%eax
f010efd4:	29 c2                	sub    %eax,%edx
f010efd6:	89 d0                	mov    %edx,%eax
f010efd8:	c1 e0 02             	shl    $0x2,%eax
f010efdb:	01 d0                	add    %edx,%eax
f010efdd:	01 c0                	add    %eax,%eax
f010efdf:	29 c1                	sub    %eax,%ecx
f010efe1:	89 ca                	mov    %ecx,%edx
f010efe3:	85 d2                	test   %edx,%edx
f010efe5:	75 9c                	jne    f010ef83 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f010efe7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f010efee:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010eff1:	48                   	dec    %eax
f010eff2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f010eff5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010eff9:	74 3d                	je     f010f038 <ltostr+0xe2>
		start = 1 ;
f010effb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f010f002:	eb 34                	jmp    f010f038 <ltostr+0xe2>
	{
		char tmp = str[start] ;
f010f004:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f007:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f00a:	01 d0                	add    %edx,%eax
f010f00c:	8a 00                	mov    (%eax),%al
f010f00e:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f010f011:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f014:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f017:	01 c2                	add    %eax,%edx
f010f019:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010f01c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f01f:	01 c8                	add    %ecx,%eax
f010f021:	8a 00                	mov    (%eax),%al
f010f023:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f010f025:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f028:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f02b:	01 c2                	add    %eax,%edx
f010f02d:	8a 45 eb             	mov    -0x15(%ebp),%al
f010f030:	88 02                	mov    %al,(%edx)
		start++ ;
f010f032:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f010f035:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f010f038:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f03b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f03e:	7c c4                	jl     f010f004 <ltostr+0xae>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f010f040:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010f043:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f046:	01 d0                	add    %edx,%eax
f010f048:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f010f04b:	90                   	nop
f010f04c:	c9                   	leave  
f010f04d:	c3                   	ret    

f010f04e <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f010f04e:	55                   	push   %ebp
f010f04f:	89 e5                	mov    %esp,%ebp
f010f051:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f010f054:	ff 75 08             	pushl  0x8(%ebp)
f010f057:	e8 54 fa ff ff       	call   f010eab0 <strlen>
f010f05c:	83 c4 04             	add    $0x4,%esp
f010f05f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f010f062:	ff 75 0c             	pushl  0xc(%ebp)
f010f065:	e8 46 fa ff ff       	call   f010eab0 <strlen>
f010f06a:	83 c4 04             	add    $0x4,%esp
f010f06d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f010f070:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f010f077:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010f07e:	eb 17                	jmp    f010f097 <strcconcat+0x49>
		final[s] = str1[s] ;
f010f080:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f083:	8b 45 10             	mov    0x10(%ebp),%eax
f010f086:	01 c2                	add    %eax,%edx
f010f088:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f010f08b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f08e:	01 c8                	add    %ecx,%eax
f010f090:	8a 00                	mov    (%eax),%al
f010f092:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f010f094:	ff 45 fc             	incl   -0x4(%ebp)
f010f097:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f09a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f09d:	7c e1                	jl     f010f080 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f010f09f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f010f0a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f010f0ad:	eb 1f                	jmp    f010f0ce <strcconcat+0x80>
		final[s++] = str2[i] ;
f010f0af:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f0b2:	8d 50 01             	lea    0x1(%eax),%edx
f010f0b5:	89 55 fc             	mov    %edx,-0x4(%ebp)
f010f0b8:	89 c2                	mov    %eax,%edx
f010f0ba:	8b 45 10             	mov    0x10(%ebp),%eax
f010f0bd:	01 c2                	add    %eax,%edx
f010f0bf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f010f0c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0c5:	01 c8                	add    %ecx,%eax
f010f0c7:	8a 00                	mov    (%eax),%al
f010f0c9:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f010f0cb:	ff 45 f8             	incl   -0x8(%ebp)
f010f0ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f0d1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f0d4:	7c d9                	jl     f010f0af <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f010f0d6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f0d9:	8b 45 10             	mov    0x10(%ebp),%eax
f010f0dc:	01 d0                	add    %edx,%eax
f010f0de:	c6 00 00             	movb   $0x0,(%eax)
}
f010f0e1:	90                   	nop
f010f0e2:	c9                   	leave  
f010f0e3:	c3                   	ret    

f010f0e4 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f010f0e4:	55                   	push   %ebp
f010f0e5:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f010f0e7:	8b 45 14             	mov    0x14(%ebp),%eax
f010f0ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f010f0f0:	8b 45 14             	mov    0x14(%ebp),%eax
f010f0f3:	8b 00                	mov    (%eax),%eax
f010f0f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f0fc:	8b 45 10             	mov    0x10(%ebp),%eax
f010f0ff:	01 d0                	add    %edx,%eax
f010f101:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1) 
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f010f107:	eb 0c                	jmp    f010f115 <strsplit+0x31>
			*string++ = 0;
f010f109:	8b 45 08             	mov    0x8(%ebp),%eax
f010f10c:	8d 50 01             	lea    0x1(%eax),%edx
f010f10f:	89 55 08             	mov    %edx,0x8(%ebp)
f010f112:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1) 
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f010f115:	8b 45 08             	mov    0x8(%ebp),%eax
f010f118:	8a 00                	mov    (%eax),%al
f010f11a:	84 c0                	test   %al,%al
f010f11c:	74 18                	je     f010f136 <strsplit+0x52>
f010f11e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f121:	8a 00                	mov    (%eax),%al
f010f123:	0f be c0             	movsbl %al,%eax
f010f126:	50                   	push   %eax
f010f127:	ff 75 0c             	pushl  0xc(%ebp)
f010f12a:	e8 13 fb ff ff       	call   f010ec42 <strchr>
f010f12f:	83 c4 08             	add    $0x8,%esp
f010f132:	85 c0                	test   %eax,%eax
f010f134:	75 d3                	jne    f010f109 <strsplit+0x25>
			*string++ = 0;
		
		//if the command string is finished, then break the loop
		if (*string == 0)
f010f136:	8b 45 08             	mov    0x8(%ebp),%eax
f010f139:	8a 00                	mov    (%eax),%al
f010f13b:	84 c0                	test   %al,%al
f010f13d:	74 5a                	je     f010f199 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1) 
f010f13f:	8b 45 14             	mov    0x14(%ebp),%eax
f010f142:	8b 00                	mov    (%eax),%eax
f010f144:	83 f8 0f             	cmp    $0xf,%eax
f010f147:	75 07                	jne    f010f150 <strsplit+0x6c>
		{
			return 0;
f010f149:	b8 00 00 00 00       	mov    $0x0,%eax
f010f14e:	eb 66                	jmp    f010f1b6 <strsplit+0xd2>
		}
		
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f010f150:	8b 45 14             	mov    0x14(%ebp),%eax
f010f153:	8b 00                	mov    (%eax),%eax
f010f155:	8d 48 01             	lea    0x1(%eax),%ecx
f010f158:	8b 55 14             	mov    0x14(%ebp),%edx
f010f15b:	89 0a                	mov    %ecx,(%edx)
f010f15d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f164:	8b 45 10             	mov    0x10(%ebp),%eax
f010f167:	01 c2                	add    %eax,%edx
f010f169:	8b 45 08             	mov    0x8(%ebp),%eax
f010f16c:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f010f16e:	eb 03                	jmp    f010f173 <strsplit+0x8f>
			string++;
f010f170:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}
		
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f010f173:	8b 45 08             	mov    0x8(%ebp),%eax
f010f176:	8a 00                	mov    (%eax),%al
f010f178:	84 c0                	test   %al,%al
f010f17a:	74 8b                	je     f010f107 <strsplit+0x23>
f010f17c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f17f:	8a 00                	mov    (%eax),%al
f010f181:	0f be c0             	movsbl %al,%eax
f010f184:	50                   	push   %eax
f010f185:	ff 75 0c             	pushl  0xc(%ebp)
f010f188:	e8 b5 fa ff ff       	call   f010ec42 <strchr>
f010f18d:	83 c4 08             	add    $0x8,%esp
f010f190:	85 c0                	test   %eax,%eax
f010f192:	74 dc                	je     f010f170 <strsplit+0x8c>
			string++;
	}
f010f194:	e9 6e ff ff ff       	jmp    f010f107 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;
		
		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f010f199:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f010f19a:	8b 45 14             	mov    0x14(%ebp),%eax
f010f19d:	8b 00                	mov    (%eax),%eax
f010f19f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f1a6:	8b 45 10             	mov    0x10(%ebp),%eax
f010f1a9:	01 d0                	add    %edx,%eax
f010f1ab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f010f1b1:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010f1b6:	c9                   	leave  
f010f1b7:	c3                   	ret    

f010f1b8 <ide_wait_ready>:
#define IDE_ERR		0x01

static int diskno = 0;

static int ide_wait_ready(bool check_error)
{
f010f1b8:	55                   	push   %ebp
f010f1b9:	89 e5                	mov    %esp,%ebp
f010f1bb:	83 ec 10             	sub    $0x10,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f010f1be:	90                   	nop
f010f1bf:	c7 45 f8 f7 01 00 00 	movl   $0x1f7,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010f1c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f1c9:	89 c2                	mov    %eax,%edx
f010f1cb:	ec                   	in     (%dx),%al
f010f1cc:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f010f1cf:	8a 45 f7             	mov    -0x9(%ebp),%al
f010f1d2:	0f b6 c0             	movzbl %al,%eax
f010f1d5:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f1d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f1db:	25 c0 00 00 00       	and    $0xc0,%eax
f010f1e0:	83 f8 40             	cmp    $0x40,%eax
f010f1e3:	75 da                	jne    f010f1bf <ide_wait_ready+0x7>
		/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f010f1e5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010f1e9:	74 11                	je     f010f1fc <ide_wait_ready+0x44>
f010f1eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f1ee:	83 e0 21             	and    $0x21,%eax
f010f1f1:	85 c0                	test   %eax,%eax
f010f1f3:	74 07                	je     f010f1fc <ide_wait_ready+0x44>
	{
 		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
f010f1f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f1fa:	eb 05                	jmp    f010f201 <ide_wait_ready+0x49>
	}
	return 0;
f010f1fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f201:	c9                   	leave  
f010f202:	c3                   	ret    

f010f203 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f010f203:	55                   	push   %ebp
f010f204:	89 e5                	mov    %esp,%ebp
f010f206:	57                   	push   %edi
f010f207:	53                   	push   %ebx
f010f208:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f010f20b:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f010f212:	76 16                	jbe    f010f22a <ide_read+0x27>
f010f214:	68 23 2b 11 f0       	push   $0xf0112b23
f010f219:	68 30 2b 11 f0       	push   $0xf0112b30
f010f21e:	6a 25                	push   $0x25
f010f220:	68 45 2b 11 f0       	push   $0xf0112b45
f010f225:	e8 32 0f ff ff       	call   f010015c <_panic>

	ide_wait_ready(0);
f010f22a:	83 ec 0c             	sub    $0xc,%esp
f010f22d:	6a 00                	push   $0x0
f010f22f:	e8 84 ff ff ff       	call   f010f1b8 <ide_wait_ready>
f010f234:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f010f237:	8b 45 10             	mov    0x10(%ebp),%eax
f010f23a:	0f b6 c0             	movzbl %al,%eax
f010f23d:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f010f244:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010f247:	8a 45 d2             	mov    -0x2e(%ebp),%al
f010f24a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f24d:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f010f24e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f251:	0f b6 c0             	movzbl %al,%eax
f010f254:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f010f25b:	88 45 d3             	mov    %al,-0x2d(%ebp)
f010f25e:	8a 45 d3             	mov    -0x2d(%ebp),%al
f010f261:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f264:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f010f265:	8b 45 08             	mov    0x8(%ebp),%eax
f010f268:	c1 e8 08             	shr    $0x8,%eax
f010f26b:	0f b6 c0             	movzbl %al,%eax
f010f26e:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f010f275:	88 45 d4             	mov    %al,-0x2c(%ebp)
f010f278:	8a 45 d4             	mov    -0x2c(%ebp),%al
f010f27b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f27e:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f010f27f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f282:	c1 e8 10             	shr    $0x10,%eax
f010f285:	0f b6 c0             	movzbl %al,%eax
f010f288:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f010f28f:	88 45 d5             	mov    %al,-0x2b(%ebp)
f010f292:	8a 45 d5             	mov    -0x2b(%ebp),%al
f010f295:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f298:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f010f299:	a1 20 2a 45 f0       	mov    0xf0452a20,%eax
f010f29e:	83 e0 01             	and    $0x1,%eax
f010f2a1:	c1 e0 04             	shl    $0x4,%eax
f010f2a4:	88 c2                	mov    %al,%dl
f010f2a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2a9:	c1 e8 18             	shr    $0x18,%eax
f010f2ac:	83 e0 0f             	and    $0xf,%eax
f010f2af:	09 d0                	or     %edx,%eax
f010f2b1:	83 c8 e0             	or     $0xffffffe0,%eax
f010f2b4:	0f b6 c0             	movzbl %al,%eax
f010f2b7:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f010f2be:	88 45 d6             	mov    %al,-0x2a(%ebp)
f010f2c1:	8a 45 d6             	mov    -0x2a(%ebp),%al
f010f2c4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010f2c7:	ee                   	out    %al,(%dx)
f010f2c8:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f010f2cf:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f010f2d3:	8a 45 d7             	mov    -0x29(%ebp),%al
f010f2d6:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010f2d9:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f010f2da:	eb 55                	jmp    f010f331 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f010f2dc:	83 ec 0c             	sub    $0xc,%esp
f010f2df:	6a 01                	push   $0x1
f010f2e1:	e8 d2 fe ff ff       	call   f010f1b8 <ide_wait_ready>
f010f2e6:	83 c4 10             	add    $0x10,%esp
f010f2e9:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f2ec:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010f2f0:	79 05                	jns    f010f2f7 <ide_read+0xf4>
			return r;
f010f2f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f2f5:	eb 45                	jmp    f010f33c <ide_read+0x139>
f010f2f7:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f010f2fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f301:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010f304:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f010f30b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f30e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f010f311:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010f314:	89 cb                	mov    %ecx,%ebx
f010f316:	89 df                	mov    %ebx,%edi
f010f318:	89 c1                	mov    %eax,%ecx
f010f31a:	fc                   	cld    
f010f31b:	f2 6d                	repnz insl (%dx),%es:(%edi)
f010f31d:	89 c8                	mov    %ecx,%eax
f010f31f:	89 fb                	mov    %edi,%ebx
f010f321:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f010f324:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f010f327:	ff 4d 10             	decl   0x10(%ebp)
f010f32a:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f010f331:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010f335:	75 a5                	jne    f010f2dc <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f010f337:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f33c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f33f:	5b                   	pop    %ebx
f010f340:	5f                   	pop    %edi
f010f341:	5d                   	pop    %ebp
f010f342:	c3                   	ret    

f010f343 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f010f343:	55                   	push   %ebp
f010f344:	89 e5                	mov    %esp,%ebp
f010f346:	56                   	push   %esi
f010f347:	53                   	push   %ebx
f010f348:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f010f34b:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f010f352:	76 16                	jbe    f010f36a <ide_write+0x27>
f010f354:	68 23 2b 11 f0       	push   $0xf0112b23
f010f359:	68 30 2b 11 f0       	push   $0xf0112b30
f010f35e:	6a 3e                	push   $0x3e
f010f360:	68 45 2b 11 f0       	push   $0xf0112b45
f010f365:	e8 f2 0d ff ff       	call   f010015c <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f010f36a:	83 ec 0c             	sub    $0xc,%esp
f010f36d:	6a 00                	push   $0x0
f010f36f:	e8 44 fe ff ff       	call   f010f1b8 <ide_wait_ready>
f010f374:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f010f377:	8b 45 10             	mov    0x10(%ebp),%eax
f010f37a:	0f b6 c0             	movzbl %al,%eax
f010f37d:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f010f384:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010f387:	8a 45 d2             	mov    -0x2e(%ebp),%al
f010f38a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f38d:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f010f38e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f391:	0f b6 c0             	movzbl %al,%eax
f010f394:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f010f39b:	88 45 d3             	mov    %al,-0x2d(%ebp)
f010f39e:	8a 45 d3             	mov    -0x2d(%ebp),%al
f010f3a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f3a4:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f010f3a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3a8:	c1 e8 08             	shr    $0x8,%eax
f010f3ab:	0f b6 c0             	movzbl %al,%eax
f010f3ae:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f010f3b5:	88 45 d4             	mov    %al,-0x2c(%ebp)
f010f3b8:	8a 45 d4             	mov    -0x2c(%ebp),%al
f010f3bb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f3be:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f010f3bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3c2:	c1 e8 10             	shr    $0x10,%eax
f010f3c5:	0f b6 c0             	movzbl %al,%eax
f010f3c8:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f010f3cf:	88 45 d5             	mov    %al,-0x2b(%ebp)
f010f3d2:	8a 45 d5             	mov    -0x2b(%ebp),%al
f010f3d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f3d8:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f010f3d9:	a1 20 2a 45 f0       	mov    0xf0452a20,%eax
f010f3de:	83 e0 01             	and    $0x1,%eax
f010f3e1:	c1 e0 04             	shl    $0x4,%eax
f010f3e4:	88 c2                	mov    %al,%dl
f010f3e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3e9:	c1 e8 18             	shr    $0x18,%eax
f010f3ec:	83 e0 0f             	and    $0xf,%eax
f010f3ef:	09 d0                	or     %edx,%eax
f010f3f1:	83 c8 e0             	or     $0xffffffe0,%eax
f010f3f4:	0f b6 c0             	movzbl %al,%eax
f010f3f7:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f010f3fe:	88 45 d6             	mov    %al,-0x2a(%ebp)
f010f401:	8a 45 d6             	mov    -0x2a(%ebp),%al
f010f404:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010f407:	ee                   	out    %al,(%dx)
f010f408:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f010f40f:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f010f413:	8a 45 d7             	mov    -0x29(%ebp),%al
f010f416:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010f419:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f010f41a:	eb 55                	jmp    f010f471 <ide_write+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f010f41c:	83 ec 0c             	sub    $0xc,%esp
f010f41f:	6a 01                	push   $0x1
f010f421:	e8 92 fd ff ff       	call   f010f1b8 <ide_wait_ready>
f010f426:	83 c4 10             	add    $0x10,%esp
f010f429:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f42c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010f430:	79 05                	jns    f010f437 <ide_write+0xf4>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f010f432:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f435:	eb 45                	jmp    f010f47c <ide_write+0x139>
f010f437:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f010f43e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f441:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010f444:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f010f44b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f44e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f010f451:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010f454:	89 cb                	mov    %ecx,%ebx
f010f456:	89 de                	mov    %ebx,%esi
f010f458:	89 c1                	mov    %eax,%ecx
f010f45a:	fc                   	cld    
f010f45b:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f010f45d:	89 c8                	mov    %ecx,%eax
f010f45f:	89 f3                	mov    %esi,%ebx
f010f461:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f010f464:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f010f467:	ff 4d 10             	decl   0x10(%ebp)
f010f46a:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f010f471:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010f475:	75 a5                	jne    f010f41c <ide_write+0xd9>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f010f477:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f47c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f47f:	5b                   	pop    %ebx
f010f480:	5e                   	pop    %esi
f010f481:	5d                   	pop    %ebp
f010f482:	c3                   	ret    
f010f483:	90                   	nop

f010f484 <__udivdi3>:
f010f484:	55                   	push   %ebp
f010f485:	57                   	push   %edi
f010f486:	56                   	push   %esi
f010f487:	53                   	push   %ebx
f010f488:	83 ec 1c             	sub    $0x1c,%esp
f010f48b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f010f48f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f010f493:	8b 7c 24 38          	mov    0x38(%esp),%edi
f010f497:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f010f49b:	89 ca                	mov    %ecx,%edx
f010f49d:	89 f8                	mov    %edi,%eax
f010f49f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f010f4a3:	85 f6                	test   %esi,%esi
f010f4a5:	75 2d                	jne    f010f4d4 <__udivdi3+0x50>
f010f4a7:	39 cf                	cmp    %ecx,%edi
f010f4a9:	77 65                	ja     f010f510 <__udivdi3+0x8c>
f010f4ab:	89 fd                	mov    %edi,%ebp
f010f4ad:	85 ff                	test   %edi,%edi
f010f4af:	75 0b                	jne    f010f4bc <__udivdi3+0x38>
f010f4b1:	b8 01 00 00 00       	mov    $0x1,%eax
f010f4b6:	31 d2                	xor    %edx,%edx
f010f4b8:	f7 f7                	div    %edi
f010f4ba:	89 c5                	mov    %eax,%ebp
f010f4bc:	31 d2                	xor    %edx,%edx
f010f4be:	89 c8                	mov    %ecx,%eax
f010f4c0:	f7 f5                	div    %ebp
f010f4c2:	89 c1                	mov    %eax,%ecx
f010f4c4:	89 d8                	mov    %ebx,%eax
f010f4c6:	f7 f5                	div    %ebp
f010f4c8:	89 cf                	mov    %ecx,%edi
f010f4ca:	89 fa                	mov    %edi,%edx
f010f4cc:	83 c4 1c             	add    $0x1c,%esp
f010f4cf:	5b                   	pop    %ebx
f010f4d0:	5e                   	pop    %esi
f010f4d1:	5f                   	pop    %edi
f010f4d2:	5d                   	pop    %ebp
f010f4d3:	c3                   	ret    
f010f4d4:	39 ce                	cmp    %ecx,%esi
f010f4d6:	77 28                	ja     f010f500 <__udivdi3+0x7c>
f010f4d8:	0f bd fe             	bsr    %esi,%edi
f010f4db:	83 f7 1f             	xor    $0x1f,%edi
f010f4de:	75 40                	jne    f010f520 <__udivdi3+0x9c>
f010f4e0:	39 ce                	cmp    %ecx,%esi
f010f4e2:	72 0a                	jb     f010f4ee <__udivdi3+0x6a>
f010f4e4:	3b 44 24 08          	cmp    0x8(%esp),%eax
f010f4e8:	0f 87 9e 00 00 00    	ja     f010f58c <__udivdi3+0x108>
f010f4ee:	b8 01 00 00 00       	mov    $0x1,%eax
f010f4f3:	89 fa                	mov    %edi,%edx
f010f4f5:	83 c4 1c             	add    $0x1c,%esp
f010f4f8:	5b                   	pop    %ebx
f010f4f9:	5e                   	pop    %esi
f010f4fa:	5f                   	pop    %edi
f010f4fb:	5d                   	pop    %ebp
f010f4fc:	c3                   	ret    
f010f4fd:	8d 76 00             	lea    0x0(%esi),%esi
f010f500:	31 ff                	xor    %edi,%edi
f010f502:	31 c0                	xor    %eax,%eax
f010f504:	89 fa                	mov    %edi,%edx
f010f506:	83 c4 1c             	add    $0x1c,%esp
f010f509:	5b                   	pop    %ebx
f010f50a:	5e                   	pop    %esi
f010f50b:	5f                   	pop    %edi
f010f50c:	5d                   	pop    %ebp
f010f50d:	c3                   	ret    
f010f50e:	66 90                	xchg   %ax,%ax
f010f510:	89 d8                	mov    %ebx,%eax
f010f512:	f7 f7                	div    %edi
f010f514:	31 ff                	xor    %edi,%edi
f010f516:	89 fa                	mov    %edi,%edx
f010f518:	83 c4 1c             	add    $0x1c,%esp
f010f51b:	5b                   	pop    %ebx
f010f51c:	5e                   	pop    %esi
f010f51d:	5f                   	pop    %edi
f010f51e:	5d                   	pop    %ebp
f010f51f:	c3                   	ret    
f010f520:	bd 20 00 00 00       	mov    $0x20,%ebp
f010f525:	89 eb                	mov    %ebp,%ebx
f010f527:	29 fb                	sub    %edi,%ebx
f010f529:	89 f9                	mov    %edi,%ecx
f010f52b:	d3 e6                	shl    %cl,%esi
f010f52d:	89 c5                	mov    %eax,%ebp
f010f52f:	88 d9                	mov    %bl,%cl
f010f531:	d3 ed                	shr    %cl,%ebp
f010f533:	89 e9                	mov    %ebp,%ecx
f010f535:	09 f1                	or     %esi,%ecx
f010f537:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f010f53b:	89 f9                	mov    %edi,%ecx
f010f53d:	d3 e0                	shl    %cl,%eax
f010f53f:	89 c5                	mov    %eax,%ebp
f010f541:	89 d6                	mov    %edx,%esi
f010f543:	88 d9                	mov    %bl,%cl
f010f545:	d3 ee                	shr    %cl,%esi
f010f547:	89 f9                	mov    %edi,%ecx
f010f549:	d3 e2                	shl    %cl,%edx
f010f54b:	8b 44 24 08          	mov    0x8(%esp),%eax
f010f54f:	88 d9                	mov    %bl,%cl
f010f551:	d3 e8                	shr    %cl,%eax
f010f553:	09 c2                	or     %eax,%edx
f010f555:	89 d0                	mov    %edx,%eax
f010f557:	89 f2                	mov    %esi,%edx
f010f559:	f7 74 24 0c          	divl   0xc(%esp)
f010f55d:	89 d6                	mov    %edx,%esi
f010f55f:	89 c3                	mov    %eax,%ebx
f010f561:	f7 e5                	mul    %ebp
f010f563:	39 d6                	cmp    %edx,%esi
f010f565:	72 19                	jb     f010f580 <__udivdi3+0xfc>
f010f567:	74 0b                	je     f010f574 <__udivdi3+0xf0>
f010f569:	89 d8                	mov    %ebx,%eax
f010f56b:	31 ff                	xor    %edi,%edi
f010f56d:	e9 58 ff ff ff       	jmp    f010f4ca <__udivdi3+0x46>
f010f572:	66 90                	xchg   %ax,%ax
f010f574:	8b 54 24 08          	mov    0x8(%esp),%edx
f010f578:	89 f9                	mov    %edi,%ecx
f010f57a:	d3 e2                	shl    %cl,%edx
f010f57c:	39 c2                	cmp    %eax,%edx
f010f57e:	73 e9                	jae    f010f569 <__udivdi3+0xe5>
f010f580:	8d 43 ff             	lea    -0x1(%ebx),%eax
f010f583:	31 ff                	xor    %edi,%edi
f010f585:	e9 40 ff ff ff       	jmp    f010f4ca <__udivdi3+0x46>
f010f58a:	66 90                	xchg   %ax,%ax
f010f58c:	31 c0                	xor    %eax,%eax
f010f58e:	e9 37 ff ff ff       	jmp    f010f4ca <__udivdi3+0x46>
f010f593:	90                   	nop

f010f594 <__umoddi3>:
f010f594:	55                   	push   %ebp
f010f595:	57                   	push   %edi
f010f596:	56                   	push   %esi
f010f597:	53                   	push   %ebx
f010f598:	83 ec 1c             	sub    $0x1c,%esp
f010f59b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f010f59f:	8b 74 24 34          	mov    0x34(%esp),%esi
f010f5a3:	8b 7c 24 38          	mov    0x38(%esp),%edi
f010f5a7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f010f5ab:	89 44 24 0c          	mov    %eax,0xc(%esp)
f010f5af:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f010f5b3:	89 f3                	mov    %esi,%ebx
f010f5b5:	89 fa                	mov    %edi,%edx
f010f5b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f010f5bb:	89 34 24             	mov    %esi,(%esp)
f010f5be:	85 c0                	test   %eax,%eax
f010f5c0:	75 1a                	jne    f010f5dc <__umoddi3+0x48>
f010f5c2:	39 f7                	cmp    %esi,%edi
f010f5c4:	0f 86 a2 00 00 00    	jbe    f010f66c <__umoddi3+0xd8>
f010f5ca:	89 c8                	mov    %ecx,%eax
f010f5cc:	89 f2                	mov    %esi,%edx
f010f5ce:	f7 f7                	div    %edi
f010f5d0:	89 d0                	mov    %edx,%eax
f010f5d2:	31 d2                	xor    %edx,%edx
f010f5d4:	83 c4 1c             	add    $0x1c,%esp
f010f5d7:	5b                   	pop    %ebx
f010f5d8:	5e                   	pop    %esi
f010f5d9:	5f                   	pop    %edi
f010f5da:	5d                   	pop    %ebp
f010f5db:	c3                   	ret    
f010f5dc:	39 f0                	cmp    %esi,%eax
f010f5de:	0f 87 ac 00 00 00    	ja     f010f690 <__umoddi3+0xfc>
f010f5e4:	0f bd e8             	bsr    %eax,%ebp
f010f5e7:	83 f5 1f             	xor    $0x1f,%ebp
f010f5ea:	0f 84 ac 00 00 00    	je     f010f69c <__umoddi3+0x108>
f010f5f0:	bf 20 00 00 00       	mov    $0x20,%edi
f010f5f5:	29 ef                	sub    %ebp,%edi
f010f5f7:	89 fe                	mov    %edi,%esi
f010f5f9:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f010f5fd:	89 e9                	mov    %ebp,%ecx
f010f5ff:	d3 e0                	shl    %cl,%eax
f010f601:	89 d7                	mov    %edx,%edi
f010f603:	89 f1                	mov    %esi,%ecx
f010f605:	d3 ef                	shr    %cl,%edi
f010f607:	09 c7                	or     %eax,%edi
f010f609:	89 e9                	mov    %ebp,%ecx
f010f60b:	d3 e2                	shl    %cl,%edx
f010f60d:	89 14 24             	mov    %edx,(%esp)
f010f610:	89 d8                	mov    %ebx,%eax
f010f612:	d3 e0                	shl    %cl,%eax
f010f614:	89 c2                	mov    %eax,%edx
f010f616:	8b 44 24 08          	mov    0x8(%esp),%eax
f010f61a:	d3 e0                	shl    %cl,%eax
f010f61c:	89 44 24 04          	mov    %eax,0x4(%esp)
f010f620:	8b 44 24 08          	mov    0x8(%esp),%eax
f010f624:	89 f1                	mov    %esi,%ecx
f010f626:	d3 e8                	shr    %cl,%eax
f010f628:	09 d0                	or     %edx,%eax
f010f62a:	d3 eb                	shr    %cl,%ebx
f010f62c:	89 da                	mov    %ebx,%edx
f010f62e:	f7 f7                	div    %edi
f010f630:	89 d3                	mov    %edx,%ebx
f010f632:	f7 24 24             	mull   (%esp)
f010f635:	89 c6                	mov    %eax,%esi
f010f637:	89 d1                	mov    %edx,%ecx
f010f639:	39 d3                	cmp    %edx,%ebx
f010f63b:	0f 82 87 00 00 00    	jb     f010f6c8 <__umoddi3+0x134>
f010f641:	0f 84 91 00 00 00    	je     f010f6d8 <__umoddi3+0x144>
f010f647:	8b 54 24 04          	mov    0x4(%esp),%edx
f010f64b:	29 f2                	sub    %esi,%edx
f010f64d:	19 cb                	sbb    %ecx,%ebx
f010f64f:	89 d8                	mov    %ebx,%eax
f010f651:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f010f655:	d3 e0                	shl    %cl,%eax
f010f657:	89 e9                	mov    %ebp,%ecx
f010f659:	d3 ea                	shr    %cl,%edx
f010f65b:	09 d0                	or     %edx,%eax
f010f65d:	89 e9                	mov    %ebp,%ecx
f010f65f:	d3 eb                	shr    %cl,%ebx
f010f661:	89 da                	mov    %ebx,%edx
f010f663:	83 c4 1c             	add    $0x1c,%esp
f010f666:	5b                   	pop    %ebx
f010f667:	5e                   	pop    %esi
f010f668:	5f                   	pop    %edi
f010f669:	5d                   	pop    %ebp
f010f66a:	c3                   	ret    
f010f66b:	90                   	nop
f010f66c:	89 fd                	mov    %edi,%ebp
f010f66e:	85 ff                	test   %edi,%edi
f010f670:	75 0b                	jne    f010f67d <__umoddi3+0xe9>
f010f672:	b8 01 00 00 00       	mov    $0x1,%eax
f010f677:	31 d2                	xor    %edx,%edx
f010f679:	f7 f7                	div    %edi
f010f67b:	89 c5                	mov    %eax,%ebp
f010f67d:	89 f0                	mov    %esi,%eax
f010f67f:	31 d2                	xor    %edx,%edx
f010f681:	f7 f5                	div    %ebp
f010f683:	89 c8                	mov    %ecx,%eax
f010f685:	f7 f5                	div    %ebp
f010f687:	89 d0                	mov    %edx,%eax
f010f689:	e9 44 ff ff ff       	jmp    f010f5d2 <__umoddi3+0x3e>
f010f68e:	66 90                	xchg   %ax,%ax
f010f690:	89 c8                	mov    %ecx,%eax
f010f692:	89 f2                	mov    %esi,%edx
f010f694:	83 c4 1c             	add    $0x1c,%esp
f010f697:	5b                   	pop    %ebx
f010f698:	5e                   	pop    %esi
f010f699:	5f                   	pop    %edi
f010f69a:	5d                   	pop    %ebp
f010f69b:	c3                   	ret    
f010f69c:	3b 04 24             	cmp    (%esp),%eax
f010f69f:	72 06                	jb     f010f6a7 <__umoddi3+0x113>
f010f6a1:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f010f6a5:	77 0f                	ja     f010f6b6 <__umoddi3+0x122>
f010f6a7:	89 f2                	mov    %esi,%edx
f010f6a9:	29 f9                	sub    %edi,%ecx
f010f6ab:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f010f6af:	89 14 24             	mov    %edx,(%esp)
f010f6b2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f010f6b6:	8b 44 24 04          	mov    0x4(%esp),%eax
f010f6ba:	8b 14 24             	mov    (%esp),%edx
f010f6bd:	83 c4 1c             	add    $0x1c,%esp
f010f6c0:	5b                   	pop    %ebx
f010f6c1:	5e                   	pop    %esi
f010f6c2:	5f                   	pop    %edi
f010f6c3:	5d                   	pop    %ebp
f010f6c4:	c3                   	ret    
f010f6c5:	8d 76 00             	lea    0x0(%esi),%esi
f010f6c8:	2b 04 24             	sub    (%esp),%eax
f010f6cb:	19 fa                	sbb    %edi,%edx
f010f6cd:	89 d1                	mov    %edx,%ecx
f010f6cf:	89 c6                	mov    %eax,%esi
f010f6d1:	e9 71 ff ff ff       	jmp    f010f647 <__umoddi3+0xb3>
f010f6d6:	66 90                	xchg   %ax,%ax
f010f6d8:	39 44 24 04          	cmp    %eax,0x4(%esp)
f010f6dc:	72 ea                	jb     f010f6c8 <__umoddi3+0x134>
f010f6de:	89 d9                	mov    %ebx,%ecx
f010f6e0:	e9 62 ff ff ff       	jmp    f010f647 <__umoddi3+0xb3>
